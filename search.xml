<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux deepin安装tensorflow、opencv、pytorh]]></title>
    <url>%2Fpost%2F5b3541b1.html</url>
    <content type="text"><![CDATA[Tensorflow不同版本要求与CUDA及CUDNN版本对应关系 安装深度学习的环境还是很复杂的，特别是 linux 下安装，新手更是闹不明白，笔者在安装的过程中因为执行错了命令，导致系统重做，各种血泪，本文是在重新安装的系统上实践出来的结果，仅供参考 安装anaconda 下载anaconda, 这里下载的版本是Anaconda3-5.3.1-Linux-x86_64。 运行sudo bash Anaconda3-5.3.1-Linux-x86_64进行安装，一路默认可以。我修改了默认的安装路径/root/anaconda3到/opt/anaconda3 最后一步，询问是否将 anaconda3 添加到 .bashrc , 选择 no。 配置环境变量，sudo vi /etc/profile 编辑 profile。 在文件最后加入 export PATH=$PATH:/opt/anaconda3/bin ， 注意这里将 $PATH 放在了前面，主要是为了保证系统中默认的python版本不被覆盖，可以保证系统的正常运行不受影响 保存 profile ， 运行 source /etc/profile 使配置生效。 运行conda --version ， 输出conda 4.5.11表示安装成功。 创建深度学习环境并激活 创建一个环境并制定python版本为3.6，conda create --name ai python=3.6 激活这个环境source activate ai，这时可以在终端命令行的开头看到多了(ai)，表示当前正在一个叫ai的虚拟环境里运行。 安装tensorflow在 anaconda 创建的 ai 虚拟环境中安装 tensorflow-gpu 的 1.11.0。123$ pip install tensorflow-gpu=1.11.0Collecting tensorflow-gpu==1.12.0 Downloading https://files.pythonhosted.org/packages/55/7e/bec4d62e9dc95e828922c6cec38acd9461af8abe749f7c9def25ec4b2fdb/tensorflow_gpu-1.11.0-cp36-cp36m-manylinux1_x86_64.whl (281.7MB)... 如果 tensorflow-gpu 的下载速度太慢，可以将下载链接复制到迅雷里下载，迅速会快很多。下载完成之后可以通过pip install /path/下载文件 来进行安装。 安装完成之后进行测试，新建一个test.py，并写入如下内容。1234567import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello))a = tf.constant(10)b = tf.constant(32)print(sess.run(a+b)) 然后python test.py运行，注意一下当前运行在 anaconda 的 ai 虚拟环境中。 安装opencv在 anaconda 创建的 ai 虚拟环境中，运行 pip install opencv-python 安装 opencv2。 安装完成之后进行测试，新建一个testCV2.py，并写入如下内容。12345678910#导入cv模块import cv2 as cv#读取图像，支持 bmp、jpg、png、tiff 等常用格式img = cv.imread("test.jpg")#创建窗口并显示图像cv.namedWindow("Image")cv.imshow("Image",img)cv.waitKey(0)#释放窗口cv.destroyAllWindows() 然后python testCV2.py运行，注意一下当前运行在 anaconda 的 ai 虚拟环境中。如果弹出窗口，窗口出现指定的路径的图片，就执行成功了。 安装pytorch打开pytorch官网，在首页选择 pytorch 的运行环境，获取对应的执行命令。 在 anaconda 创建的 ai 虚拟环境中，运行上图中的命令安装 pytorch。 安装完成之后进行测试，新建一个testPytorch.py，并写入如下内容。12345678910#导入cv模块import cv2 as cv#读取图像，支持 bmp、jpg、png、tiff 等常用格式img = cv.imread("test.jpg")#创建窗口并显示图像cv.namedWindow("Image")cv.imshow("Image",img)cv.waitKey(0)#释放窗口cv.destroyAllWindows() 然后python testPytorch.py运行，注意一下当前运行在 anaconda 的 ai 虚拟环境中。如果输出如下内容，说明环境搭建成功。 12tensor([1.], device='cuda:0')True 结束环境搭建是学习的第一步，整个环境花了一天的时间才算完成，因为linux 还在学习中，python还是第一次接触，整个操作的过程中真的是剪不断理还乱，好在最后总算完成了。]]></content>
      <tags>
        <tag>deepin</tag>
        <tag>环境安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin linux安装nvidia驱动、cuda9、cudnn7]]></title>
    <url>%2Fpost%2F5164653e.html</url>
    <content type="text"><![CDATA[cuda和gcc版本兼容的说明 安装深度学习的环境还是很复杂的，特别是 linux 下安装，新手更是闹不明白，笔者在安装的过程中因为执行错了命令，导致系统重做，各种血泪，本文是在重新安装的系统上实践出来的结果，仅供参考 安装nvidia驱动 安装驱动 1sudo apt install nvidia-smi nvidia-driver 调整显卡管理方案 使用系统自带的 显卡驱动管理器 将显卡方案设置为 NV-PRIME。 重新启动系统，应该能够看到旋转的茶壶画面 验证安装成功与否，打开终端输入命令nvidia-smi，如果出现类似下图，就说明安装成功了。 安装cuda驱动安装完成后，就可以安装 cuda 了，不过在此之前还需要检查下gcc和g++的版本是否在 4.9~6.0之间，deepin自带的是7.+，需要降级。12345sudo apt install g++-6 gcc-6cd /usr/binsudo rm gcc g++sudo ln -s g++-6 g++sudo ln -s gcc-6 gcc 可以正式开始安装，cuda建议使用官方的安装的包，不要使用默认安装源内的版本，容易出现不兼容的问题。 下载 cuda 9.0，这里选择了如下图。 使用sudo sh cuda_9.0.176_384.81_linux.run安装，安装过程中跳过 nvidia 驱动的安装，因为在上面我们已经安装过了，其他的依次正常安装即可。 将cuda添加到环境变量，在~/.bashrc文件中末尾加上 1234# cudaexport CUDA_HOME=/usr/local/cuda-9.0export LD_LIBRARY_PATH=$CUDA_HOME/lib64:$LD_LIBRARY_PATHexport PATH=$CUDA_HOME/bin:$PATH 1$ source ~/.bashrc 查看版本 12345$ nvcc --versionnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2017 NVIDIA CorporationBuilt on Fri_Sep__1_21:08:03_CDT_2017Cuda compilation tools, release 9.0, V9.0.176 运行 cuda samples 测试 进入要运行的测试程序，cd ~/NVIDIA_CUDA-9.0_Samples/1_Utilities/deviceQuery 编译 make 123"/usr/local/cuda-9.0"/bin/nvcc -ccbin g++ -m64 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_70,code=sm_70 -gencode arch=compute_70,code=compute_70 -o deviceQuery deviceQuery.o mkdir -p ../../bin/x86_64/linux/releasecp deviceQuery ../../bin/x86_64/linux/release 运行编译结果./deviceQuery 12345678910111213141516171819202122232425262728293031323334353637383940414243./deviceQuery Starting... CUDA Device Query (Runtime API) version (CUDART static linking)Detected 1 CUDA Capable device(s)Device 0: "GeForce 940MX" CUDA Driver Version / Runtime Version 9.1 / 9.0 CUDA Capability Major/Minor version number: 5.0 Total amount of global memory: 2004 MBytes (2101870592 bytes) ( 3) Multiprocessors, (128) CUDA Cores/MP: 384 CUDA Cores GPU Max Clock rate: 1189 MHz (1.19 GHz) Memory Clock rate: 2505 Mhz Memory Bus Width: 64-bit L2 Cache Size: 1048576 bytes Maximum Texture Dimension Size (x,y,z) 1D=(65536), 2D=(65536, 65536), 3D=(4096, 4096, 4096) Maximum Layered 1D Texture Size, (num) layers 1D=(16384), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(16384, 16384), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 2048 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 1 copy engine(s) Run time limit on kernels: Yes Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled Device supports Unified Addressing (UVA): Yes Supports Cooperative Kernel Launch: No Supports MultiDevice Co-op Kernel Launch: No Device PCI Domain ID / Bus ID / location ID: 0 / 1 / 0 Compute Mode: &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 9.1, CUDA Runtime Version = 9.0, NumDevs = 1Result = PASS 这样 cuda 的安装就大功告成了。 cudnn 的安装打开cudnn 下载地址 下载 cuda-9.0 对应版本的 cudnn，需要注意的是 cudnn 需要注册登录才能下载。 这里下载的是 cuDNN 7.5 for CUDA 9.0 对应的linux版。 下载完成后 tar -zxvf cudnn-9.1-linux-x64-v7.1.tgz ， 将解压出来的cuda文件夹复制到/usr/local。 关键的步骤来了123$ cd /etc/ld.so.conf.d$ touch cuda.conf$ vi cuda.conf 在conda.conf中输入如下内容12/usr/local/cuda/lib64/usr/local/cuda-9.0/lib64 之所以说是关键步骤，因为经过无数次的测试验证，这样的配置可以解决 tensorflow 运行时出现的ImportError:libcublas.so.9.0: cannot open shared object file: No such file or directory 和 ImportError:libcudnn.so.7: cannot open shared object file: No such file or directory 结束不断学习思考是不断进步的保证]]></content>
      <tags>
        <tag>deepin</tag>
        <tag>环境安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下多个git账号的配置]]></title>
    <url>%2Fpost%2F5f8b2e94.html</url>
    <content type="text"><![CDATA[周末在 deepin linux 上安装深度学习环境的时候，把系统搞挂了，找了一下备份的系统，最近的还在去年 4 月份，思前想后，最后选择了重装系统，顺便记录下笔记。下面的操作实在全新安装的系统上进行了。 安装gitgit地址在这里，今天用的是 deepin 所以直接使用源安装。 1$ apt-get install git 全局配置 name 和 email12$ git config --global user.name "xxx"$ git config --global user.email "eamil@qq.com" 生成公钥创建~/xingmu/.ssh目录，并进入。123$ cd ~$ mkdir .ssh$ cd .ssh 在~/xingmu/.ssh目录下，用 ssh-keygen 命令生成一组新的 id_rsa_new 和 id_rsa_new.pub，我这里需要使用 github 和 gitee(码云)两个平台，所以需要执行两次命令，分别生成 id_rsa_github/id_rs_github.pub 和 id_rsa_gitee/id_rsa_gitee.pub两组。 1$ ssh-keygen -t rsa -C "xxx@xxx.com" 需要注意的是，平时都是默认生成 id_rsa 和 id_rsa.pub 。现在要在第一个提示输入出现时分别输入带有表示意义的名字，以便于识别，这里我输入的是 id_rsa_github 和 id_rsa_gitee。 配置config将公钥分别配置到对应的 git 平台上，然后在~/xingmu/.ssh目录下新建 config 文件，配置参考如下。123456789101112131415161718192021## github# 域名地址的别名Host github# 这个是真实的域名地址 Hostname github.com# 配置使用用户名 User xxx@xx.com# 这里是id_rsa的目录位置 IdentityFile ~/.ssh/id_rsa_github ## 码云# 域名地址的别名Host gitee# 这个是真实的域名地址 Hostname gitee.com# 配置使用用户名 User xxx@xx.com# 这里是id_rsa的目录位置 IdentityFile ~/.ssh/id_rsa_gitee## 以下第三个或者更多 测试1234$ ssh -T git@githubHi your name! You've successfully authenticated, but GitHub does not provide shell access.$ ssh -T git@giteeHi xingmu! You've successfully authenticated, but GITEE.COM does not provide shell access. 如果出现如下的提示，选择 yes 继续就可以了 然后就可以愉快的玩耍了！！]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin中安装jdk]]></title>
    <url>%2Fpost%2F36da9d0d.html</url>
    <content type="text"><![CDATA[下载jdk 解压 123456$ mv /opt$ mkdir java$ cd java$ mv ~/Downloads/jdk-8u144-linux-x64.tar.gz .$ tar -zxvf jdk-8u144-linux-x64.tar.gz$ mv jdk-8u144 jdk1.8 设置环境变量 1$ sudo vi /etc/profile 在最后加入如下内容12345#set java environmentexport JAVA_HOME=/opt/java/jdk1.8export JRE_HOME=/opt/java/jdk1.8/jreexport CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 让修改生效1$ source /etc/profile 验证1234$ java -versionjava version &quot;1.8.0_144&quot;Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)]]></content>
      <tags>
        <tag>deepin</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux在终端通过命令打开文件夹]]></title>
    <url>%2Fpost%2Fc1433548.html</url>
    <content type="text"><![CDATA[在 deepin linux 中提供了一个叫 dde-file-manager 的命令可以在命令行打开制定路径的文件夹。 1234# 打开当前位置的文件夹dde-file-manager .# 打开指定位置的文件夹dde-file-manager /usr/local 使用nautilus linux 图形化桌面 GNOME 包括了一个叫做 Nautilus 的文件管理器，可以通过安装 nautilus 来使用 nautilus 命令，在命令窗口中直接打开指定的文件夹。123456# 安装nautilussudo apt-get install nautilus# 打开当前位置的文件夹nautilus .# 打开指定位置的文件夹nautilus /usr/local]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea消息框等界面中文显示成小方块]]></title>
    <url>%2Fpost%2F3050fa27.html</url>
    <content type="text"><![CDATA[操作系统环境是deepin linux，版本是 2018.3 ，搜索窗口、帮助窗口、消息窗口等出现乱码，idea、webstorm、pycharm 都出现这样的情况，如下图所示。 这个乱码跟编码格式无关，根本原因是 IDE 的界面主题使用的字体，显示中文有 bug ，所以只有设置下中文字体就可以解决了，我这里设置的 微软雅黑。 另外说一下就是，在 deepin linux 中如果无法找到中文字体，可以去网上下载，通过系统自带的字体安装器安装到系统，然后重启 IDE 就可以选择了。]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]阮一峰-IntersectionObserver API 使用教程]]></title>
    <url>%2Fpost%2F3d5f3b65.html</url>
    <content type="text"><![CDATA[原文地址一直以来，检测元素的可视状态或者两个元素的相对可视状态都不是件容易事，毕竟大部分解决办法并非完全可靠，也极易拖慢整个网站的性能。然而，随着网页发展，对上述检测的需求也随之增加了。多种情况下都需要用到元素交集变化的信息，比如： 当页面滚动时，懒加载图片或其他内容。 实现“可无限滚动”网站，也就是当用户滚动网页时直接加载更多内容，无需翻页。 为计算广告收益，检测其广告元素的曝光情况。 根据用户是否已滚动到相应区域来灵活开始执行任务或动画。 上图的绿色方块不断滚动，顶部会提示它的可见性。 传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，不断调用getBoundingClientRect()来计算元素相对位置，会造成频繁的回流和重绘，而且Element.getBoundingClientRect()运行在主线程上，容易造成性能问题。 目前有一个新的 IntersectionObserver API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。 Intersection Observer API 会注册一个回调方法，每当期望被监视的元素进入或者退出另外一个元素的时候(或者浏览器的视口)该回调方法将会被执行，或者两个元素的交集部分大小发生变化的时候回调方法也会被执行。通过这种方式，网站将不需要为了监听两个元素的交集变化而在主线程里面做任何操作，并且浏览器可以帮助我们优化和管理两个元素的交集变化。 API1var io = new IntersectionObserver(callback, option); 上面代码中，IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数，callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。 构造函数的返回值是一个观察器实例。实例的 observe 方法可以指定观察哪个 DOM 节点。 12345678// 开始观察io.observe(document.getElementById('example'));// 停止观察io.unobserve(element);// 关闭观察器io.disconnect(); 上面代码中，observe 的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。 12io.observe(elementA);io.observe(elementB); callback 参数目标元素的可见性变化时，就会调用观察器的回调函数 callback。 callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。 12345var io = new IntersectionObserver( entries =&gt; &#123; console.log(entries); &#125;); 上面代码中，回调函数采用的是箭头函数的写法。callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。 IntersectionObserverEntry 对象IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。12345678910111213141516171819&#123; time: 3893.92, rootBounds: ClientRect &#123; bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, boundingClientRect: ClientRect &#123; // ... &#125;, intersectionRect: ClientRect &#123; // ... &#125;, intersectionRatio: 0.54, target: element&#125; 每个属性的含义如下。 time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target：被观察的目标元素，是一个 DOM 节点对象 rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null boundingClientRect：目标元素的矩形区域的信息 intersectionRect：目标元素与视口（或根元素）的交叉区域的信息 intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0 上图中，灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的intersectionRatio图中都已经注明。 我写了一个 Demo，演示IntersectionObserverEntry对象。注意，这个 Demo 只能在 Chrome 51+ 运行。 实例：惰性加载（lazy load）有时，我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做”惰性加载”。 有了 IntersectionObserver API，实现起来就很容易了。123456789101112131415161718function query(selector) &#123; return Array.from(document.querySelectorAll(selector));&#125;var observer = new IntersectionObserver( function(changes) &#123; changes.forEach(function(change) &#123; var container = change.target; var content = container.querySelector('template').content; container.appendChild(content); observer.unobserve(container); &#125;); &#125;);query('.lazy-loaded').forEach(function (item) &#123; observer.observe(item);&#125;); 上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。 实例：无限滚动无限滚动（infinite scroll）的实现也很简单。123456789101112var intersectionObserver = new IntersectionObserver( function (entries) &#123; // 如果不可见，就返回 if (entries[0].intersectionRatio &lt;= 0) return; loadItems(10); console.log('Loaded new items'); &#125;);// 开始观察intersectionObserver.observe( document.querySelector('.scrollerFooter')); 无限滚动时，最好在页面底部有一个页尾栏（又称sentinels）。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。这样做的好处是，不需要再一次调用observe()方法，现有的IntersectionObserver可以保持使用。 Option 对象IntersectionObserver 构造函数的第二个参数是一个配置对象。它可以设置以下属性。 threshold 属性threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。1234567new IntersectionObserver( entries =&gt; &#123; /* ... */ &#125;, &#123; threshold: [0, 0.25, 0.5, 0.75, 1] &#125;); 用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。 root 属性，rootMargin 属性很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。 IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。123456789var opts = &#123; root: document.querySelector('.container'), rootMargin: "500px 0px"&#125;;var observer = new IntersectionObserver( callback, opts); 上面代码中，除了 root 属性，还有rootMargin属性。后者定义根元素的 margin，用来扩展或缩小 rootBounds 这个矩形的大小，从而影响 intersectionRect 交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。 这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。 注意点IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。 规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。 兼容性 Chrome 51+（发布于 2016-05-25） Android 5+ （Chrome 56 发布于 2017-02-06） Edge 15 （2017-04-11） iOS 不支持 WICG 提供了一个 Polyfill。 参考图片懒加载的几种实现方式 MDN]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>dom</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现react-redux之五Provider终篇]]></title>
    <url>%2Fpost%2F83f2f127.html</url>
    <content type="text"><![CDATA[现在代码中依赖 context 只有 Index 组件了123456789101112131415161718class Index extends Component &#123; static childContextTypes = &#123; store: PropTypes.object &#125;; getChildContext() &#123; return &#123; store &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ); &#125;&#125; 这里使用 context 的主要是为了将 store 放入 context 里面，方便子组件 connect 的时候可以拿得到 store。我们可以将这块的内容抽出来单独做个组件，并将需要使用 store 的组件作为这个组件的子组件。 这个组件命名为 Provider （提供者）。新增一个 src/Provider.js，代码如下：1234567891011121314151617181920212223242526272829import React from "react";import PropTypes from "prop-types";class Provider extends React.Component &#123; static childContextTypes = &#123; store: PropTypes.object.isRequired &#125;; static propTypes = &#123; store: PropTypes.object &#125;; getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return ( &lt;React.Fragment&gt; &#123;this.props.children&#125; &lt;/React.Fragment&gt; ); &#125;&#125;export default Provider; Provider 做的事情也很简单，它就是一个容器组件，会把嵌套的内容原封不动作为自己的子组件渲染出来。它还会把外界传给它的 props.store 放到 context，这样子组件 connect 的时候都可以获取到。 然后重构 src/index.js:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; Component &#125; from "react";import ReactDOM from "react-dom";import Header from "./Header";import Content from "./Content";import "./index.css";import Provider from "./Provider";function createStore(reducer) &#123; let events = []; let state = null; let store = &#123; subscribe: (event) =&gt; events.push(event), dispatch: (action) =&gt; &#123; state = reducer(state, action); events.forEach((event) =&gt; event()); &#125;, getState: () =&gt; state &#125;; // 初始化state store.dispatch(&#123;&#125;); return store;&#125;function themeReducer(state, action) &#123; if (!state) &#123; return &#123; themeColor: "red" &#125;; &#125; switch (action.type) &#123; case "CHANGE_THEME_COLOR": return &#123; ...state, themeColor: action.themeColor &#125;; default: return state; &#125;&#125;const store = createStore(themeReducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/Provider&gt;, document.getElementById("root")); 这样我们就把所有关于 context 的代码从组件里面删除了。 现在通过这种方式大家不仅仅知道了 React-redux 的基础概念和用法，而且还知道这些概念到底是解决什么问题，为什么 React-redux 这么奇怪，为什么要 connect，为什么要 mapStateToProps 和 mapDispatchToProps，什么是 Provider，我们通过解决一个个问题就知道它们到底为什么要这么设计的了。 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现react-redux之四mapDispatchToProps]]></title>
    <url>%2Fpost%2Fa24de6ae.html</url>
    <content type="text"><![CDATA[重构 ThemeSwitch 组件除了需要 store 里面的数据，还需要通过 store 的 dispatch 来修改数据。现在 connect 还提供不了这个功能，需要进一步改进 connect。 仿照给 connect 传入 mapStateToProps 函数来达到获取指定数据的效果，给 connect 再提供一个 mapDispatchToProps 函数来告诉 connect 组件需要如何调用 dispatch。这个函数应该是这样的：1234567const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onSwitchColor: (color) =&gt; &#123; dispatch(&#123; type: "CHANGE_THEME_COLOR", themeColor: color &#125;); &#125; &#125;;&#125;; mapDispatchToProps 也是返回一个对象，和 mapStateToProps 不同的地方是传入的参数不是 state ，而是 dispatch。下面来修改 connect ，让他可以处理 mapDispatchToProps。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React from "react";import PropTypes from "prop-types";function connect(mapStateToProps, mapDispatchToProps) &#123; return (WrappedComponent) =&gt; &#123; class Connect extends React.Component &#123; static contextTypes = &#123; store: PropTypes.object &#125;; state = &#123; allProps: &#123;&#125; &#125;; componentWillMount() &#123; const &#123; store &#125; = this.context; // 挂载的时候，进行第一次渲染 this.updateProps(); // 然后订阅 store 的后续变化，并更新 store.subscribe(() =&gt; this.updateProps()); &#125; updateProps() &#123; const &#123; store &#125; = this.context; const state = store.getState(); // 额外传入 props，让获取数据更加灵活方便 let stateProps = mapStateToProps ? mapStateToProps(state, this.props) : &#123;&#125;; let dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125;; this.setState(&#123; // 整合普通的 props 和从 state 生成的 props allProps: &#123; ...this.props, ...stateProps, ...dispatchProps &#125; &#125;); &#125; render() &#123; // let &#123; &#125; = this.props; return ( &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; ); &#125; &#125; return Connect; &#125;;&#125;export default connect; 这时候我们就可以重构 ThemeSwitch，让它摆脱 store.dispatch 和 context。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import connect from "./connect";class ThemeSwitch extends Component &#123; static propTypes = &#123; color: PropTypes.string, switchColor: PropTypes.func.isRequired &#125;; // 更新store中的颜色 handleSwitchColor(color) &#123; this.props.switchColor(color); &#125; render() &#123; return ( &lt;div&gt; &lt;button style=&#123;&#123; color: this.props.themeColor &#125;&#125; onClick=&#123;this.handleSwitchColor.bind(this, "red")&#125; &gt; 设置主题颜色red &lt;/button&gt; &lt;button style=&#123;&#123; color: this.props.themeColor &#125;&#125; onClick=&#123;this.handleSwitchColor.bind(this, "green")&#125; &gt; 设置主题颜色green &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;function mapStateToProps(state, props) &#123; return &#123; themeColor: state.themeColor &#125;;&#125;function mapDispatchToProps(dispatch, props) &#123; return &#123; switchColor: (color) =&gt; &#123; dispatch(&#123; type: "CHANGE_THEME_COLOR", themeColor: color &#125;); &#125; &#125;;&#125;export default connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch); 这时候这三个组件的重构都已经完成了，代码大大减少、不依赖 context，并且功能和原来一样。 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现react-redux之三connect 和 mapStateToProps]]></title>
    <url>%2Fpost%2Fe08ec58f.html</url>
    <content type="text"><![CDATA[仔细看上一节完成的组件会发现两个问题： 每个组件中都有大量重复获取 context ，添加 store 监听的逻辑 每个组件都依赖于 context ，使组件基本丧失了可复用性。 对于第一个大量重复逻辑的问题，可以通过高阶组件抽取重复的逻辑来解决。高阶组件就是一个函数，传给它一个组件，它返回一个新的组件，它的作用就是用于代码复用，可以把组件之间可复用的代码、逻辑抽离到高阶组件当中。新的组件和传入的组件通过 props 传递信息 对于第二个问题，首先需要知道可复用组件需要具有什么样的特征，在 React 中，如果一个组件的渲染只依赖于外界传进去的 props 和自己的 state，而并不依赖于其他的任何外界数据，也就是说像纯函数一样，给它什么，它就吐出（渲染）什么出来。这种组件的复用性是最强的，别人使用的时候根本不用担心任何事情，只要看看 PropTypes 它能接受什么参数，然后把参数传进去控制它就行了。 有了思路，下面就来修改代码，首先需要一个高阶组件来协助从 context 中获取数据，然后用一个傻瓜组件来帮助提交组件的复用性。 将这个高阶组件命名为 connect，他的作用是将 context 和 可复用组件连接起来。 123456789101112131415161718import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";export default connect = (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125;; // TODO: 如何从 store 取数据？ render() &#123; return &lt;WrappedComponent /&gt;; &#125; &#125; return Connect;&#125;; connect 函数接受一个组件 WrappedComponent 作为参数，把这个组件包含在一个新的组件 Connect 里面，Connect 会去 context 里面取出 store。现在要把 store 里面的数据取出来通过 props 传给 WrappedComponent。 但是每个传进去的组件需要 store 里面的数据都不一样的，所以除了给高阶组件传入 Dumb 组件以外，还需要告诉高级组件我们需要什么数据，高阶组件才能正确地去取数据。为了解决这个问题，我们可以给高阶组件传入类似下面这样的函数：12345678const mapStateToProps = (state,props) =&gt; &#123; return &#123; themeColor: state.themeColor, themeName: state.themeName, fullName: `$&#123;state.firstName&#125; $&#123;state.lastName&#125;` ... &#125;;&#125;; 这个函数会接受 store.getState() 的结果和给 WrappedComponent 传递的 props 作为参数，然后返回一个对象。mapStateTopProps 相当于告知了 Connect 应该如何去 store 里面取数据，然后可以把这个函数的返回结果传给被包装的组件。 connect 现在是接受一个参数 mapStateToProps，然后返回一个函数，这个返回的函数才是高阶组件。它会接受一个组件作为参数，然后用 Connect 把组件包装以后再返回。 connect 的用法是：123456const mapStateToProps = (state) =&gt; &#123; return &#123; themeColor: state.themeColor &#125;;&#125;;Header = connect(mapStateToProps)(Header); 现在根据上面的描述，给 connect 加上 mapStateToProps 和 数据变化的监听，connect 完整的代码应该是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React from "react";import PropTypes from "prop-types";function connect(mapStateToProps) &#123; return (WrappedComponent) =&gt; &#123; class Connect extends React.Component &#123; static contextTypes = &#123; store: PropTypes.object &#125;; state = &#123; allProps: &#123;&#125; &#125;; componentWillMount() &#123; const &#123; store &#125; = this.context; // 挂载的时候，进行第一次渲染 this.updateProps(); // 然后订阅 store 的后续变化，并更新 store.subscribe(() =&gt; this.updateProps()); &#125; updateProps() &#123; const &#123; store &#125; = this.context; const state = store.getState(); // 额外传入 props，让获取数据更加灵活方便 let stateProps = mapStateToProps(state, this.props); this.setState(&#123; // 整合普通的 props 和从 state 生成的 props allProps: &#123; ...this.props, ...stateProps &#125; &#125;); &#125; render() &#123; // let &#123; &#125; = this.props; return ( &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; ); &#125; &#125; return Connect; &#125;;&#125;export default connect; 组件 Connect 的 state.allProps，它是一个对象，用来保存需要传给被包装组件的所有的参数。生命周期 componentWillMount 会调用调用 updateProps 进行初始化，然后通过 store.subscribe 监听数据变化重新调用 updateProps。 为了让 connect 返回新组件和被包装的组件使用参数保持一致，我们会把所有传给 Connect 的 props 原封不动地传给 WrappedComponent。所以在 updateProps 里面会把 stateProps 和 this.props 合并到 this.state.allProps 里面，再通过 render 方法把所有参数都传给 WrappedComponent。 现在使用 connect 修改 Header.js、Content.js。 src/Header.js123456789101112131415161718192021222324import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import connect from "./connect";class Header extends Component &#123; static propTypes = &#123; color: PropTypes.string &#125;; render() &#123; return ( &lt;h1 style=&#123;&#123; color: this.props.themeColor &#125;&#125;&gt;React-Redux是什么&lt;/h1&gt; ); &#125;&#125;function mapStateToProps(state, props) &#123; return &#123; themeColor: state.themeColor &#125;;&#125;export default connect(mapStateToProps)(Header); src/Content.js12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import connect from "./connect";import ThemeSwitch from "./ThemeSwitch";class Content extends Component &#123; static propTypes = &#123; themeColor: PropTypes.string &#125;; render() &#123; return ( &lt;div style=&#123;&#123; color: this.props.themeColor &#125;&#125;&gt; &lt;p&gt;React-Redux是Redux的官方React绑定库。它能够使你的React组件从Redux store中读取数据，并且向store分发actions以更新数据&lt;/p&gt; &lt;ThemeSwitch /&gt; &lt;/div&gt; ); &#125;&#125;function mapStateToProps(state) &#123; return &#123; themeColor: state.themeColor &#125;;&#125;export default connect(mapStateToProps)(Content); 现在通过 connect 抽取了使用 context 产生的重复逻辑，并提高了 Header 和 Context 组件的复用性，后面继续重构 ThemeSwitch 组件。 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现react-redux之二组合context和store]]></title>
    <url>%2Fpost%2Fff5d605f.html</url>
    <content type="text"><![CDATA[在 src/index.js 中添加模拟 redux 时创建的 createStore 函数，并创建一个 themeReducer 用来初始化 state 并维护 state 的更新，通过 themeReducer 生成一个 store。然后将 store 放到 Index 组件的 context 里面，这个每个子组件都可以获取到 store 了。 修改 src/index.js:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import ReactDOM from "react-dom";import Header from "./Header";import Content from "./Content";import "./index.css";function createStore(reducer) &#123; let events = []; let state = null; let store = &#123; subscribe: (event) =&gt; events.push(event), dispatch: (action) =&gt; &#123; state = reducer(state, action); events.forEach((event) =&gt; event()); &#125;, getState: () =&gt; state &#125;; // 初始化state store.dispatch(&#123;&#125;); return store;&#125;function themeReducer(state, action) &#123; if (!state) &#123; return &#123; themeColor: "red" &#125;; &#125; switch (action.type) &#123; case "CHANGE_THEME_COLOR": return &#123; ...state, themeColor: action.themeColor &#125;; default: return state; &#125;&#125;const store = createStore(themeReducer);class Index extends Component &#123; static childContextTypes = &#123; store: PropTypes.object &#125;; getChildContext() &#123; return &#123; store &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById("root")); 然后修改 src/Header.js 和 src/Context.js，让它从 Index 的 context 里面获取 store，并且获取里面的 themeColor 状态来设置自己的颜色。 src/Header.js1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";class Header extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125;; state = &#123; themeColor: "" &#125;; componentWillMount() &#123; const &#123; store &#125; = this.context; // 挂载的时候，进行第一次渲染 this.updateThemeColor(); // 然后订阅 store 的后续变化，并更新 store.subscribe(() =&gt; this.updateThemeColor()); &#125; updateThemeColor() &#123; let state = this.context.store.getState(); this.setState(&#123; themeColor: state.themeColor &#125;); &#125; // static getDerivedStateFromProps(nextProps, prevState) &#123; // // &#125; render() &#123; return ( &lt;h1 style=&#123;&#123; color: this.state.themeColor &#125;&#125;&gt;React-Redux是什么&lt;/h1&gt; ); &#125;&#125;export default Header; src/Context.js 123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import ThemeSwitch from "./ThemeSwitch";class Content extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125;; componentWillMount() &#123; const &#123; store &#125; = this.context; // 挂载的时候，进行第一次渲染 this.updateThemeColor(); // 然后订阅 store 的后续变化，并更新 store.subscribe(() =&gt; this.updateThemeColor()); &#125; updateThemeColor() &#123; let state = this.context.store.getState(); this.setState(&#123; themeColor: state.themeColor &#125;); &#125; render() &#123; return ( &lt;div style=&#123;&#123; color: this.state.themeColor &#125;&#125;&gt; &lt;p&gt;React-Redux是Redux的官方React绑定库。它能够使你的React组件从Redux store中读取数据，并且向store分发actions以更新数据&lt;/p&gt; &lt;ThemeSwitch /&gt; &lt;/div&gt; ); &#125;&#125;export default Content; 修改 src/ThemeSwitch.js，添加颜色更新及两个按钮的点击事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";class ThemeSwitch extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125;; state = &#123; themeColor: "" &#125;; componentWillMount() &#123; let &#123; store &#125; = this.context; this.updateThemeColor(); store.subscribe(() =&gt; &#123; this.updateThemeColor(); &#125;); &#125; updateThemeColor() &#123; const &#123; store &#125; = this.context; const state = store.getState(); this.setState(&#123; themeColor: state.themeColor &#125;); &#125; // 更新store中的颜色 handleSwitchColor(color) &#123; let &#123; store &#125; = this.context; store.dispatch(&#123; type: "CHANGE_THEME_COLOR", themeColor: color &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;button style=&#123;&#123; color: this.state.themeColor &#125;&#125; onClick=&#123;this.handleSwitchColor.bind(this, "red")&#125; &gt; 设置主题颜色red &lt;/button&gt; &lt;button style=&#123;&#123; color: this.state.themeColor &#125;&#125; onClick=&#123;this.handleSwitchColor.bind(this, "green")&#125; &gt; 设置主题颜色green &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default ThemeSwitch; 到此 store 和 context 已经结合起来，看起来功能完成的不错，就是代码稍微啰嗦，后面继续优化。 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现react-redux之一初步]]></title>
    <url>%2Fpost%2Fe5e94e1.html</url>
    <content type="text"><![CDATA[通过 redux 动手实现可以看到它并不复杂，很多看起来奇怪的约定或者约束都是为了解决特定问题而存在的，把这些问题想清楚之后就不难理解那些奇怪的约定了，下面我们试着来实现下可以使 React 和 redux 相互结合一个库 react-redux。 在 React 中应用的状态存在可能被多个组件依赖或者影响，而 React 并没有提供很好的解决方案，我们只能把状态提升到依赖或者影响这个状态的所有组件的公共父组件上，我们把这种行为叫做状态提升。但是需求不停变化，导致状态一直在不断的提升，然后一层层的传递，这显然不是我们想要的。 后来 React 提供了 context 的概念，将共享状态放到父组件的 context 上，这个父组件下所有的子组件 都可以从 context 中直接获取状态，而不要一层层传递了。但是直接从 context 里面存放、获取数据增强了组件的耦合性；并且所有组件都可以修改 context 里面的状态就像谁都可以修改共享状态一样，导致让程序不可预测。 而 redux 中的 store 的数据不是谁都能修改，而是约定只能通过 dispatch 来进行修改，这样的话将 redux 和 context 结合起来，每个组件既可以去 context 里面获取 store 从而获取状态，又不用担心它们乱改数据了。下面我们来试一下。 使用 create-react-app 新建一个工程，然后安装 prop-types , 删除 src 下面除 index.js和index.css之外的文件，然后在 src 下面新建三个文件 Header.js、Content.js、ThemeSwitch.js。 src/Header.js： 123456789101112import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";class Header extends Component &#123; render() &#123; return ( &lt;h1&gt;React-Redux是什么&lt;/h1&gt; ); &#125;&#125;export default Header; src/ThemeSwitch.js： 123456789101112131415import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";class ThemeSwitch extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;button&gt;设置主题颜色red&lt;/button&gt; &lt;button&gt;设置主题颜色green&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default ThemeSwitch; src/Content.js: 12345678910111213141516import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import ThemeSwitch from "./ThemeSwitch";class Content extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;React-Redux是Redux的官方React绑定库。它能够使你的React组件从Redux store中读取数据，并且向store分发actions以更新数据&lt;/p&gt; &lt;ThemeSwitch /&gt; &lt;/div&gt; ); &#125;&#125;export default Content; 修改 src/index.js: 12345678910111213141516171819202122import React, &#123; Component &#125; from "react";import PropTypes from "prop-types";import ReactDOM from "react-dom";import Header from "./Header";import Content from "./Content";import "./index.css";class Index extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById("root")); 然后 npm start 启动项目，打开页面就可以看到效果。 目前只是完成项目搭建，状态和逻辑都还没添加，后面继续。 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的宏任务和微任务]]></title>
    <url>%2Fpost%2F54c4052.html</url>
    <content type="text"><![CDATA[执行机制 注意: 主线程中的代码执行也是宏任务，在主线程代码执行结束后，会先去检查也没有微任务，如果有先执行微任务，然后再去查看事件队列中还有没有需要执行的宏任务。 宏任务的优先级: 主代码块 &gt; setImmediate &gt; MessageChannel &gt; requestAnimationFrame &gt; setTimeout / setInterval微任务的优先级: process.nextTick &gt; Promise &gt; MutationObserver 如果在一个微任务中递归新增微任务，是可以造成类似死循环的效果 async/await函数因为，async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种。所以在使用await关键字与Promise.then效果类似， async函数在await之前的代码都是同步执行的，可以理解为await之前的代码属于new Promise时传入的代码，await之后的所有代码都是在Promise.then中的回调 浏览器中的表现在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？ 假设有这样的一些DOM结构：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #outer &#123; padding: 20px; background: #616161; &#125; #inner &#123; width: 100px; height: 100px; background: #757575; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; const $inner = document.querySelector("#inner"); const $outer = document.querySelector("#outer"); function handler() &#123; console.log("click"); // 直接输出 Promise.resolve().then(_ =&gt; console.log("promise")); // 注册微任务 setTimeout(_ =&gt; console.log("timeout")); // 注册宏任务 requestAnimationFrame(_ =&gt; console.log("animationFrame")); // 注册宏任务 $outer.setAttribute("data-random", Math.random()); // DOM属性修改，触发微任务 &#125; // 注册微任务 new MutationObserver(_ =&gt; &#123; console.log("observer"); &#125;).observe($outer, &#123; attributes: true &#125;); $inner.addEventListener("click", handler); $outer.addEventListener("click", handler); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果点击#inner，其执行顺序一定是：click -&gt; promise -&gt; observer -&gt; click -&gt; promise -&gt; observer -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。 因为 click 触发了一个宏任务 handler，按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了 Promise 和 MutationObserver 两个微任务，遂执行之。 因为click事件会冒泡，所以同时也触发了 #outer 的 click 事件，再次执行了 handler 函数，这个是一个同步的过程，所以会优先执行冒泡的事件(早于其他的宏任务)，重复 #inner 的结果。 在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务，然后执行了 animationFrame 和 timeout。需要注意的一点是，因为我们触发了 setAttribute ，实际上修改了 DOM 的属性，这会导致页面的重绘，而这个 setAttribute 的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。 在Node中的表现Node也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。 setImmediate与setTimeout的区别在官方文档中的定义，setImmediate 为一次 Event Loop 执行完毕后调用。setTimeout 则是通过计算一个延迟时间后进行执行。 但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发。因为如果主进程中先注册了两个任务，然后执行的代码耗时超过setTimeout 的延迟时间，而这时定时器已经处于可执行回调的状态了。所以会先执行定时器，而执行完定时器以后才是结束了一次 Event Loop ，这时才会执行 setImmediate 。 12setTimeout(_ =&gt; console.log('setTimeout'))setImmediate(_ =&gt; console.log('setImmediate')) 有兴趣的可以自己试验一下，执行多次真的会得到不同的结果。 但是如果后续添加一些代码以后，就可以保证setTimeout一定会在setImmediate之前触发了： 12345678setTimeout(_ =&gt; console.log("setTimeout"));setImmediate(_ =&gt; console.log("setImmediate"));let countdown = 1e9;// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了，所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate`while (countdown--) &#123;&#125; 如果在另一个宏任务中，必然是setImmediate先执行：123456require('fs').readFile(__dirname, _ =&gt; &#123; setTimeout(_ =&gt; console.log('timeout')) setImmediate(_ =&gt; console.log('immediate'))&#125;)// 如果使用一个设置了延迟的setTimeout也可以实现相同的效果 process.nextTick这个可以认为是一个类似于 Promise 和 MutationObserver 的微任务实现，在代码执行的过程中可以随时插入 nextTick ，并且会保证在下一个宏任务开始之前所执行。 在使用方面的一个最常见的例子就是一些事件绑定类的操作：1234567891011121314class Lib extends require("events").EventEmitter &#123; constructor() &#123; super(); this.emit("init"); &#125;&#125;const lib = new Lib();lib.on("init", _ =&gt; &#123; // 这里将永远不会执行 console.log("init!");&#125;); 因为上述的代码在实例化Lib对象时是同步执行的，在实例化完成以后就立马发送了init事件。而这时在外层的主程序还没有开始执行到lib.on(‘init’)监听事件的这一步。所以会导致发送事件时没有回调，回调注册后事件不会再次发送。 我们可以很轻松的使用process.nextTick来解决这个问题：12345678910111213class Lib extends require("events").EventEmitter &#123; constructor() &#123; super(); process.nextTick(_ =&gt; &#123; this.emit("init"); &#125;); // 同理使用其他的微任务 // 比如Promise.resolve().then(_ =&gt; this.emit('init')) // 也可以实现相同的效果 &#125;&#125; 这样会在主进程的代码执行完毕后，程序空闲时触发Event Loop流程查找有没有微任务，然后再发送init事件。递归调用process.nextTick会导致报警，后续的代码永远不会被执行，这是对的， 参考https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9060940668586593086%22%7D&amp;n_type=1&amp;p_from=3 https://www.cnblogs.com/jiasm/p/9482443.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux手动实现之五终篇]]></title>
    <url>%2Fpost%2Fd60b308f.html</url>
    <content type="text"><![CDATA[现在已经完成了一个很通用的 createStore ，并且使用起来也很容易，性能也ok。重新审视一下我们代码，发现 stateChanger 第一个参数 state 就是 createStore 第一个参数的 state，两者其实都是全局变量 appState , 那么是否可以将 appState 和 stateChanger 合并到一起？ 这样使用 createStore 的时候就可以不用关注 state , 也避免了无意中的 state.title.text=&quot;xxx&quot; 这样的代码。 1234567891011121314151617181920212223242526function stateChanger(state, action) &#123; if(!state)&#123; state = &#123; title: &#123; text: "redux", color: "red", &#125;, content: &#123; text: "redux文档内容", color: "blue" &#125; &#125;; &#125; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": &#123; state.title.text = action.text; break; &#125; case "UPDATE_TITLE_COLOR": &#123; state.title.color = action.color; break; &#125; default: break; &#125;&#125; 这时 stateChanger 就同时拥有了初始化和修改 state 的能力，如果有传入 state 就生成更新数据，否则就是初始化数据。 现在可以优化 createStore 为一个参数，将原来的参数 state 变为一个局部遍历，在完成 createStore 的操作之前，通过触发一个空操作，完成局部变量 state 的初始化。 123456789101112131415161718function createStore(stateChanger) &#123; let state = null; let events = []; let store = &#123; subscribe: (event) =&gt; &#123; events.push(event); &#125;, dispatch: (action) =&gt; &#123; // 每次修改之后， 获取新的state state = stateChanger(state, action); events.forEach((event) =&gt; event()); &#125;, getState: () =&gt; state &#125;; // 触发一个空操作， 初始化 state store.dispatch(&#123;&#125;); return store;&#125; 现在我们就拥有了一个最终形态的 createStore ， 它接收一个可以根据 action 修改 state 的函数，这个函数是一个不依赖外部数据，并且没有副作用的纯函数（Pure Function），现在我们把 stateChanger 改为 reducer 就完全符合 redux 的 api 了。 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='title'&gt;&lt;/div&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script&gt; // const appState = &#123; // title: &#123; // text: "redux", // color: "red", // &#125;, // content: &#123; // text: "redux文档内容", // color: "blue" // &#125; // &#125;; function reducer(state, action) &#123; if (!state) &#123; state = &#123; title: &#123; text: "redux", color: "red", &#125;, content: &#123; text: "redux文档内容", color: "blue" &#125; &#125;; &#125; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, text: action.text &#125; &#125;; case "UPDATE_TITLE_COLOR": return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, color: action.color &#125; &#125;; default: return state; // 没有修改，返回原来的对象 &#125; &#125; // 添加 createStore function createStore(stateChanger) &#123; let state = null; let events = []; let store = &#123; subscribe: (event) =&gt; &#123; events.push(event); &#125;, dispatch: (action) =&gt; &#123; // 每次修改之后， 获取新的state state = stateChanger(state, action); events.forEach((event) =&gt; event()); &#125;, getState: () =&gt; state &#125;; // 触发一个空操作， 初始化 state store.dispatch(&#123;&#125;); return store; &#125; function renderTitle(newTitle, oldTile = &#123;&#125;) &#123; if (newTitle === oldTile) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render title..."); const titleDom = document.querySelector("#title"); titleDom.innerHTML = newTitle.text; titleDom.style.color = newTitle.color; &#125; function renderContent(newContent, oldContent = &#123;&#125;) &#123; if (newContent === oldContent) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render content..."); const contentDom = document.querySelector("#content"); contentDom.innerHTML = newContent.text; contentDom.style.color = newContent.color; &#125; function renderApp(newAppState, oldAppState = &#123;&#125;) &#123; if (newAppState === oldAppState) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render app..."); renderTitle(newAppState.title, oldAppState.title); renderContent(newAppState.content, oldAppState.content); &#125; // 生成 store let store = createStore(reducer); // 缓存旧的state let oldState = store.getState(); // 监听数据变化 store.subscribe(() =&gt; &#123; // 获取新的 state let newState = store.getState(); // 把新旧的 state 传进去渲染 renderApp(newState, oldState); // 新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染 oldState = newState; &#125;); renderApp(store.getState()); // 三秒钟之后，修改标题和标题颜色，并重新渲染 setTimeout(function () &#123; store.dispatch(&#123; type: "UPDATE_TITLE_TEXT", text: "Redux是React是好基友" &#125;); store.dispatch(&#123; type: "UPDATE_TITLE_COLOR", color: "green" &#125;); // renderApp(store.getState()); &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux手动实现之四性能优化]]></title>
    <url>%2Fpost%2F3d4efad1.html</url>
    <content type="text"><![CDATA[在上一节的代码中，其实存在一个很严重的性能问题。12345678910111213141516171819function renderTitle(title) &#123; console.log("render title..."); const titleDom = document.querySelector("#title"); titleDom.innerHTML = title.text; titleDom.style.color = title.color;&#125;function renderContent(content) &#123; console.log("render content..."); const contentDom = document.querySelector("#content"); contentDom.innerHTML = content.text; contentDom.style.color = content.color;&#125;function renderApp(appState) &#123; console.log("render app..."); renderTitle(appState.title); renderContent(appState.content);&#125; 其他代码保持不变，依旧执行一次初始化渲染，和两次更新，然后打开控制台看下log 前三个是第一次渲染打印出来的。中间三个是第一次 store.dispatch 的结果，最后三个是第二次 store.dispatch 的结果。问题就是后两次的更新都没有改动 content 对象，只是修改了 title 对象。 renderContent 是不需要执行的，这里的操作需要优化。 可以通过在每个渲染函数执行渲染操作之前先做个判断，判断传入的新数据和旧的数据是不是相同，相同的话就不渲染了。 12345678910111213141516171819202122232425262728function renderTitle(newTitle, oldTile = &#123;&#125;) &#123; if (newTitle === oldTile) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render title..."); const titleDom = document.querySelector("#title"); titleDom.innerHTML = newTitle.text; titleDom.style.color = newTitle.color;&#125;function renderContent(newContent, oldContent = &#123;&#125;) &#123; if (newContent === oldContent) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render content..."); const contentDom = document.querySelector("#content"); contentDom.innerHTML = newContent.text; contentDom.style.color = newContent.color;&#125;function renderApp(newAppState, oldAppState = &#123;&#125;) &#123; if (newAppState === oldAppState) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render app..."); renderTitle(newAppState.title, oldAppState.title); renderContent(newAppState.content, oldAppState.content);&#125; 然后我们用一个 oldState 变量保存旧的应用状态，在需要重新渲染的时候把新旧数据传进入去： 1234567891011121314151617181920// 生成 storelet store = createStore(appState, stateChanger);// 缓存旧的statelet oldState = store.getState();// 监听数据变化store.subscribe(() =&gt; &#123; // 获取新的 state let newState = store.getState(); // 把新旧的 state 传进去渲染 renderApp(newState, oldState); // 新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染 oldState = newState;&#125;);renderApp(store.getState());// 三秒钟之后，修改标题和标题颜色，并重新渲染setTimeout(function () &#123; store.dispatch(&#123; type: "UPDATE_TITLE_TEXT", text: "Redux是React是好基友" &#125;); store.dispatch(&#123; type: "UPDATE_TITLE_COLOR", color: "green" &#125;); // renderApp(store.getState());&#125;, 3000); 我们的代码现在变成了这样：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='title'&gt;&lt;/div&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script&gt; const appState = &#123; title: &#123; text: "redux", color: "red", &#125;, content: &#123; text: "redux文档内容", color: "blue" &#125; &#125;; function stateChanger(state, action) &#123; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": &#123; state.title.text = action.text; break; &#125; case "UPDATE_TITLE_COLOR": &#123; state.title.color = action.color; break; &#125; default: break; &#125; &#125; // 添加 createStore function createStore(state, stateChanger) &#123; let events = []; return &#123; subscribe: (event) =&gt; &#123; events.push(event); &#125;, dispatch: (action) =&gt; &#123; stateChanger(state, action); events.forEach((event) =&gt; event()); &#125;, getState: () =&gt; state &#125;; &#125; function renderTitle(newTitle, oldTile = &#123;&#125;) &#123; if (newTitle === oldTile) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render title..."); const titleDom = document.querySelector("#title"); titleDom.innerHTML = newTitle.text; titleDom.style.color = newTitle.color; &#125; function renderContent(newContent, oldContent = &#123;&#125;) &#123; if (newContent === oldContent) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render content..."); const contentDom = document.querySelector("#content"); contentDom.innerHTML = newContent.text; contentDom.style.color = newContent.color; &#125; function renderApp(newAppState, oldAppState = &#123;&#125;) &#123; if (newAppState === oldAppState) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render app..."); renderTitle(newAppState.title, oldAppState.title); renderContent(newAppState.content, oldAppState.content); &#125; // 生成 store let store = createStore(appState, stateChanger); // 缓存旧的state let oldState = store.getState(); // 监听数据变化 store.subscribe(() =&gt; &#123; // 获取新的 state let newState = store.getState(); // 把新旧的 state 传进去渲染 renderApp(newState, oldState); // 新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染 oldState = newState; &#125;); renderApp(store.getState()); // 三秒钟之后，修改标题和标题颜色，并重新渲染 setTimeout(function () &#123; store.dispatch(&#123; type: "UPDATE_TITLE_TEXT", text: "Redux是React是好基友" &#125;); store.dispatch(&#123; type: "UPDATE_TITLE_COLOR", color: "green" &#125;); // renderApp(store.getState()); &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开页面，会发现只执行了第一次渲染，而后面的两次更新根本就不执行了，why??????? 我们知道在 JavaScript 函数中，所有的参数都是值传递，参数为基本类型时传递的直接就是值，参数为对象时，参数的值就是对象所在的内存地址空间，看下我们修改 state 的地方：1234567891011121314function stateChanger(state, action) &#123; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": &#123; state.title.text = action.text; break; &#125; case "UPDATE_TITLE_COLOR": &#123; state.title.color = action.color; break; &#125; default: break; &#125;&#125; 通过上面的代码可以看到，我们只是修改了 state.title 中的 text 和 color 属性，而 title 对象的内存地址依然原来的，state 的内存地址也依然是原来，所以 newState 和 oldState 都是指向同一个内存地址，所以 newAppState === oldAppState 为 true，所以也就不会触发新的渲染。 内存空间详细图解 怎么办？？？？？？ 是不是可以通过浅复制生成一个新的对象，然后将修改的部分覆盖到这个新的对象上，这样既可以保证没有被修改的对象内存地址保持不变，而被修改的对象又可以获得新的地址，继而触发渲染。 每次修改某些数据的时候，不去改变原来的数据，而是把需要修改数据对象都 copy 一个出来，然后再去修改新生成的数据。如上图所示，content 对象就可以在不同的阶段进行共享。 根据这个思路，来修改 stateChanger: 12345678910111213141516171819202122function stateChanger(state, action) &#123; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, text: action.text &#125; &#125;; case "UPDATE_TITLE_COLOR": return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, color: action.color &#125; &#125;; default: return state; // 没有修改，返回原来的对象 &#125;&#125; 每次需要修改的时候都会产生新的对象，并且返回。而如果没有修改（在 default 语句中）则返回原来的 state 对象。 因为 stateChanger 不会修改原来对象了，而是返回对象，所以我们需要修改一下 createStore。让它用每次 stateChanger(state, action) 的调用结果覆盖原来的 state： 1234567891011121314function createStore(state, stateChanger) &#123; let events = []; return &#123; subscribe: (event) =&gt; &#123; events.push(event); &#125;, dispatch: (action) =&gt; &#123; // 每次修改之后， 获取新的state state = stateChanger(state, action); events.forEach((event) =&gt; event()); &#125;, getState: () =&gt; state &#125;;&#125; 现在的完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='title'&gt;&lt;/div&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script&gt; const appState = &#123; title: &#123; text: "redux", color: "red", &#125;, content: &#123; text: "redux文档内容", color: "blue" &#125; &#125;; function stateChanger(state, action) &#123; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, text: action.text &#125; &#125;; case "UPDATE_TITLE_COLOR": return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, color: action.color &#125; &#125;; default: return state; // 没有修改，返回原来的对象 &#125; &#125; // 添加 createStore function createStore(state, stateChanger) &#123; let events = []; return &#123; subscribe: (event) =&gt; &#123; events.push(event); &#125;, dispatch: (action) =&gt; &#123; // 每次修改之后， 获取新的state state = stateChanger(state, action); events.forEach((event) =&gt; event()); &#125;, getState: () =&gt; state &#125;; &#125; function renderTitle(newTitle, oldTile = &#123;&#125;) &#123; if (newTitle === oldTile) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render title..."); const titleDom = document.querySelector("#title"); titleDom.innerHTML = newTitle.text; titleDom.style.color = newTitle.color; &#125; function renderContent(newContent, oldContent = &#123;&#125;) &#123; if (newContent === oldContent) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render content..."); const contentDom = document.querySelector("#content"); contentDom.innerHTML = newContent.text; contentDom.style.color = newContent.color; &#125; function renderApp(newAppState, oldAppState = &#123;&#125;) &#123; if (newAppState === oldAppState) &#123; return false;// 数据没有变化就不渲染了 &#125; console.log("render app..."); renderTitle(newAppState.title, oldAppState.title); renderContent(newAppState.content, oldAppState.content); &#125; // 生成 store let store = createStore(appState, stateChanger); // 缓存旧的state let oldState = store.getState(); // 监听数据变化 store.subscribe(() =&gt; &#123; // 获取新的 state let newState = store.getState(); // 把新旧的 state 传进去渲染 renderApp(newState, oldState); // 新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染 oldState = newState; &#125;); renderApp(store.getState()); // 三秒钟之后，修改标题和标题颜色，并重新渲染 setTimeout(function () &#123; store.dispatch(&#123; type: "UPDATE_TITLE_TEXT", text: "Redux是React是好基友" &#125;); store.dispatch(&#123; type: "UPDATE_TITLE_COLOR", color: "green" &#125;); // renderApp(store.getState()); &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 刷新页面，然后打开控制台看下log 另外，并不需要担心每次修改都新建共享结构对象会有性能、内存问题，因为构建对象的成本非常低，而且我们最多保存两个对象引用（oldState 和 newState），其余旧的对象都会被垃圾回收掉。 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux手动实现之三数据监控]]></title>
    <url>%2Fpost%2F9995c091.html</url>
    <content type="text"><![CDATA[接着上一节继续来看代码，每次通过 dispatch 修改状态之后都要重新调用 renderApp 去渲染，不然的话页面不会改变的，那么能不能智能一点，在每次调用 dispatch 的时候自动调用 renderApp 呢？ 好像是可以的，将 renderApp 传入 dispatch ，在数据更新后，重新调用下就可以了。 但是，新的问题又来了，既然 state 是共享数据，那么使用的地方必然不止一处，如果数据更新了，需要调用的渲染函数也不止一个，dispatch 就会变得特别臃肿。 这里就要用到观察者模式了，修改 createStore 为如下代码 12345678910111213function createStore(state,stateChanger)&#123; let events = []; return &#123; subscribe:(event)=&gt;&#123; events.push(event); &#125;, dispatch: (action) =&gt; &#123; stateChanger(state, action); events.forEach((event)=&gt;event()); &#125;, getState: () =&gt; state &#125;&#125; 我们在 createStore 里面定义了一个数组 events和一个新的方法 subscribe，可以通过 store.subscribe(event) 的方式给 subscribe 传入一个监听函数，这个函数会被 push 到 events 中。 每次修改数据时都会调用 dispatch ，而 dispatch 除了修改数据，还会遍历调用 events 数组里面的函数，这样就可以通过 subscribe 在 events 中注册事件，来进行数据改变之后的操作。 现在只要在使用到数据的地方，通过 subscribe 注册一个事件就可以在 dispatch 触发数据改变的时候，重新渲染使用到数据的地方。 全部代码修改如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='title'&gt;&lt;/div&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script&gt; const appState = &#123; title: &#123; text: "redux", color: "red", &#125;, content: &#123; text: "redux文档内容", color: "blue" &#125; &#125;; function stateChanger(state, action) &#123; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": &#123; state.title.text = action.text; break; &#125; case "UPDATE_TITLE_COLOR": &#123; state.title.color = action.color; break; &#125; default: break; &#125; &#125; // 添加 createStore function createStore(state, stateChanger) &#123; let events = []; return &#123; subscribe: (event) =&gt; &#123; events.push(event); &#125;, dispatch: (action) =&gt; &#123; stateChanger(state, action); events.forEach((event) =&gt; event()); &#125;, getState: () =&gt; state &#125;; &#125; function renderTitle(title) &#123; const titleDom = document.querySelector("#title"); titleDom.innerHTML = title.text; titleDom.style.color = title.color; &#125; function renderContent(content) &#123; const contentDom = document.querySelector("#content"); contentDom.innerHTML = content.text; contentDom.style.color = content.color; &#125; function renderApp(appState) &#123; renderTitle(appState.title); renderContent(appState.content); &#125; // 生成 store let store = createStore(appState, stateChanger); // 监听数据变化 store.subscribe(() =&gt; &#123; renderApp(store.getState()); &#125;); renderApp(store.getState()); // 三秒钟之后，修改标题和标题颜色，并重新渲染 setTimeout(function () &#123; store.dispatch(&#123; type: "UPDATE_TITLE_TEXT", text: "Redux是React是好基友" &#125;); store.dispatch(&#123; type: "UPDATE_TITLE_COLOR", color: "green" &#125;); // renderApp(store.getState()); &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现在我们有了一个比较通用的 createStore，它可以产生一种我们新定义的数据类型 store，通过 store.getState 我们获取共享状态，而且我们约定只能通过 store.dispatch 修改共享状态。store 也允许我们通过 store.subscribe 监听数据数据状态被修改了，并且进行后续的例如重新渲染页面的操作。 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux手动实现之二store]]></title>
    <url>%2Fpost%2Fecfe7ba3.html</url>
    <content type="text"><![CDATA[上一节通过 dispatch 控制了对共享数据 appState 操作的渠道，这种模式可以很好的解决共享数据修改难以排查的问题，现在我们再做一次抽离，使这种模式可以很好的复用到其他应用上。 构建一个函数叫createStore用来生成一个维护共享数据的中心store。123456function createStore(state, stateChanger) &#123; return &#123; dispatch: (action) =&gt; stateChanger(state, action), getState: () =&gt; state &#125;;&#125; createStore 接收两个参数 state 和 stateChanger， state 用于表示应用程序的状态，stateChanger 就是上一节的 dispatch 用于根据 action 的变化去操作 state。 createStore 会返回包含两个方法 getState 和 dispatch 的对象。getState 用于返回 state 参数，dispatch 用于修改数据，和之前不同的是它只接受一个参数 action，然后它会把 state 和 action 一并传给 stateChanger，那么 stateChanger 就可以根据 action 来修改 state 了。 现在使用 createStore 来修改上一节的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='title'&gt;&lt;/div&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script&gt; const appState = &#123; title: &#123; text: "redux", color: "red", &#125;, content: &#123; text: "redux文档内容", color: "blue" &#125; &#125;; function stateChanger(state, action) &#123; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": &#123; state.title.text = action.text; break; &#125; case "UPDATE_TITLE_COLOR": &#123; state.title.color = action.color; break; &#125; default: break; &#125; &#125; // 添加 createStore function createStore(state, stateChanger) &#123; return &#123; dispatch: (action) =&gt; stateChanger(state, action), getState: () =&gt; state &#125;; &#125; function renderTitle(title) &#123; const titleDom = document.querySelector("#title"); titleDom.innerHTML = title.text; titleDom.style.color = title.color; &#125; function renderContent(content) &#123; const contentDom = document.querySelector("#content"); contentDom.innerHTML = content.text; contentDom.style.color = content.color; &#125; function renderApp(appState) &#123; renderTitle(appState.title); renderContent(appState.content); &#125; // 生成 store let store = createStore(appState, stateChanger); renderApp(store.getState()); // 三秒钟之后，修改标题和标题颜色，并重新渲染 setTimeout(function () &#123; store.dispatch(&#123; type: "UPDATE_TITLE_TEXT", text: "Redux是React是好基友" &#125;); store.dispatch(&#123; type: "UPDATE_TITLE_COLOR", color: "green" &#125;); renderApp(store.getState()); &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux手动实现之一初步]]></title>
    <url>%2Fpost%2F2da5028e.html</url>
    <content type="text"><![CDATA[Redux 是一种前端新型的架构模式，经常和 React 一起使用，在我们使用 React 的时候基本都要伴随着 Redux , 并使用 react-redux 这个库把这两粘和起来。 需要注意的是，Redux 是一种从 Flux 演变而来的架构模式，它不关注跟哪个库一起用，你可以把它应用到 React 和 Vue，跟 jquery 结合也没有问题。react-redux 就是一种将 Redux 和 React 结合起来的一个库。 关于 Redux 的用法可以去官网上查看，今天主要是来看下 redux 主要解决了什么问题以及怎么解决的。 通过 webstorm 新建一个项目 redux-achieve , 新建 index.html 里面的 body 结构为: 1234&lt;body&gt; &lt;div id='title'&gt;&lt;/div&gt; &lt;div id='content'&gt;&lt;/div&gt;&lt;/body&gt; 新建 index.js，添加代码，表示应用的状态： 12345678910const appState = &#123; title: &#123; text: "redux", color: "red", &#125;, content: &#123; text: "redux文档内容", color: "blue" &#125;&#125; 然后添加以下函数，将状态渲染到页面上。123456789101112131415161718function renderTitle(title) &#123; const titleDom = document.querySelector("#title"); titleDom.innerHTML = title.text; titleDom.style.color = title.color;&#125;function renderContent(content) &#123; const contentDom = document.querySelector("#content"); contentDom.innerHTML = content.text; contentDom.style.color = content.color;&#125;function renderApp(appState) &#123; renderTitle(appState.title); renderContent(appState.content);&#125;renderApp(appState); 然后打开页面，就会看到 这是一个很简单的页面，一看就明白，但是这个页面有个很大的问题，就是状态数据 appState 是一个全局变量，每个人都可以修改它，如果页面上有很多操作的话，出现问题的时候，很难排查哪一个操作改变了 appState 的值，这也就是常说的尽量避免使用全局变量。但是，很多时候确实需要全局变量来做到不同功能模块之间的数据共享，这是一个需要解决矛盾点。 为了解决这个问题，我们做一些约定，当我们需要修改共享数据的时候，只能通过制定的方法修改，而不能直接去改，以保证出现问题的时候，方便查找问题的根源。所以新建一个 dispatch 函数，专门用来修改数据。 1234567891011121314function dispatch(state, action) &#123; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": &#123; state.title.text = action.text; break; &#125; case "UPDATE_TITLE_COLOR": &#123; state.title.color = action.color; break; &#125; default: break; &#125;&#125; dispatch 接收两个参数，一个是要修改的共享数据对象 state ，一个是action,action是一个普通的js对象，action里面必须包含一个 type 以表示想做什么事情，dispatch 通过这个值去执行对应的操作，action其他的属性是可以自定义传入的。 现在所有对于数据的操作都必须通过调用 dispatch 函数来进行，这时排查 bug 就只需要在 dispatch 的 case 里面打上断点就可以调试出来了。dispatch 就像一个单一功能的数据接口，只需要关注 dispatch 所有对 state 数据的操作就都被监控了。 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='title'&gt;&lt;/div&gt; &lt;div id='content'&gt;&lt;/div&gt; &lt;script&gt; const appState = &#123; title: &#123; text: "redux", color: "red", &#125;, content: &#123; text: "redux文档内容", color: "blue" &#125; &#125;; function dispatch(state, action) &#123; switch (action.type) &#123; case "UPDATE_TITLE_TEXT": &#123; state.title.text = action.text; break; &#125; case "UPDATE_TITLE_COLOR": &#123; state.title.color = action.color; break; &#125; default: break; &#125; &#125; function renderTitle(title) &#123; const titleDom = document.querySelector("#title"); titleDom.innerHTML = title.text; titleDom.style.color = title.color; &#125; function renderContent(content) &#123; const contentDom = document.querySelector("#content"); contentDom.innerHTML = content.text; contentDom.style.color = content.color; &#125; function renderApp(appState) &#123; renderTitle(appState.title); renderContent(appState.content); &#125; renderApp(appState); // 三秒钟之后，修改标题和标题颜色，并重新渲染 setTimeout(function () &#123; dispatch(appState, &#123; type: "UPDATE_TITLE_TEXT", text: "Redux是React是好基友" &#125;); dispatch(appState, &#123; type: "UPDATE_TITLE_COLOR", color: "green" &#125;); renderApp(appState); &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考http://huziketang.mangojuice.top/books/react/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node爬虫之gbk网页中文乱码解决方案]]></title>
    <url>%2Fpost%2F94238009.html</url>
    <content type="text"><![CDATA[中文乱码具体是指用 node 请求 gb2312 编码的网页，无法正确获取网页中的中文（需要转码）。 解决办法直接用 iconv-lite 模块进行转码。 iconv-lite 是一个进行编码转换的模块（node 默认编码 utf-8）。需要 decode 的编码必须是 Buffer 类型。 使用http模块123456789101112131415161718192021222324252627282930const http = require("http");const querystring = require("querystring");const iconv = require("iconv-lite");let postData = &#123; username:"username"&#125;;let req = http.request(&#123; hostname: "xxxx.com", port: 80, path: "/pathname", method: "POST", headers: &#123; "Content-Type": "application/x-www-form-urlencoded" &#125;&#125;, (res) =&gt; &#123; let chunks = []; res.on("data", (chunk) =&gt; &#123; chunks.push(chunk); &#125;); res.on("end", () =&gt; &#123; let html = iconv.decode(Buffer.concat(chunks), "gb2312"); &#125;);&#125;);req.on("error", (e) =&gt; &#123; console.error(`problem with request: $&#123;e.message&#125;`);&#125;);// write data to request bodyreq.write(querystring.stringify(postData));req.end(); 使用axios123456const iconv = require("iconv-lite");const axios = require("axios");axios.get(`url`, &#123; responseType: "arraybuffer" &#125;).then(function(response)&#123; let html = iconv.decode(response.data, "gb2312"); console.log(html);&#125;)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npx的使用]]></title>
    <url>%2Fpost%2F7c5a0d00.html</url>
    <content type="text"><![CDATA[Node 自带 npm 模块，所以可以直接使用 npx 命令。万一不能用，就要手动安装一下。1$ npm install -g npx 调用项目安装的模块npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具 Mocha。1$ npm install -D mocha 一般来说，调用 Mocha ，只能在项目脚本和 package.json 的scripts字段里面， 如果想在命令行下调用，必须像下面这样。12# 项目的根目录下执行$ node-modules/.bin/mocha --version npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。1$ npx mocha --version npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。12# 等同于 ls$ npx ls 注意，Bash 内置的命令不在$PATH里面，所以不能用。比如，cd是 Bash 命令，因此就不能用npx cd。 避免全局安装模块除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx 可以运行它，而且不进行全局安装。1$ npx create-react-app my-react-app 上面代码运行时，npx 将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。 下载全局模块时，npx 允许指定版本。1$ npx uglify-js@3.1.0 main.js -o ./dist/main.js 上面代码指定使用 3.1.0版本的uglify-js压缩脚本。 注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。1$ npx http-server –no-install 参数和–ignore-existing 参数如果想让 npx 强制使用本地模块，不下载远程模块，可以使用--no-install参数。如果本地不存在该模块，就会报错。1$ npx --no-install http-server 反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用--ignore-existing参数。比如，本地已经全局安装了create-react-app，但还是想使用远程模块，就用这个参数。1$ npx --ignore-existing create-react-app my-react-app 使用不同版本的 node利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 node 模块。12$ npx node@0.12.8 -vv0.12.8 上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。 某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。 -p 参数-p参数用于指定 npx 所要安装的模块，所以上一节的命令可以写成下面这样。12$ npx -p node@0.12.8 node -v v0.12.8 上面命令先指定安装`node@0.12.8，然后再执行node -v`命令。 -p参数对于需要安装多个模块的场景很有用。1$ npx -p lolcatjs -p cowsay [command] -c 参数如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。12$ npx -p lolcatjs -p cowsay 'cowsay hello | lolcatjs'# 报错 上面代码中，cowsay hello | lolcatjs执行时会报错，原因是第一项cowsay由 npx 解释，而第二项命令localcatjs由 Shell 解释，但是lolcatjs并没有全局安装，所以报错。 -c参数可以将所有命令都用 npx 解释。有了它，下面代码就可以正常执行了。1$ npx -p lolcatjs -p cowsay -c 'cowsay hello | lolcatjs' -c参数的另一个作用，是将环境变量带入所要执行的命令。举例来说，npm 提供当前项目的一些环境变量，可以用下面的命令查看。1$ npm run env | grep npm_ -c参数可以把这些 npm 的环境变量带入 npx 命令。1$ npx -c 'echo "$npm_package_name"' 上面代码会输出当前项目的项目名。 执行 GitHub 源码npx 还可以执行 GitHub 上面的模块源码。12345# 执行 Gist 代码$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32# 执行仓库代码$ npx github:piuccio/cowsay hello 注意，远程代码必须是一个模块，即必须包含package.json和入口脚本。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]重绘与重排(回流)]]></title>
    <url>%2Fpost%2F49cb51ee.html</url>
    <content type="text"><![CDATA[前言早在五年前，Google 就提出了 1s 完成终端页面的首屏渲染的标准。 常见的优化网络请求的方法有：DNS Lookup，减少重定向，避免 JS、CSS 阻塞，并行请求，代码压缩，缓存，按需加载，前端模块化… 虽然相较于网络方面的优化，前端渲染的优化显得杯水车薪，而且随着浏览器和硬件性能的增长，再加上主流前端框架（react、vue、angular）的已经帮我们解决了大多数的性能问题，但是前端渲染性能优化依然值得学习，除去网络方面的消耗，留给前端渲染的时间已经不多了。本文主要学习前端渲染相关的问题。 浏览器是如何渲染一个页面的 浏览器把获取到的 HTML 代码解析成1个 DOM 树，HTML 中的每个 tag 都是 DOM 树中的1个节点，根节点是 document 对象。DOM 树里包含了所有 HTML 标签，包括 display:none 隐藏的标签，还有用 JS 动态添加的元素等。 浏览器把所有样式解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如 IE 会去掉 -moz 开头的样式。 DOM Tree 和样式结构体组合后构建 render tree, render tree 类似于 DOM tree，但区别很大，render tree 能识别样式，render tree 中每个 NODE 都有自己的 style，而且 render tree 不包含隐藏的节点 (比如 display:none 的节点，还有 head 节点)，因为这些节点不会用于呈现，而且不会影响呈现的节点，所以就不会包含到 render tree 中。注意 visibility:hidden 隐藏的元素还是会包含到 render tree 中的，因为 visibility:hidden 会影响布局(layout)，会占有空间。根据css2的标准，render tree 中的每个节点都称为 box(Box dimensions)，box所有属性：width, height, margin, padding, left, top, border等。 注意结果就是渲染树是和DOM树是相对应的，但是不是一一对应的，因为非可视化的DOM元素不会插入到渲染树中，例如head元素；而如果元素的display属性的值是none的话，也不会出现在渲染树中。 一旦 render tree 构建完毕后，浏览器就可以根据 render tree 来绘制页面了。 在此过程中，前端工程师主要的敌人为： 重新计算样式（Recalculate Style）、计算布局（Layout）=&gt; Rendering/Reflow。 绘制 =&gt; Painting/Repaint。 重绘与回流在讨论回流与重绘之前，我们要知道： 浏览器使用流式布局模型 (Flow Based Layout)。 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。 回流（Reflow）是指布局引擎为frame计算图形的过程, frame是一个矩形，拥有宽高和相对父容器的偏移。frame用来显示盒模型（content model）， 但一个content model可能会显示为多个frame，比如换行的文本每行都会显示为一个frame。 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程就是回流。页面第一次加载的时候，至少发生一次回流。 当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如背景色、前景色等，这个过程叫做重绘（repaint） 在回流的时候，浏览器会使 render tree 中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。因此回流必将引起重绘，而重绘不一定会引起回流。 Reflow 的成本比 Repaint 高得多的多。回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。 一句话：回流必将引起重绘，重绘不一定会引起回流。 重绘何时发生当一个元素的外观的可见性 visibility 发生改变的时候，但是不影响布局。类似的例子包括：outline, visibility, background color。 回流何时发生 页面渲染初始化。 调整窗口大小。 改变字体，比如修改网页默认字体。 增加或者移除样式表。 内容变化，比如文本改变或者图片大小改变而引起的计算值宽度和高度改变。 激活 CSS 伪类，比如 :hover 操作 class 属性。 脚本操作 DOM，增加删除或者修改 DOM 节点，元素尺寸改变——边距、填充、边框、宽度和高度。 计算 offsetWidth 和 offsetHeight 属性。 设置 style 属性的值。 1234567var s = document.body.styles.padding = "2px"; // 回流+重绘s.border = "1px solid red"; // 回流+重绘s.color = "blue"; // 重绘s.backgroundColor = "#ccc"; // 重绘s.fontSize = "14px"; // 再一次 回流+重绘document.body.appendChild(document.createTextNode('abc!')); // 回流+重绘 聪明的浏览器如果向上述代码中那样，浏览器不停地回流+重绘，很可能性能开销非常大，实际上浏览器会优化这些操作，将所有引起回流和重绘的操作放入一个队列中，等待队列达到一定的数量或者时间间隔，就 flush 这个队列，一次性处理所有的回流和重绘。 虽然有浏览器优化，但是当我们向浏览器请求一些 style 信息的时候，浏览器为了确保我们能拿到精确的值，就会提前 flush 队列，有可能会引发回流。 offsetTop/Left/Width/Height scrollTop/Left/Width/Height clientTop/Left/Width/Height width,height getComputedStyle(), 或者 IE的 currentStyle 如何减少回流、重绘 JavaScript 修改 class 的时候，就尽可能使用使用 classList 代替 className ，因为 className 只要赋值，就一定出现一次 rendering 计算；classList 的 add 和 remove，浏览器会进行样式名是否存在的判断，以减少重复的 rendering。尽可能在DOM树的里面改变class，可以限制了回流的范围，使其影响尽可能少的节点。例如，你应该避免通过改变对包装元素类去影响子节点的显示。 123ele.className += 'something'ele.classList.add('something')ele.classList.remove('something') 避免使用table布局。 保持 DOM 操作“原子性” 12345678910111213// bad// 下面这个读取操作会导致连续的清空和放入操作到 重绘+回流队列var newWidth = ele.offsetWidth + 10;ele.style.width = newWidth + 'px';var newHeight = ele.offsetHeight + 10;ele.style.height = newHeight + 'px';// good 读写分离，批量操作var newWidth = ele.offsetWidth + 10; // readvar newHeight = ele.offsetHeight + 10; // readele.style.width = newWidth + 'px'; // writeele.style.height = newHeight + 'px'; // write 如果动态改变style，则使用cssText。 1234567//不好的写法var left = 1;var top = 1;el.style.left = left + "px";el.style.right = right + "px";//动态改变样式，比较好的写法el.style.cssText += ";left:" + left + "px; top:" + top + "px;"; 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存 123456789101112131415//不好的写法for(循环) &#123; el.style.left = el.offsetLeft + 5 + "px"; el.style.top = el.offsetTop + 5 + "px"; &#125;// 比较好的写法var left = el.offsetLeft, top = el.offsetTop, s = el.style;for(循环) &#123; left += 10; top += 10; s.left = left + "px"; s.top = top + "px"; &#125; 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流动画效果应用到 position 属性为 absolute 或 fixed 的元素上，它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。 使用CSS3的transition也可以获得不错的性能。 假设block1是position: absolute的元素，block2是position: relative的元素。当使用jquery的animate()方法移动元素来展示一些动画效果时$(&quot;#block1&quot;).animate({left:50});block1 移动，会影响到它父元素下的所有子元素。因为在移动过程中，所有子元素需要判断 block1 的z-index是否在自己的上面，如果是在自己的上面，则需要重绘，这里不会引起回流。 $(&quot;#block2&quot;).animate({marginLeft:50}); , block2 是相对定位的元素，影响的元素与 block1 一样，但是因为 block2 非绝对定位，而且改变的是 marginLeft 属性，所以这里每次改变不但会重绘，还会引起父元素及其下元素的回流。 ​ 所以，动画效果应用到position属性为absolute或fixed的元素上，它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。 让要操作的元素进行“离线处理”，处理完后一起更新。这里所谓的”离线处理”即让元素不存在于render tree中 使用DocumentFragment进行缓存操作,引发一次回流和重绘； 这个主要用于添加元素的时候，就是先把所有要添加到元素添加到1个div中(这个div也是新加的)，最后才把这个div append到body中。 使用display:none技术，只引发两次回流和重绘； 先display:none 隐藏元素，然后对该元素进行所有的操作，最后再显示该元素。因对display:none的元素进行操作不会引起回流、重绘。所以只要操作只会有2次回流。 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘。 假如需要在下面的 html 中添加两个 li 节点： 1234567891011121314&lt;ul id=""&gt;&lt;/ul&gt; &lt;script&gt;let ul = document.getElementByTagName('ul')let man = document.createElement('li')man.innerHTML = 'man'ul.appendChild(li) let woman = document.createElement('li')woman.innerHTML = 'woman'ul.appendChild(woman)&lt;/script&gt; 上述代码会发生两次回流，假如使用 display: none 的方案，虽然能够减少回流次数，但是会发生一次闪烁，这时候使用 DocumentFragment 的优势就体现出来了。 DocumentFragment 有两大特点： DocumentFragment 节点不属于文档树，继承的 parentNode 属性总是 null。 当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。这使得 DocumentFragment 成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。、12345678910let fragment = document.createDocumentFragment()let man = document.createElement('li')let woman = document.createElement('li')man.innerHTML = 'man'woman.innerHTML = 'woman'fragment.appendChild(man)fragment.appendChild(woman)document.body.appendChild(spanNode) 避免使用CSS表达式（例如：calc()） 这项规则较过时，但确实是个好的主意。主要的原因，这些表现是如此昂贵，是因为他们每次重新计算文档，或部分文档、回流。正如我们从所有的很多事情看到的：引发回流，它可以每秒产生成千上万次。当心！ 参考Web性能优化-页面重绘和回流网页性能管理详解了解DocumentFragment 给我们带来的性能优化高性能WEB开发(8) - 页面呈现、重绘、回流]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>html/css</tag>
        <tag>转载</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]事件循环是如何影响页面渲染的？]]></title>
    <url>%2Fpost%2F6b1caa88.html</url>
    <content type="text"><![CDATA[原文地址 页面渲染/交互任务也会插入在 Task Queue 中，会与各种异步机制插入的任务交错执行。 Microtask Queue 会在下一个任务开始之前清空。 单个耗时任务和 Microtask Queue 都会阻塞页面交互，Task Queue 则不影响。 渲染时机可以通过 requestAnimationFrame 精确控制。 setImmediate 与 setTimeout 一样使用 Task Queue，但克服了 4ms 限制。 任务与队列的概念JavaScript 的异步机制由 事件循环 实现，这些 API 的不同表现在进入和离开任务队列的时机。 为了讨论方便，先解释几个概念。 任务与调用栈。由于单线程的特性，每个 JavaScript 执行上下文只有一个调用栈，其中保存着当前任务中所有未执行完的函数。只要调用栈非空，JavaScript 引擎就会持续地、不被打断地（从进程内的角度来看）执行完当前栈中的所有函数，因此 JavaScript 有 “run-to-completion” 的特性。调用栈被清空时意味着当前任务执行结束。 Task Queue 是事件循环的主要数据结构。当前调用栈为空时（上一个任务已经完成），事件循环机制会持续地轮询 Task Queue，只要队列中有任务就拿出来执行。在任务执行期间插入的任务会进入 Task Queue 尾部。会加入 Task 队列的包括：setTimeout, setInterval, setImmediate，postMessage，MessageChannel，UI 事件，I/O，页面渲染。 Microtask Queue 在 Task Queue 的每个任务执行结束后，下一个任务执行开始前，会执行并清空 Microtask Queue 中的所有任务。在 Microtask 执行期间插入的任务也会进入当前 Microtask Queue。会加入 MicroTask 队列的包括：Promise, MutationObserver，process.nextTick。 上述异步 API 的分类依据的是最新标准或最新实现。存在一些例外，比如：Node &lt; 9 的 process.nextTick 实现的是 Task 语义（而非 Microtask）；IE8 中的 postMessage 是同步的；Edge 浏览器在点击事件处理函数之间不会清空 Microtask Queue。 无论是 Task Queue 还是 Microtask Queue，其中的 task 和 microtask 的执行都是异步的。 为了对上述两个队列有更直观的认识，这里举个例子：123456setTimeout(() =&gt; console.log('setTimeout'));Promise.resolve().then(() =&gt; &#123; console.log('Promise'); Promise.resolve().then(() =&gt; console.log('Promise queued by Promise'));&#125;);console.log('stack'); 上述代码片段中有两个Task（stack, setTimeout），两个 Microtask（Promise、Promise queued by Promise）。 stack 是当前任务会先执行；setTimeout 是第二个任务，在它执行前会清空 Microtask Queue。 这时 Microtask Queue 只有一个 Microtask（Promise）， 在它执行的过程中会插入第二个 Microtask（Promise queued by Promise）。 这些 Microtask 都会在下一个 Task（setTimeout）之前执行。因此输出为：1234stackPromisePromise queued by PromisesetTimeout 注意与 .then 的回调不同，new Promise 的回调是同步执行的。可参考 Promise 回调的执行 一文。 在 Jake 的 Tasks, microtasks, queues and schedules 一文中有更加详细的例子，感兴趣的读者可前往观摩。 何时会阻塞 UIUI 渲染和交互的处理是通过 Task Queue 来调度的，因此耗时任务会导致渲染和交互任务得不到调用，也就是页面“卡死”。 典型的浏览器会在每秒插入 60 个渲染帧，也就是说每 16ms 需要一次渲染。 如果存在一个任务在 16ms 内未能执行结束，页面就会掉帧给人卡顿的感觉。 渲染帧的详细讨论可以参考 浏览器的 16ms 渲染帧 一文， 这里 Harttle 给一个例子。 在 Loop for 10 seconds 部分我们写了 4 种不同的循环，它们的表现如下： 循环 API 队列类型 期间页面能否交互 每秒执行次数 while(true) 当前任务 否 701665.8 | Promise | Microtask Queue | 否 | 609555.4|| setTimeout| Task Queue| 是 | 208.3|| requestAnimationFrame | vTask Queue | 是| 59| 页面不可交互是指：无法点击其他按钮、无法操作输入控件、无法选择/赋值页面文本。 以 PC Chrome 为例，iOS Safari 尤其是 UIWebview 的表现可能会不同。 单个的耗时任务和 Microtask Queue 都会阻塞页面交互，Task 则不影响。 因为 Task 之间浏览器有机会会插入 UI 任务。 这里还可以观察到 setTimeout 虽然设置了 0 延时但调用次数远小于 while，甚至远小于 Microtask。 下文 setImmediate 章节会详细讨论原因。 渲染任务的时机有时我们希望精确地控制浏览器在每一帧的绘制，这时就要了解浏览器绘制的时机。 首先举个例子，我们希望页面背景闪现一下红色： 12document.body.style.background = 'red';document.body.style.background = 'white'; 上述代码一定达不到效果，背景会稳定地呈现白色。 因为 JavaScript “run-to-completion” 的特性，在上述两行代码之间不可能插入渲染任务。 这时可能有人想到 setTimeout： 1234document.body.style.background = 'red';setTimeout(function () &#123; document.body.style.background = 'white';&#125;) 这样两次背景设置会在不同的任务中执行，如果这两个任务之间插入了渲染任务背景就会发生闪动。 但渲染任务是 16ms 一次，你怎么知道浏览器会正好插入在这两个任务之间？ 因此上述代码只会几率性起作用，背景闪动的几率大概 4/16.67 = 25%。 16.67 是渲染帧间隔，那为什么是 4ms 呢？请看下文 setImmediate。 想要增大几率到 100% 怎么办？setTimeout 100ms 呗… 其实 HTML5 中给出了 requestAnimationFrame API，使得脚本有机会精确地控制动画： 123456requestAnimationFrame(function () &#123; document.body.style.background = 'red'; requestAnimationFrame(function () &#123; document.body.style.background = 'white'; &#125;)&#125;) 插入的任务会在每次渲染任务之前执行，因此等待渲染之后需要调用两次来插入到第二次渲染之前。 这样背景一定会闪现红色。同样下面页面的 “Switch background red and white” 部分给了例子 setImmediate 是啥setImmediate 是由 IE 提出的， 目前尚未形成标准。当前状态是 Proposal 且只有 IE 有实现。 setImmediate 是为了让脚本更快地执行，与 setTimeout 一样都使用 Task Queue。 为了解 setImmediate 的用途，我们先看 setTimeout 为什么不够快。 下面的文本来自 HTML5 Living Standard 的 timer initialization steps: If timeout is less than 0, then set timeout to 0. If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4. Increment nesting level by one. 其中 nesting level 是指 timer nesting level， 每一级可能是 setTimeout 也可能是 setInterval。也就是说在嵌套 5 层以上时，会设置最小 4ms 的延迟。 setImmediate 意在让脚本有机会在 UA 事件和渲染发生后立即得到调用，从渲染的角度上类似于渲染之后调用的 requestAnimationFrame。 由于没有广泛实现，使用 setImmediate 需要引入 Polyfill。请参考： https://github.com/YuzuJS/setImmediate/blob/master/README.md]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Router迷之实现]]></title>
    <url>%2Fpost%2F5603cf15.html</url>
    <content type="text"><![CDATA[本文主要是通过创建一个基本版本的React Router v4 来理解背后实现的原理。如果要学习React Router怎么使用，请移步官方文档 RouteRoute是用来渲染 UI的，具体点就是当一个 URL 匹配上了你所指定的路由路径，就进行渲染。 Route 组件常用的属性主要有四个exact、path、component和render，这个四个属性的主要作用为：exact: 只有当所给路径精确匹配上 location.pathname 时才返回 true。path: 非必须属性，如果改属性不存在，那么路由对应的组件将自动渲染component: 如果路径匹配上了，则渲染属性对应的组件render： 允许你创建一个直接返回 UI 的内联函数而不用创建额外的组件 Route的功能是渲染匹配指定路由路径的组件，所以Router需要做到的功能为：判断当前的URL是否和组件的path相匹配，如果匹配则返回渲染的UI；否则返回null。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 判断path是否匹配const matchPatch = (pathname, options) =&gt; &#123; const &#123; exact = false, path &#125; = options if (!path) &#123; return &#123; path: null, url: pathname, isExact: true, &#125; &#125; const match = new RegExp(`^$&#123;path&#125;`).exec(pathname) if(!match)&#123; // 没有匹配上 return null; &#125; const url = match[0]; const isExact = url === patchname; if(exact &amp;&amp; !isExact)&#123; // 匹配上了 ， 但是不精确 return null; &#125; return &#123; path,url,isExact &#125;&#125;class Route extend React.Component&#123; static propTypes = &#123; exact: PropTypes.bool, path: PropTypes.string, component: PropTypes.func, r ender: PropTypes.func, &#125; render()&#123; let &#123;path,render,component,exact&#125; = this.props; let match = matchPath(location.pathname,&#123;path,exact&#125;); if(!match)&#123; // path匹配失败， 返回null return null; &#125; // path 匹配成功 if(component)&#123; // 如果component属性存在 // 以 component 创建新元素并且传递 match return React.createElement(component,&#123;match,loaction&#125;) &#125; if(render)&#123; // 如果render存在 // 则调用 render 并以 match 作为参数 return render(&#123;match,loction&#125;) &#125; return null; &#125;&#125; 上面的代码即实现了：如果匹配上了 path 属性，就返回 UI，否则什么也不做。 这里还有一种情况就是点击浏览器前进/后退按钮改变URL的时候，需要让Route可以做出针对性的处理。当用户点击了后退/前进按钮的时候，popstate事件会被触发，因此只需要监听popstate事件，在URL被改变时，触发popstate去检查是否匹配上了新的 URL，如果是则渲染 UI，如果不是，什么也不做。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 判断path是否匹配const matchPatch = (pathname, options) =&gt; &#123; const &#123; exact = false, path &#125; = options if (!path) &#123; return &#123; path: null, url: pathname, isExact: true, &#125; &#125; const match = new RegExp(`^$&#123;path&#125;`).exec(pathname) if(!match)&#123; // 没有匹配上 return null; &#125; const url = match[0]; const isExact = url === patchname; if(exact &amp;&amp; !isExact)&#123; // 匹配上了 ， 但是不精确 return null; &#125; return &#123; path,url,isExact &#125;&#125;class Route extend React.Component&#123; static propTypes = &#123; exact: PropTypes.bool, path: PropTypes.string, component: PropTypes.func, render: PropTypes.func, &#125; componentDidMount()&#123; // 加了一个 popstate 监听，当 popstate 触发的时候，调用 forceUpdate 来强制做重新渲染的判断。 window.addEventListener("popstate",this.handlePopstate); &#125; componentWillUnMount()&#123; // 组件卸载时，移除监听事件 window.removeEventListener("popstate",this.handlePopstate); &#125; handlePopstate()&#123; this.forceUpdate(); &#125; render()&#123; let &#123;path,render,component,exact&#125; = this.props; let match = matchPath(location.pathname,&#123;path,exact&#125;); if(!match)&#123; // path匹配失败， 返回null return null; &#125; // path 匹配成功 if(component)&#123; // 如果component属性存在 // 以 component 创建新元素并且传递 match return React.createElement(component,&#123;match,loaction&#125;) &#125; if(render)&#123; // 如果render存在 // 则调用 render 并以 match 作为参数 return render(&#123;match,loction&#125;) &#125; return null; &#125;&#125; 这样就实现了根据后退/前进按钮来“重匹配”、“重判断”和“重渲染”。 LinkLink主要是解决通过a标签改变URL的时候，重新匹配Route组件并渲染的问题。Link一般是这样的使用的&lt;Link to=&#39;/some-path&#39; replace={false} /&gt;，to是一个string类型，表示要跳转到的链接。replace是布尔类型，如果为true，则将替换history中的最后一个链接替换为当前的链接，否则就添加当前链接到history中。 首先，Link需要渲染一个a标签，并且需要组织a的默认动作，以免全页面刷新，所以需要一个click事件处理函数来阻止a的默认动作。 123456789101112131415class Link extends React.Component&#123; static propTypes = &#123; to: PropTypes.string.isRequired, replace: PropTypes.bool &#125; onClick(e)&#123; e.preventDefault(); let &#123;to,replace&#125; = this.props; &#125; render()&#123; return ( &lt;a href=&#123;this.props.to&#125; onClick=&#123;this.handleClick&#125;&gt;&#123;this.props.children&#125;&lt;/a&gt; ) &#125;&#125; 然后需要处理更新URL的部分，通过history的api更新路由，我们需要在点击事件中，获取目标URL，然后通知目标URL对应的Route组件渲染。 为了可以准确的渲染路由对应的组件，我们需要将所有的路由收集起来，没当地址发生改变的时候，就遍历数组，并调用forceUpdate函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 这里创建的两个函数，用来收集Route和删除Routelet instances = [];const register = (comp)=&gt;&#123;instances.push(comp);&#125;;const unregister = (comp)=&gt;&#123;instances.splice(instances.indexOf(comp),1);&#125;// 更新 Route 组件// 判断path是否匹配const matchPatch = (pathname, options) =&gt; &#123; ...&#125;class Route extend React.Component&#123; ... componentDidMount()&#123; // 加了一个 popstate 监听，当 popstate 触发的时候，调用 forceUpdate 来强制做重新渲染的判断。 window.addEventListener("popstate",this.handlePopstate); register(this); &#125; componentWillUnMount()&#123; // 组件卸载时，移除监听事件 window.removeEventListener("popstate",this.handlePopstate); unregister(this) &#125; handlePopstate()&#123; this.forceUpdate(); &#125; ...&#125;// 更新 Link 组件class Link extends React.Component&#123; static propTypes = &#123; to: PropTypes.string.isRequired, replace: PropTypes.bool &#125; onClick(e)&#123; e.preventDefault(); let &#123;to,replace&#125; = this.props; if(replace)&#123; history.replaceState(&#123;&#125;,null,to) &#125;else&#123; history.pushState(&#123;&#125;,null,to) &#125; instances.forEach(item=&gt;item.forceUpdate()); &#125; render()&#123; return ( &lt;a href=&#123;this.props.to&#125; onClick=&#123;this.handleClick&#125;&gt;&#123;this.props.children&#125;&lt;/a&gt; ) &#125;&#125; Redirect1234567891011121314151617181920class Redirect extends React.Component&#123; static defaultProps=&#123; push:false &#125; static propTypes = &#123; push: PropTypes.bool.isRequired, to: PropTypes.string.isRequired &#125; componentDidMount()&#123; let &#123;to,push&#125; = this.props; if(push)&#123; history.pushState(&#123;&#125;,null,to); &#125;else&#123; history.replaceState(&#123;&#125;,null,to); &#125; &#125; render()&#123; return null; &#125;&#125; 参考https://www.jianshu.com/p/4e86372cb2fb]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现全排列组合算法]]></title>
    <url>%2Fpost%2F24a5b0c6.html</url>
    <content type="text"><![CDATA[全排列组合算法，例如a,b,c,d进行全排列组合，则组合结果为：a,b,ab,c,ac,bc,abc,d,ad,bd,abd,cd,acd,bcd,abcd。实现思路：从数据源拿出一个元素，依次与已存在的组合数据进行组合，循环上面操作直到数据源没有数据为止。 例子：数据源a,b,c 1.拿出a，组合数据group为空，插入数据源a元素到组合数据group，此时group=[a] 2.拿出b，组合数据group拿出a，a和b组合，得到ab，把数据源b元素、ab插入组合数据group，此时group=[a,b,ab] 3.拿出c，组合数据group拿出a、b、ab，分别与c组合，分别得到ac、bc、abc，把数据源c元素、ac、bc、abc插入组合数据group，此时group=[a,b,ab,c,ac,bc,abc] 1234567891011121314151617var data = ['a','b','c','d'];function getGroup(data, index = 0, group = []) &#123; var need_apply = new Array(); need_apply.push(data[index]); for(var i = 0; i &lt; group.length; i++) &#123; need_apply.push(group[i] + data[index]); &#125; group.push.apply(group, need_apply); if(index + 1 &gt;= data.length) &#123; return group; &#125;else &#123; return getGroup(data, index + 1, group); &#125;&#125; console.log(getGroup(data)); 运行输出结果： 123456789101112131415[ 'a', 'b', 'ab', 'c', 'ac', 'bc', 'abc', 'd', 'ad', 'bd', 'abd', 'cd', 'acd', 'bcd', 'abcd' ]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos编译安装nginx]]></title>
    <url>%2Fpost%2F25974cd9.html</url>
    <content type="text"><![CDATA[下载并解压 12$ curl -o https://nginx.org/download/nginx-1.14.2.tar.gz$ tar zxvf nginx-1.14.2.tar.gz 执行configure命令，生成Makefile文件 1234# 查看编译参数$ ./configure --help# 编译时启用四个模块$ ./configure --with-http_ssl_module --with-http_realip_module --with-http_geoip_module --with-http_stub_status_module 若出现./configure: error: C compiler cc is not found错误，则执行： 1$ yum -y install gcc gcc-c++ autoconf automake make 若出现./configure: error: the HTTP rewrite module requires the PCRE library.错误，则执行： 12345 $ yum install pcre-devel ``` - 若出现`./configure: error: SSL modules require the OpenSSL library.`错误，则执行： ```shell $ yum -y install openssl openssl-devel 若出现./configure: error: the GeoIP module requires the GeoIP library.错误，则执行： 1$ yum -y install GeoIP-devel 看到如下提示表示生成成功：123456789101112131415161718Configuration summary + using system PCRE library + using system OpenSSL library + using system zlib library nginx path prefix: "/usr/local/nginx" nginx binary file: "/usr/local/nginx/sbin/nginx" nginx modules path: "/usr/local/nginx/modules" nginx configuration prefix: "/usr/local/nginx/conf" nginx configuration file: "/usr/local/nginx/conf/nginx.conf" nginx pid file: "/usr/local/nginx/logs/nginx.pid" nginx error log file: "/usr/local/nginx/logs/error.log" nginx http access log file: "/usr/local/nginx/logs/access.log" nginx http client request body temporary files: "client_body_temp" nginx http proxy temporary files: "proxy_temp" nginx http fastcgi temporary files: "fastcgi_temp" nginx http uwsgi temporary files: "uwsgi_temp" nginx http scgi temporary files: "scgi_temp" 编译安装1$ make &amp;&amp; make install PS: 可以通过make clean来清除Makefile。 如果一切正常，则nginx会被安装到/usr/local/nginx目录，该目录主要包含 conf、 html 、logs 、sbin 四个目录。 conf 存放了nginx的所有配置文件。其中，nginx.conf文件是nginx服务器的主配置文件，其他配置文件是用来配置nginx的相关功能，比如，fastcgi.cong和fastcgi_params用来配置fastcgi。 html 该目录存放了nginx服务器在运行过程中调用的一些html文件。index.html文件是在服务器运行成功后默认返回的网页；50x.html是在nginx服务器出现某些问题时将会调用该页面。 logs 顾名思义，用来存放nginx服务器的日志。因为目前服务器还未启动，所以该目录为空。 sbin 只有一个nginx文件，该文件就是nginx服务器的主程序了。 启动nginx 1$ ./usr/local/nginx/sbin/nginx 是否成功 访问ip，出现下图表示成功 ps验证：显示已经启动成功1234$ ps -ef|grep nginx root 8483 1 0 21:21 ? 00:00:00 nginx: master process ./nginx nobody 8484 8483 0 21:21 ? 00:00:00 nginx: worker process root 13186 12897 0 22:17 pts/1 00:00:00 grep --color=auto nginx 目前只能用/usr/local/nginx/sbin/nginx,不能全局使用 nginx. 需要在系统环境变量添加一行代码,首先打开系统环境变量文件:1$ vi /etc/profile 在末尾追加一行PATH=$PATH:/usr/local/webserver/nginx/sbin, :wq 保存后,执行下面命令即可立即生效:source /etc/profile。 常用命令123456nginx #启动nginxnginx -s quit #快速停止nginxnginx -V #查看版本，以及配置文件地址nginx -v #查看版本nginx -s reload|reopen|stop|quit #重新加载配置|重启|快速停止|安全关闭nginxnginx -h #帮助]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]$.ajax vs axios vs fetch]]></title>
    <url>%2Fpost%2F46828a58.html</url>
    <content type="text"><![CDATA[原文地址 Ajax 是什么？答：Ajax是一种可以在浏览器和服务器之间使用异步数据传输（HTTP请求）的技术。使用它可以让页面请求少量的数据，而不用刷新整个页面。而传统的页面（不使用Ajax）要刷新部分内容，必须重载整个网页页面。 Ajax 基于什么？答：它基于的是XMLHttpRequest（XHR）。这是一个比较粗糙的API，不符合关注分离的设计原则（Separation of Concerns），配置和使用都不是那么友好。 $.ajax 的产生背景？答：基于上面的原因，各种ajax库引用而生，然而最有名的就是jQuery的API中的 $.ajax() 。 $.ajax() 它的一个优势异步操作，但jQuery的异步操作是基于事件的异步模型，没有promise那么友好。 fetch 产生的背景？答：综合上面所讲的各种因素，fetch这个api应运而生。但好用归好用，它存在着一些问题（这个问题下面详讲，并讲解相对应的解决方案），再加上兼容性问题（ie压根不支持），所以很多开发者使用了axios这个第三方库。 支持promise的库（axios）？答：axios 这个库现在是一个比较通用的行业解决方案，axios 流行开来的一个原因是promise，另一个原因是基于数据操作的库的流行（vue.js, angular.js, react.js等），而传统的jQuery是基于dom操作的库。但它也存在着缺陷，就是我们使用前，要保证这个库已经被引入。 其实，就我个人而言，我还是比较喜欢使用 fetch 的。在开发中遇到兼容性的问题，只需要同构fetch即可，而不需要额外的引入一个库。下面就重点说一下fetch。 fetch 的使用123fetch(url, options) .then(response =&gt; console.log(responese)) .catch(err =&gt; console.log(err)) url：访问地址 options：常用配置参数 response: 请求返回对象 请求参数配置 options 详情可参考MDN fetch fetch存在的问题及解决方案 得到数据你需要两个步骤1234567fetch('https://api.github.com/users/lvzhenbang/repos') .then(res =&gt; &#123; console.log(res) return res.text() &#125;).then(data =&gt; &#123; console.log(data) &#125;) 通过上面的代码，可以发现直接打印返回的 Response 对象中压根就没有数据，要想获取到所需的数据，必须经一个中间的方法 response.text() （fetch提供了5中方法） 而反观 axios 使用起来就要方便的多，它返回的 Response 对象中却有数据，在 data 属性内。参考代码如下： 12axios.get('https://api.github.com/users/lvzhenbang/repos') .then(res =&gt; console.log(res)); 当然，这也不算是一个大问题，就是使用略显麻烦了点。 fetch的请求默认是不带 cookie解决这个问题，需要在 options 中配置 {credentials: &#39;include&#39;} 并非所有的请求错误都会 reject也就是说 catch 方法并不能捕获所有的错误，当错误可以用一个状态码（如：404，500等）的形式表示时，fetch 返回的 Promise 不会拥有reject，只有当网络故障或请求被阻止时 catch 才有效。 解决这个问题，我们可判断 Response 对象中的 ok 是否为true，如果不是，用 Promise 手动添加一个 reject 即可。参考代码如下：123456789101112fetch('https://api.github.com/usrs/lvzhenbang/repos') .then(res =&gt; &#123; if (res.ok) &#123; return res.text() &#125; else &#123; return Promise.reject('请求失败') &#125; &#125;).then(data =&gt; &#123; console.log(data) &#125;).catch(err =&gt; &#123; console.log(err) &#125;) 如果不手动添加 reject 将打印出 undefined，而这并不是我们想要的，当然使用 axios 则不需要考虑这个问题，代码如下：123axios.get('https://api.github.com/usrs/lvzhenbang/repos') .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)); fetch 的优化由于 res.text() 方法返回的就是一个 promise ，所以可以直接调用 .then ；此外为了保证所有的错误都返回一个统一的格式（都返回一个 Promise），上面的代码可以优化如下：123456789101112131415fetch('https://api.github.com/usrs/lvzhenbang/repos') .then(res =&gt; &#123; return res.text() .then(data =&gt; &#123; if (res.ok) &#123; return data &#125; elese &#123; return Promise.reject(json) &#125; &#125;) &#125;).then(data =&gt; &#123; console.log(data) &#125;).catch(err =&gt; &#123; console.log(err) &#125;) 玩过express/koa的同学，或者对后端有一定了解的同学都知道，服务器在某些情况下也会返回一些提示信息，那么应该如何处理呢？常见的错误提示包括一个状态码（status）和提示信息（msg），代码修改如下：1234567891011121314151617181920// server:res.status(404).send(&#123; err: 'not found'&#125;)// client:fetch('https://api.github.com/usrs/lvzhenbang/repos') .then(handleResponse).then(data =&gt; &#123; console.log(data) &#125;).catch(err =&gt; &#123; console.log(err) &#125;)function handleResponse (res) &#123; return Promise.reject(Object.assign(&#123;&#125;, res.text(), &#123; status: res.status, msg: res.statusText &#125;))&#125; 兼容解决方案以上问题解决并优化fetch的使用后，发现fetch还是一个不错的选择。针对不同使用情况可以作如下处理： 首先，要引入 es5-shim 解决fetch这个新特性的同构； 其次，要引入 es6-promise 解决promise的兼容问题； 然后，引入 fetch-ie8 解决fech的同构问题； 最后，引入 fetch-jsonp 解决跨域问题。 当然，你也不需要针对性的解决这些问题，GitHub团队提供了一个polyfill解决方案，你不需要一步步的是实现。只需要两步： 安装 fetch package 1npm install whatwg-fetch --save 在使用的模块引入 fetch123import 'whatwg-fetch'window.fetch(url, options) 其他的使用和 fetch 则这个原生的API雷同。 哪些情况可以放弃使用fetch获取Promsie的状态，如：isRejected, isResolved 如果使用习惯了jquery的progress方法的，或者使用deffered的一些方法 具体 fetch 实现了哪些与jquery类似的方法可参考whatwg-fetch 或者 fetch-issue]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]IE9 跨域请求兼容]]></title>
    <url>%2Fpost%2F719762e3.html</url>
    <content type="text"><![CDATA[原文地址 背景搭建公司官网的框架时采用了 vuejs, 使用 history router mode 来做 SEO 优化, 使用 fetch 做网络请求, fetch 用 whatwg-fetch 做 polyfill. 根据百度浏览器市场份额统计, 2017年全年 IE9 的占有率达到 9.50%, 并且 vue 框架也是兼容到 IE9, 所以项目要求兼容到 IE9. 但是 fetch polyfill 并不兼容 IE9, 这篇文章追溯问题原因并提出解决方法. 问题: 访问拒绝在 IE9 下打开页面, 发现 fetch 请求报了Unhandled promise rejectionError: 拒绝访问: IE9 IE11 开 IE9 调试模式 怀疑是 fetch 的兼容问题, 查看一下版本: 123$npm list whatwg-fetch project└── whatwg-fetch@2.0.3 查看了一下whatwg-fetch 兼容性: 只支持到 IE10. 然后看到 whatwg-fetchv0.11 可以兼容 IE9, 那就降级一下吧: 123456$ npm uninstall whatwg-fetchremoved 1 package in 4.851s$ npm install whatwg-fetch@0.11+ whatwg-fetch@0.11.1added 1 package in 5.96s 再试一下, 发现还是一样的问题. 问题原因: IE9 XMLHttpRequest 不支持 CORSfetch 的 polyfill 采用了 XMLHttpRequest 实现, 但是在 IE9 下面, XMLHttpRequest 是不支持跨域请求的. IE10 的 XMLHttpRequest 支持跨域, 而 IE8, IE9 需要使用 XDomainRequest 来实现跨域. 那就用 XDomainRequest 实现异步请求, 代码: 1234567891011121314151617181920212223242526272829303132333435function fetchIe9(url, options = &#123;&#125;) =&gt; &#123; if (window.XDomainRequest) &#123; // https://developer.mozilla.org/en-US/docs/Web/API/XDomainRequest // only support GET and POST method // request and response content type should be JSON // without response status code return new Promise((resolve, reject) =&gt; &#123; const method = options.method || 'GET'; const timeout = options.timeout || 30000; let data = options.body || options.params || &#123;&#125;; if (data instanceof Object) &#123; data = JSON.stringify(data); &#125; const XDR = new XDomainRequest(); XDR.open(method, url); XDR.timeout = timeout; XDR.onload = () =&gt; &#123; try &#123; const json = JSON.parse(XDR.responseText); return resolve(json.data); &#125; catch (e) &#123; reject(e); &#125; return reject(&#123;&#125;); &#125;; XDR.ontimeout = () =&gt; reject('XDomainRequest timeout'); XDR.onerror = () =&gt; reject('XDomainRequest error'); XDR.send(data); &#125;); &#125; else &#123; // native fetch or polyfill fetch(XMLHttpRequest) // fetch... &#125;&#125; 需要注意的是: XDomainRequest 只支持 GET 和 POST mehtod XDomainRequest 不支持带 cookie XDomainRequest 不能设置 responseType, 通信双方需要约定数据格式 XDomainRequest 的响应没有 response status code 题外话: whatwg-fetch 一直采用 XMLHttpRequest 来做 polyfill, whatwg-fetch1.0+ 不支持 IE9, 并不是因为没有采用 XDomainRequest, 而是因为 IE9 的状态码不符合 fetch 规范, 而 polyfill 的目标是 polyfill 规范, 而不是做兼容. 问题: 请求异常终止和挂起写好了代码, 在 IE9 中, 网络请求非常诡异, 经常不行: 请求只持续了不到 1ms, 并且接收数据为 0B, 没有状态码; 但是在少数时候是可以成功请求并获取数据的. IE9 IE11 开 E9 调试模式此时 IE11 的 IE9 调试模式是可以的, 看来模拟器还是模拟不到位. 查了好久, 终于看到一篇文章: Internet Explorer Aborting AJAX Requests : FIXED IE timing out the request even though data is being transmitted. 主要的原因大概是 IE9 会将一个正在传输的请求 timeout 掉. 解决办法是: 添加 onprogress 事件回调, 告知 IE9 这个请求是活动中的, 不要 timeout 掉. 将请求的发送放到主线程之外, 保证 XDomainRequest 已经完全初始化好. 最终代码123456789101112131415161718192021222324252627282930313233343536373839function fetchIe9(url, options = &#123;&#125;) =&gt; &#123; if (window.XDomainRequest) &#123; // https://developer.mozilla.org/en-US/docs/Web/API/XDomainRequest // only support GET and POST method // request and response content type should be JSON // without response status code return new Promise((resolve, reject) =&gt; &#123; const method = options.method || 'GET'; const timeout = options.timeout || 30000; let data = options.body || options.params || &#123;&#125;; if (data instanceof Object) &#123; data = JSON.stringify(data); &#125; const XDR = new XDomainRequest(); XDR.open(method, url); XDR.timeout = timeout; XDR.onload = () =&gt; &#123; try &#123; const json = JSON.parse(XDR.responseText); return resolve(json.data); &#125; catch (e) &#123; reject(e); &#125; return reject(&#123;&#125;); &#125;; // fix random aborting: https://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/ XDR.onprogress = () =&gt; &#123;&#125;; XDR.ontimeout = () =&gt; reject('XDomainRequest timeout'); XDR.onerror = () =&gt; reject('XDomainRequest error'); setTimeout(() =&gt; &#123; XDR.send(data); &#125;, 0); &#125;); &#125; else &#123; // native fetch or polyfill fetch(XMLHttpRequest) // fetch... &#125;&#125; 结论 IE9 发起跨域请求要使用 XDomainRequest, 因为 IE9 下的 XMLHttpRequest 不支持跨域调用. XDomainRequest 只支持 GET 和 POST method, 并且没有 response status code, 可以说是不完善的 HTTP 异步请求对象. XDomainRequest 不支持指定 responseType, 使用时建议请求和返回数据格式约定为 JSON. whatwg-fetch1.0+ 不支持 IE9, 是因为 IE9 的状态码不符合 fetch 规范, 而 polyfill 的目标是 polyfill 规范, 而不是做兼容.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Ajax Fetch Axios之间的详细区别以及优缺点]]></title>
    <url>%2Fpost%2Fdab34b8d.html</url>
    <content type="text"><![CDATA[原文地址 jQuery ajax12345678$.ajax(&#123; type: 'POST', url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125;) 优缺点： 本身是针对mvc模式的编程，不符合现在mvvm的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） 尽管JQuery对我们前端的开发工作曾有着（现在也仍然有着）深远的影响，但是我们可以看到随着VUE，REACT新一代框架的兴起，以及ES规范的完善，更多API的更新，JQuery这种大而全的JS库，未来的路会越走越窄。 axiosaxios中文文档 1234567891011axios(&#123; method: 'POST', url: '' data:&#123; name:'zhang' &#125;&#125;).then(function (response)&#123; console.log(response)&#125;).then(function (error)&#123; console.log(error)&#125;) Vue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax，想必让Axios进入了很多人的目光中。Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，从它的官网上可以看到它有以下几条特性： 优缺点： 从 node.js 创建 http 请求 支持 Promise API 客户端支持防止CSRF 提供了一些并发请求的接口(重要，方便了很多的操作)这个支持防止CSRF其实挺好玩的，是怎么做到的呢，就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。 Axios既提供了并发的封装，也没有下文会提到的fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。 fetchfetch号称是AJAX的替代品，它的好处在《传统 Ajax 已死，Fetch 永生》中提到有以下几点： 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里更好更方便的写法，诸如：1234567try&#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125;catch (e)&#123; console.log("Oops, error", e);&#125; 脱离了XHR，是ES规范里新的实现方式1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理2）fetch默认不会带cookie，需要添加配置项3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费4）fetch没有办法原生监测请求的进度，而XHR可以 PS: fetch的具体问题大家可以参考：《fetch没有你想象的那么美》 《fetch使用的常见问题及解决方法》 看到这里，你心里一定有个疑问，这鬼东西就是个半拉子工程嘛，我还是回去用Jquery或者Axios算了——其实我就是这么打算的。但是，必须要提出的是，我发现fetch在前端的应用上有一项xhr怎么也比不上的能力：跨域的处理。 我们都知道因为同源策略的问题，浏览器的请求是可能随便跨域的——一定要有跨域头或者借助JSONP，但是，fetch中可以设置mode为no-cors（不跨域），如下所示：12345fetch('/users.json', &#123; method: 'post', mode: 'no-cors', data: &#123;&#125;&#125;).then(function() &#123; /* handle response */ &#125;); 为什么要用axiosaxios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack使用purgecss-webpack-plugin去除无用的css]]></title>
    <url>%2Fpost%2Ffc406327.html</url>
    <content type="text"><![CDATA[使用插件purgecss-webpack-plugin，直接使用配置很简单文档 如果使用css modules，需要配置白名单whitelistPatterns， 如果开启css modules，配合babel-plugin-react-css-modules一起使用，需要特别注意css的引入方式是import styles from &quot;./index.module.css&quot;;，而不能省略变量styles。 如果import &quot;./index.module.css&quot;;这样的话，模块话的css会被忽略。 12345678910111213141516171819plugins: [ new MiniCssExtractPlugin(&#123; filename: "css/[name].[contenthash:8].css", chunkFilename: "css/[name].[contenthash:8].css" &#125;), // 放在MiniCssExtractPlugin之后 new PurgecssWebpackPlugin(&#123; // collectWhitelistPatternsChildren: () =&gt; &#123; // return [/^purify-/]; // &#125;, // whitelist: () =&gt; &#123; // return [/\.module\.(css|scss|sass)$/]; // &#125;, whitelistPatterns: () =&gt; &#123; return [/^purify-/]; &#125;, paths: () =&gt; glob.sync([`$&#123;paths.appSrc&#125;/**/*`], &#123; nodir: true &#125;) &#125;)]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在deepin中实现科学上网]]></title>
    <url>%2Fpost%2Fc919bec2.html</url>
    <content type="text"><![CDATA[购买ss 进入 shadowsocks（点就是点，哈哈），购买ss服务器 购买时候会填写很多信息，除了邮箱保证是对的，其他无所谓 如果没有多设备使用要求，买最便宜的套餐就行（一年100多），自己选择。 ss客户端linux版本下载地址 配置客户端的教程, 进入 shadowsocks（点就是点，哈哈）， 打开技术支持==&gt; 帮助中心 ==&gt; Shadowsocks使用教程， 点击Shadowsocks客户端设置教程-Linux，里面有详细介绍，请自行查看。 生成PACpac文件可以在github找， 也可以通过安装genpac自己生成。 代码清单1123456# 安装pipsudo apt install python3-pip# 安装genpacsudo pip3 install genpac# 生成pac文件， 端口要和本地ss的端口一致，我本地的是1080genpac --pac-compress --pac-proxy 'SOCKS5 127.0.0.1:1080' --format pac -o ~/auto.pac 配置系统代理打开deepin系统，设置==&gt;网络==&gt;系统代理==&gt;自动，在配置URL中填入你的pac文件位置。 代码清单21file:///home/登录用户名/auto.pac 搞定， 欢迎来到真实的互联网！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React全新的Context API]]></title>
    <url>%2Fpost%2Fffc42bbf.html</url>
    <content type="text"><![CDATA[Context 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。官方文档特别提醒说不要仅仅为了避免在几个层级下的组件传递 props 而使用 context，它是被用于在多个层级的多个组件需要访问相同数据的情景。 16.3之前的 Context API 的使用场景以及缺陷 该版本已经不建议使用 我们都知道在 React 中父子组件可以通过 props 自顶向下的传递数据。但是当组件深度嵌套时，从顶层组件向最内层组件传递数据就不那么方便了。手动在每一层组件上逐级传递 prop 不仅书写起来很繁琐同时还会为夹在中间的组件引入不必要的 prop。这时 Context API 就派上用场了。你只需要在外层组件上声明要传递给子组件的 Context： 注意：由于React v15.5开始 React.PropTypes已经废弃，现在需要单独使用prop-types来定义contextTypes。通过在 Parent 上添加 childContextTypes 和 getChildContext ， React会向下自动传递参数，任何组件只要在它的子组件中就能通过定义contextTypes来获取参数。代码清单112345678910111213141516class Parent extends React.Component &#123; getChildContext() &#123; return &#123;color: "purple"&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Child text=&#123;message.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125;Parent.childContextTypes = &#123; color: PropTypes.string&#125;; 然后就可以在任意一级子组件上访问 Context 里的内容了：代码清单2123456789101112131415161718192021222324252627282930import PropTypes from "prop-types";import React from "react";class Child extends React.Component &#123; render() &#123; return ( &lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; 我是按钮 &lt;/button&gt; ); &#125;&#125;Child.contextTypes = &#123; color: PropTypes.string&#125;;// 上面的代码也可以通过无状态组件实现import PropTypes from "prop-types";import React from "react";const Button = (&#123;children&#125;, context) =&gt;( &lt;button style=&#123;&#123;background: context.color&#125;&#125;&gt; 我是按钮 &lt;/button&gt; );Child.contextTypes = &#123; color: PropTypes.string&#125;; 这个版本的 Context API 和 shouldComponentUpdate 搭配使用时很容易出问题。让我们通过一个小例子来简单说明，假设有以下组件结构：12345&lt;A&gt; &lt;B&gt; &lt;C /&gt; &lt;/B&gt;&lt;/A&gt; 其中组件 A 会通过 getChildContext 设置 Context，组件 C 通过 this.context 读取 Context。 当组件 A 要更新 Context 的时候发生什么呢？ 组件 A 通过 setState 设置新的 Context 值同时触发子组件的 rerender。 组件 B rerender。 组件 C rerender，并在自己的 render 方法中拿到更新后的Context。 整个流程看起来好像没什么问题。如果我们在组件 B 上定义了 shouldComponentUpdate 会发生什么呢？ 组件 A 通过 setState 设置新的 Context 值同时触发子组件的 rerender。 组件 B 执行 shouldComponetUpdate，由于组件 B 自身并不依赖 Context，所以 shouldComponetUpdate 检测到 state 与 prop 均未变化因此返回 false。无需重新 render。 由于 B 组件没有 rerender。这导致组件 C 也不会rerender，因此也就无法获取到最新的 Context 值。 由于 shouldComponentUpdate 是一个 React 开发人员经常使用的优化方法。所以如果代码里使用了这一版的 Context API 很大概率会遇到上述问题。 PropTypes 属性验证在打包为生产环境的时候一般会选择除去，这种使用方式也会产生选择的困难。 16.3新版Context API新版 Context API 都由以下几部分组成： React.createContext 方法用于创建一个 Context 对象。该对象包含 Provider 和 Consumer两个属性，分别为两个 React 组件。 Provider 组件。用在组件树中更外层的位置。它接受一个名为 value 的 prop，其值可以是任何 JavaScript 中的数据类型。 Consumer 组件。可以在 Provider 组件内部的任何一层使用。它接收一个名为 children 值为一个函数的 prop。这个函数的参数是 Provider 组件接收的那个 value prop 的值，返回值是一个 React 元素（一段 JSX 代码）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let ThemeContext = React.createContext(&#123; style: &#123; color: "green", background: "red", &#125;&#125;);function Button(&#123; theme, ...props &#125;) &#123; return ( &lt;button &#123;...props&#125; &gt;我是按钮&lt;/button&gt; );&#125;function ThemedButton(props) &#123; return ( /* * Consumer会自动获取离其最近的Provider提供的value * */ &lt;ThemeContext.Consumer&gt; &#123; (context) =&gt; &#123; return &lt;Button &#123;...props&#125; style=&#123;context.style&#125; /&gt;; &#125; &#125; &lt;/ThemeContext.Consumer&gt; );&#125;function Toolbar(props) &#123; return ( &lt;ThemeContext.Provider value=&#123;&#123; style: &#123; color: "red", background: "green", &#125; &#125;&#125;&gt; &lt;ThemedButton /&gt; &lt;/ThemeContext.Provider&gt; );&#125;ReactDOM.render( &lt;Toolbar /&gt;, document.getElementById("root")); 这版 Context API 的几个特点： Provider 和 Consumer 必须来自同一次 React.createContext 调用。也就是说 NameContext.Provider 和 AgeContext.Consumer 是无法搭配使用的。 React.createContext 方法接收一个默认值作为参数。当 Consumer 外层没有对应的 Provider 时就会使用该默认值。 Provider 组件的 value prop 值发生变更时，其内部组件树中对应的 Consumer 组件会接收到新值并重新执行 children 函数。此过程不受 shouldComponentUpdete 方法的影响。 Provider 组件利用 Object.is 检测 value prop 的值是否有更新。注意 Object.is 和 === 的行为不完全相同。具体细节请参考 Object.is 的 MDN 文档页。 Consumer 组件接收一个函数作为 children prop 并利用该函数的返回值生成组件树的模式被称为 Render Props 模式。 注意： 因为 context 使用引用标示符（reference identity）来判断何时需要重新渲染，所以有些情况下，当 provider 的父元素重新渲染时，会触发 consumer 的非内部渲染。为了避免这个问题，可以将 value 放在 render 的外部，如 state 通过高阶函数简化123456789101112131415import &#123; ThemeContext &#125; from "./themeContext";import React from "react";export function withTheme(Component) &#123; return function (props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123; (context) =&gt; &#123; return &lt;Component &#123;...props&#125; style=&#123;context.style&#125; /&gt;; &#125; &#125; &lt;/ThemeContext.Consumer&gt; ); &#125;;&#125; 16.6 提供了便利的API为了简化 Context API的使用，React 16.6的版本新提供了一个contextType来简化使用 123456789101112131415import &#123; ThemeContext &#125; from "./themeContext";import React from "react";class Button extends React.Component &#123; static contextType = ThemeContext; render() &#123; return ( &lt;button onClick=&#123;this.context.change&#125; style=&#123;this.context.style&#125;&gt;我是按钮3333&lt;/button&gt; ); &#125;&#125;export &#123; Button &#125;; 通过这种方式，每个组件只能注册一个context对象。如果需要读取多个context的value值，参加Consuming Multiple Contexts. 参考http://www.cnblogs.com/qiqi105/p/8881097.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]CSS Display属性与盒模型]]></title>
    <url>%2Fpost%2F99460206.html</url>
    <content type="text"><![CDATA[原文地址 Box SizingBox Sizing用来设置元素大小的计算方式，在HTML中，任何HTML元素都会被呈现为一个矩形。该矩形由内容、内边距、边框、外边距构成。举个例子：1234567891011&lt;style&gt;.box-demo&#123; width: 100px; height: 100px; border: 50px solid green; padding: 30px; margin: 50px; background: yellow;&#125;&lt;/style&gt;&lt;div class="box-demo"&gt;&lt;/div&gt; 上述的中，内容、边距与边框如下图所示： 黄色的背景作用于内容和内边距构成的矩形，其宽高为160px：宽度100px+两侧的内边距30pxX2； 绿色部分为边框，宽度为50px； 与浏览器边框的距离为外边距，宽度为50px。 例子中 width 属性定义的是内容的宽度，不包含边距、边框。然而在 IE 中 width 定义的是内容+内边距+边框的宽度。这是由box-sizing属性来定义的，前者的默认值为content-box，后者的默认值为border-box。 Display了解了box-sizing之后，我们回到display属性。display指定了元素渲染Box的类型（type of rendering box）。我们来看它常用的取值： none: 隐藏元素； inline：行内元素，顾名思义，用于把一个元素放在行的内部； block：块元素，用于显示占用一行的块； inline-block：以block的方式渲染，以inline的方式放置； table-cell：以表格元素的方式显示。 隐藏元素none是最容易理解的取值。当一个元素的 displayCSS 属性被设为 none 时，该元素不会被渲染，也不会占位，就像不存在一样。对布局不会产生任何影响。 行内元素行内（inline）元素不会打断文本流，默认（UA）显示为inline的元素包括：，，等。它们的出现不会使得后续元素另起一行。行内元素可以设置margin与padding，但margin只在水平方向上起作用：123456div&#123; display: inline; background: red; padding: 10px; margin: 10px;&#125; 上图中，红色背景的是一个&lt;div&gt;，其大小为内容大小+padding，左右的空隙即为外边距 margin。可以看到在 Chrome 中，这个 inline 的 遮挡了出现在它前面的文本，同时被出现在它后面的文本所遮挡。这正是流式文档的特性。 另外，对 inline 元素设置 width 与 height 是不起作用的。 块元素块（block）元素会中断当前的文本流，另起一行，并在父元素中尽可能地占据最大宽度。常见的块元素有&lt;p&gt;、&lt;div&gt;、&lt;section&gt;等。通常块元素不可包含在行内元素内部。 行内块行内块（inline-block）将会产生一个块元素，并以行内元素的方式放置。什么意思呢？该元素的样式是以块元素的方式来渲染的，例如可以设置宽和高，然后以行内元素的方式放置在其上下文中，就像在行内元素的位置上替换成这个块元素一样。 MDN：The element generates a block element box that will be flowed with surrounding content as if it were a single inline box. 同样地，我们在一行文本内加入一个，这次将它的display设为inline-block.1234567div&#123; display: inline-block; background: yellow; padding: 10px; margin: 10px; height: 20px;&#125; 此时，垂直方向的margin和height都起作用了。 蓝色部分为内容，可以看到其高度为20px； 绿色部分为10px的padding； 接着，border为空； 红色为10px的margin； inline-block与inline的不同在于：垂直方向上的margin也会起作用，并且可以设置width和height。inline-block是非常常用的样式设置。 表格元素display 设为table-cell的元素与&lt;td&gt;标签的行为一致，即可设置padding，不接受margin，可伸缩的width。 IE6/7不支持table-cell，然而WinXP已经下架。Win7的标配是IE8。现在可以放心地使用table-cell了！ 利用 table-cell 属性可以在不写&lt;table&gt;标签的情况下完成表格布局。12345678910111213141516171819&lt;style&gt;.left, .right&#123; display: table-cell; line-height: 50px;&#125;.left&#123; background: yellow; min-width: 150px;&#125;.right&#123; background: lightgreen; width: 100%;&#125;&lt;/style&gt;&lt;div&gt; &lt;div class="left"&gt;This is left cell&lt;/div&gt; &lt;div class="right"&gt;This is right cell&lt;/div&gt;&lt;/div&gt; 左侧固定150px宽度，右侧自适应。]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈JSON.stringify]]></title>
    <url>%2Fpost%2Fcf7d3d1c.html</url>
    <content type="text"><![CDATA[JSON不是一种编程语言，而是一种独立于语言的数据交换格式。它获得了当今大部分语言的支持，从而可以在不同平台间进行数据交换。JSON可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。 认识JSON.stringify在JavaScript中，操作json格式的数据主要通过JSON对象，JSON.stringify是其中一个将JS对象序列化的函数。下面看几段代码 代码清单112345678var json = &#123; name: "xingmu", age: 23, phone: ["huawei", "xiaomi", "sanxing"], getJob()&#123; return "coding";&#125;&#125;console.log(JSON.stringify(json));// &#123;"name":"xingmu","age":23,"phone":["huawei","xiaomi","sanxing"]&#125; 上面代码中的函数getJob在序列化过程中被忽略了。 代码清单212345678var json = &#123; name: "xingmu", age: 23, phone: ["huawei", "xiaomi", "sanxing"], job: undefined&#125;;console.log(JSON.stringify(json));// &#123;"name":"xingmu","age":23,"phone":["huawei","xiaomi","sanxing"]&#125; 上面代码中的job值为undefined在序列化过程中被忽略了。 代码清单312345678var json = &#123; name: "xingmu", age: 23, phone: ["huawei", "xiaomi", "sanxing"], job: Symbol()&#125;;console.log(JSON.stringify(json));// &#123;"name":"xingmu","age":23,"phone":["huawei","xiaomi","sanxing"]&#125; 上面代码中的job值为Symbol类型在序列化过程中被忽略了。 代码清单412345678var json = &#123; name: "xingmu", age: 23, phone: ["huawei", "xiaomi", "sanxing"], [Symbol()]: "coding"&#125;;console.log(JSON.stringify(json));// &#123;"name":"xingmu","age":23,"phone":["huawei","xiaomi","sanxing"]&#125; 上面代码中的key为Symbol类型在序列化过程中被忽略了。 代码清单512345678var json = &#123; name: "xingmu", age: 23, phone: ["huawei", function()&#123;&#125;, undefined, Symbol()], job: "coding"&#125;;console.log(JSON.stringify(json));// &#123;"name":"xingmu","age":23,"phone":["huawei",null,null,null],"job":"coding"&#125; 上面的代码中数组phone中的函数、undefined在转换后，变成了null。 代码清单61234567891011121314151617181920212223242526272829303132var notEnum = Symbol("不可枚举symbol");var proto = &#123; [Symbol("可枚举symbol")]: "可枚举symbol", name: "可枚举属性"&#125;;// 不可枚举属性Object.defineProperty(proto, "age", &#123; value: 234&#125;);// 不可枚举symbol属性Object.defineProperty(proto, notEnum, &#123; value: "不可枚举symbol"&#125;);var json = &#123; name: "xingmu", age: 23, job: "coding"&#125;;// 继承Object.setPrototypeOf(json, proto);// 不可枚举属性Object.defineProperty(json, "address", &#123; value: "sh"&#125;);//可枚举Object.defineProperty(json, "city", &#123; enumerable:true, value: "ks"&#125;);console.log(JSON.stringify(json));// &#123;"name":"xingmu","age":23,"job":"coding","city":"ks"&#125; 上面代码中的继承属性和不可枚举属性在序列化过程中被忽略了。 从上面的几段代码中发现，函数/Symbol/undefined在序列化的过程中被忽略了，而当他们出现在数组中的时候，又被转换为了null。继承属性和不可枚举属性在序列化过程中也被忽略了，这是为什么呢？ 因为JSON是一个通用的文本格式，和语言无关。设想如果将函数定义也可以被序列化的话，接收数据一方没有对应的格式，无法通过合适的方式将其呈现出来，要完成这个过程将极为复杂。所以和语言特别相关的一些特性在序列化的过程中会被忽略，比如函数/Symbol/undefined这些JavaScript中特有的类型。 在文档里也提到JavaScript对象在进行序列化过程中需要注意五个方面的问题： 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。 undefined、任意的函数以及 symbol 值，出现在非数组对象的属性值中时，在序列化过程中会被忽略；出现在数组中时，被转换成 null。 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。 继承属性和不可枚举的属性会被忽略 对象的toJSON函数上一节我们聊到有些数据类型是无法参与序列化，有没有什么办法可以解决这个问题呢，那就要用到toJSON了。 MDN文档里是这么介绍toJSON的：如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为，这时就不是该对象被序列化，而是调用 toJSON 方法后的返回值参与被序列化。 MDN的一个例子，代码清单71234567var obj = &#123; foo: 'foo', toJSON: function () &#123; return 'bar'; &#125;&#125;;JSON.stringify(obj); // '"bar"' 有没有很神奇，下面我们在代码清单1的基础上增加toJSON，看能做点什么 代码清单812345678910111213141516var json = &#123; name: "xingmu", age: 23, phone: ["huawei", "xiaomi", "sanxing"], getJob() &#123; return "coding"; &#125;, toJSON() &#123; let &#123; name &#125; = json; let job = json.getJob(); return &#123; name, job &#125;; &#125; &#125;;console.log(JSON.stringify(json));// &#123;"name":"xingmu","job":"coding"&#125; 很酷，有没有，我们可以在toJSON中任意定义可以参与序列化的属性，如果在构造函数中使用，将极大的增加复用性，让代码看起来更加优雅简介。 stringify的可选参数JSON.stringify的语法是这样定义的JSON.stringify(value[, replacer [, space]])。 replacer： 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理； 如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中； 如果该参数为null或者未提供，则对象所有的属性都会被序列化； 代码清单9123456789101112function replacer(key, value) &#123; if (typeof value === "string") &#123; return undefined; &#125; return value;&#125;var foo = &#123; foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7 &#125;;console.log(JSON.stringify(foo, replacer));// &#123;"week":45,"month":7&#125;.console.log(JSON.stringify(foo, ['week', 'month']));// '&#123;"week":45,"month":7&#125;', 只保留“week”和“month”属性值。 space：指定缩进用的空白字符串，用于美化输出（pretty-print） 如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格； 如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格； 如果该参数没有提供（或者为null）将没有空格。 请参考文档示例。 扩展序列化概念对象的寿命通常随着生成该对象的程序的终止而终止。有时候，可能需要将对象的状态保存下来，在需要时再将对象恢复。我们把对象的这种能记录自己的状态以便将来再生的能力。叫作对象的持续性(persistence)。对象通过写出描述自己状态的数值来记录自己 ，这个过程叫对象的序列化(Serialization) 。序列化的主要任务是写出对象实例变量的数值。如果交量是另一对象的引用，则引用的对象也要序列化。 序列化又叫串行化。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片懒加载]]></title>
    <url>%2Fpost%2Ff0e261b6.html</url>
    <content type="text"><![CDATA[什么是懒加载懒加载其实就是延迟加载，是对网页性能优化的一种方式，比如当访问一个页面的时候，优先显示可视区域的图片而不是一次性加载所有的图片，当需要显示的时候在发送图片请求，避免打开网页的时候加载过多的资源。 什么时候使用懒加载 当页面中一次性载入很多图片的时候 SPA页面中的图片一定要做懒加载，否则你会发现路由跳转很慢，很慢。因为新页面路由是在dom挂在完之后才会跳转的。如果你的页面有很多图片，那么一定要做图片懒加载，否则会瞬间发出很多请求，还涉及页面渲染，重绘。因为处理并发请求比较慢，浏览器对同一域名并发http请求是有限制的（chrome是6个，一般都在8个以内），但是加载到渲染还是很消耗性能。可以在dom mount之后，加个延时做图片懒加载。这样页面会跳转会快很多。 懒加载原理标签有一个属性是src，用来表示图像的URL，当这个属性的值不为空时，浏览器就会根据这个值发送请求。如果没有src属性，就不会发送请求。 可以通过先不给 设置 src，把图片真正的 URL 放在另一个属性 data-src 中，在需要的时候也就是图片进入可视区域的之前，将 URL 取出放到 src 中。 实现HTML结构1234567891011121314151617&lt;div class="container"&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" data-src="./img/img1.png"&gt; &lt;/div&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" data-src="./img/img2.png"&gt; &lt;/div&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" data-src="./img/img3.png"&gt; &lt;/div&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" data-src="./img/img4.png"&gt; &lt;/div&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" data-src="./img/img5.png"&gt; &lt;/div&gt;&lt;/div&gt; 仔细观察一下， 标签此时是没有 src 属性的，只有 alt 和 data-src 属性。 alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。 data-* 全局属性：构成一类名称为自定义数据属性的属性，可以通过HTMLElement.dataset来访问。 如何判断元素是否在可视区域通过scrollTop判断 通过document.documentElement.clientHeight获取屏幕可视窗口高度 通过element.offsetTop获取元素相对于文档顶部的距离 通过document.documentElement.scrollTop获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离 然后判断element.offsetTop - document.documentElement.scrollTop &lt; document.documentElement.clientHeight是否成立，如果成立，元素就在可视区域内。 使用getBoundingClientRect通过getBoundingClientRect()方法获取元素的大小及其相对于视口的位置，这个方法返回一个名为ClientRect的DOMRect对象，包含了top、right、bottom、left、width、height这些值 返回的元素位置是相对于左上角而言的，而不是边距。假设const bound = el.getBoundingClientRect();来表示图片到可视区域顶部距离； 并设 const clientHeight = window.innerHeight; 来表示可视区域的高度。随着滚动条的向下滚动，bound.top会越来越小，也就是图片到可视区域顶部的距离越来越小，当bound.top===clientHeight时，图片的上沿应该是位于可视区域下沿的位置的临界点，再滚动一点点，图片就会进入可视区域。也就是说，在bound.top&lt;=clientHeight时，图片是在可视区域内的。 12345678function isInSight(el) &#123; const bound = el.getBoundingClientRect(); const clientHeight = window.innerHeight; // 如果只考虑向下滚动加载 // const clientWidth = window.innerWeight; // +100是为了提前加载。 return bound.top &lt;= clientHeight + 100;&#125; 加载图片页面打开时需要对所有图片进行检查，是否在可视区域内，如果是就加载。12345678910111213141516function checkImgs() &#123; const imgs = document.querySelectorAll(".my-photo"); Array.from(imgs).forEach(el =&gt; &#123; if (isInSight(el)) &#123; loadImg(el); &#125; &#125;);&#125;function loadImg(el) &#123; // 这里可以保存一个已加载过的图片，这样每次检查的时候就不用循环全部的图片了 if (!el.src) &#123; const source = el.dataset.src; el.src = source; &#125;&#125; 上面的代码还有个问题就是 checkImgs 函数什么时候执行，这就要用来函数的防抖]]></content>
      <categories>
        <category>javascript</category>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>dom</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可以透传ref的React高阶组件]]></title>
    <url>%2Fpost%2Fe79ee8fc.html</url>
    <content type="text"><![CDATA[DOM组件使用forwardRef通常情况下，我们想获取一个组件或则 DOM 元素通过 Ref 就可以实现，但是某些时候我们需要在子父级组建中传递使用实例，react在16.3版本之后React提供createRef的同时，也提供了Forwarding Refs来满足这个需求，特别是开发一些重复使用的组建库时尤其好用。比如下面的例子： 1234567function MyButton(props) &#123; return ( &lt;button className="MyButton"&gt; &#123;props.children&#125; &lt;/button&gt; );&#125; 上面的代码中 MyButton 组件渲染了一个 DOM 元素。对于使用者而言，React 隐藏了将代码渲染成页面元素的过程，当其他组件使用MyButton时，并没有任何直接的方法来获取MyButton中的 button 元素，这样的设计方法有利于组件的分片管理，降低耦合。 但是像 MyButton 这样的组件，其实仅仅是对基本的 HTML 元素进行了简单的封装。有时候，实现某些效果需要直接操作DOM，比如focus、selection 和 animations 效果。 下面的例子将Forwarding Refs添加到MyButton组件中，以实现实例传递的效果。 123456789const MyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className="MyButton"&gt; &#123;props.children&#125; &lt;/button&gt;));// 通过ref可以直接操作&lt;button&gt;元素:const ref = React.createRef();&lt;MyButton ref=&#123;ref&#125;&gt;Click me!&lt;/MyButton&gt;; 这个时候，ref可以直接操作 button 元素。其实执行过程非常简单，也就下面5步： 通过React.createRef()方法创建一个ref实例。 将其作为一个ref属性参数传递给MyButton组件。 使用React.forwardRef方法来创建一个组件，并将ref作为第二个参数传递。 将ref参数以ref属性的方式传递给 button 元素。 在渲染之后，可以使用ref.current来获取 button 元素的实例。 需要注意的是只有使用React.forwardRef来创建一个组件时，第二个ref参数才会存在。其他情况下组件并不会接收到ref参数。Forwarding Refs特性并不仅仅局限于用在HTML DOM元素上，这种方式也实用于组件之间传递Ref。 在高阶组件中使用Forwarding Refs高阶组件（HOC）一般用来增强一般组件。一般组件被包装之后对于使用者来说并不清楚其是否是被包装过，此时使用 Ref 得到的是最外层高阶组件的实例。因此Forwarding Refs特性对于高阶组件来说更有价值。 下面是一个高阶组件记录日志的例子：123456789101112131415function logProps(WrappedComponent) &#123; class LogProps extends React.Component &#123; componentDidUpdate(prevProps) &#123; console.log('old props:', prevProps); console.log('new props:', this.props); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; return LogProps;&#125; logProps组件用于在每次数据更新前后记录props中的数据。我们用其包装前面的MyButton组件。1234567891011class MyButton extends React.Component &#123; focus() &#123; // ... &#125; render() &#123; // &#125;&#125;export default logProps(MyButton); 此时通过import并使用Refs实际上得到的是LogProps的实例：123456789import FancyButton from './FancyButton';const ref = React.createRef();&lt;MyButton label="Click Me" handleClick=&#123;handleClick&#125; ref=&#123;ref&#125;/&gt;; 我们使用Forwarding Refs对高阶组件进行简单的改造即可解决这个问题：12345678910111213141516171819202122function logProps(Component) &#123; class LogProps extends React.Component &#123; componentDidUpdate(prevProps) &#123; console.log('old props:', prevProps); console.log('new props:', this.props); &#125; render() &#123; const &#123;forwardedRef, ...rest&#125; = this.props; // 通过forwardedRef参数传递ref的值 return &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;; &#125; &#125; //然后使用 React.forwardRef 来包装创建 LogProps组件的实例 //注意这里使用 forwardedRef 来传递 父组件的 ref // return React.forwardRef((props, ref) =&gt; &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125;);&#125; 开发调试组件名称显示如果我们不进行任何调整，下面的代码在调试工具中输出的组件名称为ForwardRef(MyComonent)：12345const WrappedComponent = React.forwardRef( function myFunction(props, ref) &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125;); 可以通过displayName来设定想要现实的名字：123456789101112131415161718function logProps(Component) &#123; class LogProps extends React.Component &#123; // ... &#125; //先定义返回的高阶组件方法 function forwardRef(props, ref) &#123; return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125; //然后设定这个组件的名称 const name = Component.displayName || Component.name; forwardRef.displayName = `logProps($&#123;name&#125;)`; //构建组件 return React.forwardRef(forwardRef);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之深入理解ES6参数作用域]]></title>
    <url>%2Fpost%2F183473cc.html</url>
    <content type="text"><![CDATA[参数默认值是变量1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 上面代码中，参数y的默认值等于x，在调用函数的时候，形成一个单独的参数作用域。es标准中参数是从左到右顺序初始化，所以x先于y初始化，当y初始化的时候指向了第一个参数x，而不是指向全局变量x，所以输出2。 例子2 12345678var x = 1;function f(y = x) &#123; let x=2; console.log(y);&#125;f() // 1 在上面的代码中，参数y的默认值等于x。在调用函数f的时候，形成一个单独的参数作用域。es标准中参数是从左到右顺序初始化，此时参数作用域内并没有变量x，在作用域链上查找x在全局作用域，所以y指向全局作用域x。所以函数作用域内x和参数作用域的y没有关系，所以输出1。 如果此时全局变量x不存在，则会报错123456function f(y = x) &#123; let x=2; console.log(y);&#125;f() // ReferenceError: x is not undefined 下面的写法也会报错123456var x=1;function f(x = x) &#123; // ...&#125;f() // ReferenceError: x is not undefined 上面代码中，参数是从左到右顺序初始化的时候，x并不存在，无法使用，不能完成初始化，类似let x=x; 参数默认值为函数例212345678let foo = 'outer';function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar(); // outer 在上面的代码中，参数func的默认值是一个函数。在调用函数的时候，形成一个单独的参数作用域。在这个作用域里面定义了一个变量y指向匿名函数，在匿名函数中的变量foo在参数作用域没有找到变量foo，所以foo指向了外层的全局作用域的foo，所以输出1。 例3123456function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar() // ReferenceError: foo is not defined 上面代码中，函数外层并没有定义变量foo，所以就报错了。 例412345678910var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; // 这里只能使用var声明，如果是let/const会报错，因为参数中已经有x变量了 var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 在上面的代码中，参数作用域里首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向参数作用域的第一个参数x。 函数作用域又定义了一个内部变量x，函数作用域与参数作用域分属不同的作用域，所以两个x不是同一个变量，因此y()执行之后，改变的是参数作用域的x，所以全局作用域的x和函数作用域的x都没有改变。 让我们稍微改变下例4的代码。 例5123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 此时的函数作用域x指向了参数作用域的x，函数y内部的x也指向函数作用域的x，这个时候输入的就是2了。 转换为es5将例4的代码转为es5的就比较清楚参数作用域的范围了。12345678910111213141516//这里是全局作用域var x=1function foo(x, y) &#123; // 这里相当于参数作用域 if (typeof y == 'undefined') &#123; y = function() &#123; x = 2; &#125;; // 参数x屏蔽了全局作用域的x，所以x指向参数中的x &#125; return function() &#123; // 这里相当于函数作用域，重新声明了一个变量x，屏蔽了参数作用域的x // 这里只能使用var声明，如果是let/const会报错 var x = 3; y(); console.log(x); &#125;.apply(this, arguments);&#125; 将例5的代码转为es5的就比较清楚参数作用域的范围了。12345678910111213141516//这里是全局作用域var x=1function foo(x, y) &#123; // 这里相当于参数作用域 if (typeof y == 'undefined') &#123; y = function() &#123; x = 2; &#125;; // 参数x屏蔽了全局作用域的x，所以x指向参数中的x &#125; return function() &#123; // 这里相当于函数作用域，此时函数作用域没有变量x，向上层参数作用域查找x // 所以这里x就是参数作用域的x x = 3; y(); console.log(x); &#125;.apply(this, arguments);&#125; 结论由上面es5的代码可以看出，参数作用域可以访问自己和外层的变量，无法访问函数体内的变量，这样理解起来参数作用域就容易了。 如果还理解不了，就在大脑里把有默认值参数的函数转换为es5的形式，也就豁然开朗。 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。 从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。 参考ES6入门教程 Note 6. ES6: Default values of parameters]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs版本的Gitalk/Gitment评论自动初始化]]></title>
    <url>%2Fpost%2F322747ae.html</url>
    <content type="text"><![CDATA[前言今天搭建blog的最后一步，添加评论功能，一番搜索，看中了Gitalk和Gitment，因为Gitment在github上的代码断更太久，最终选择了Gitalk，关于具体安装和配置，可以参见下面官网和两篇文章 Gitalk官网 Hexo中Gitalk配置使用教程-可能是目前最详细的教程 Hexo NexT主题中集成gitalk评论系统 遇到的问题Gitalk配置完成后，启动hexo，打开文章页面，会出现如下的界面，需要登陆github，完成初始化后才能使用 文章这么一篇一篇的点过去，操作贼麻烦，如果有自动化操作一波，才符合懒人天性，就百度了一下有没有同道中人，已经解决过了，果然有【这里】，一顿操作后，只能放弃。 原因： 发布的时候，每次执行这个脚本，都会为每个链接 创建一个issue，并没有对已经创建的做过滤。 ruby手生，改不动 如此如此，只能自己动手了，nodejs大法。 解决问题生成sitemap站点地图 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 安装插件 在你hexo的根目录，执行下面两个命令来安装针对google和百度的插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在站点根目录下的_config.yml添加如下代码 123456# hexo sitemap网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 现在在执行hexo generate的时候，在博客根目录下的public文件夹下面，就会生成sitemap.xml和baidusitemap.xml。 获取github接口的调用权限 创建一个access token，点击链接进入 点击Generate new token按钮 输入一个描述，为token添加所有的repo权限，然后点击最下方的Generate token按钮，就可以生成一个新的Token备用 生成的token，在后面使用 脚本文件 安装依赖包 在你hexo的根目录，执行下面的命令 1234npm install request --savenpm install xml-parser --savenpm install yamljs --savenpm install cheerio --save 创建脚本文件 在站点根目录下创建comment.js文件，将下面的代码粘贴进文件中，然后修改config中的配置项，其中token就是上一步中获取的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const request = require("request");const fs = require("fs");const path = require("path");const url = require("url");const xmlParser = require("xml-parser");const YAML = require("yamljs");const cheerio = require("cheerio");// 根据自己的情况进行配置const config = &#123; username: "GitHub 用户名", // GitHub 用户名 token: "GitHub Token", // GitHub Token repo: "daihaoxin.github.io", // 存放 issues的git仓库 // sitemap.xml的路径，commit.js放置在根目录下，无需修改，其他情况自行处理 sitemapUrl: path.resolve(__dirname, "./public/sitemap.xml"), kind: "Gitalk", // "Gitalk" or "Gitment"&#125;;let issuesUrl = `https://api.github.com/repos/$&#123;config.username&#125;/$&#123;config.repo&#125;/issues?access_token=$&#123;config.token&#125;`;let requestGetOpt = &#123; url: `$&#123;issuesUrl&#125;&amp;page=1&amp;per_page=1000`, json: true, headers: &#123; "User-Agent": "github-user" &#125;&#125;;let requestPostOpt = &#123; ...requestGetOpt, url:issuesUrl, method: "POST", form: ""&#125;;console.log("开始初始化评论...");(async function() &#123; console.log("开始检索链接，请稍等..."); try &#123; let websiteConfig = YAML.parse(fs.readFileSync(path.resolve(__dirname, "./_config.yml"), "utf8")); let urls = sitemapXmlReader(config.sitemapUrl); console.log(`共检索到$&#123;urls.length&#125;个链接`); console.log("开始获取已经初始化的issues:"); let issues = await send(requestGetOpt); console.log(`已经存在$&#123;issues.length&#125;个issues`); let notInitIssueLinks = urls.filter((link) =&gt; &#123; return !issues.find((item) =&gt; &#123; link = removeProtocol(link); return item.body.includes(link); &#125;); &#125;); if (notInitIssueLinks.length &gt; 0) &#123; console.log(`本次有$&#123;notInitIssueLinks.length&#125;个链接需要初始化issue：`); console.log(notInitIssueLinks); console.log("开始提交初始化请求, 大约需要40秒..."); /** * 部署好网站后，直接执行start，新增文章并不会生成评论 * 经测试，最少需要等待40秒，才可以正确生成， 怀疑跟github的api有关系，没有找到实锤 */ setTimeout(async ()=&gt;&#123; let initRet = await notInitIssueLinks.map(async (item) =&gt; &#123; let html = await send(&#123; ...requestGetOpt, url: item &#125;); let title = cheerio.load(html)("title").text(); let pathLabel = url.parse(item).path; let body = `$&#123;item&#125;&lt;br&gt;&lt;br&gt;$&#123;websiteConfig.description&#125;`; let form = JSON.stringify(&#123; body, labels: [config.kind, pathLabel], title &#125;); return send(&#123; ...requestPostOpt, form &#125;); &#125;); console.log(`已完成$&#123;initRet.length&#125;个！`); console.log("可以愉快的发表评论了！"); &#125;,40000); &#125; else &#123; console.log("本次发布无新增页面，无需初始化issue!!"); &#125; &#125; catch (e) &#123; console.log(`初始化issue出错，错误如下：`); console.log(e); &#125; finally &#123; &#125;&#125;)();function sitemapXmlReader(file) &#123; let data = fs.readFileSync(file, "utf8"); let sitemap = xmlParser(data); return sitemap.root.children.map(function (url) &#123; let loc = url.children.filter(function (item) &#123; return item.name === "loc"; &#125;)[0]; return loc.content; &#125;);&#125;function removeProtocol(url) &#123; return url.substr(url.indexOf(":"));&#125;function send(options) &#123; return new Promise(function (resolve, reject) &#123; request(options, function (error, response, body) &#123; if (!error) &#123; resolve(body); &#125; else &#123; reject(error); &#125; &#125;); &#125;);&#125; 执行脚本 需要注意的是第一步中的sitemap插件会生成的sitemap.xml会包含全部的界面，包括标签页、关于页等，执行上面的代码也会对这些页面生成评论框(也就是issue) 完成上述操作后，执行下面的命令，就可以部署站点，并初始化所有的评论了。 1234hexo cleanhexo generatehexo deploynode ./comment.js 也可以通过在站点根目录的package.json文件中，新建npm脚本，一个命令搞定清除缓存、生成静态文件、提交git并生成issue的所有操作。 1234"scripts": &#123; "start": "hexo clean &amp;&amp; hexo s", "deploy": "hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy &amp;&amp; node ./comment.js"&#125; 完成文章编写，或者其他的更新操作后，直接执行deploy即可。 1npm run deploy 后记和一些坑计划半个小时搞定的，最后花了三四个小时，程序猿评估工作量的水平依然很稳定^_^。 在使用nodejs完成脚本的过程中，因为找不到在页面点击直接登录github完成的初始化规则，踩了不少坑。 第一版完成的时候，测试发现相同的地址，还是会生成issue，后来才发现github获取issues的接口是分页的，默认返回的30条。在官方文档可以找到分页的设置方式，每页的最大记录1000条，所以代码里指定了1000。博客文章数超过1000貌似要写很久很久，就没有做进一步的处理 在_config.yml站点网址的时候，使用了http协议，而登陆自动生成规则使用的是https协议，导致过滤手动初始化的判断一直有问题(一个s引发的血案)。通过去除链接里的协议，然后比较进行解决，兼容了http和https; Gitalk在页面登陆初始化的时候，默认生成的issue label是链接的path，最开始处理的是直接使用链接，与默认规则生成的在一起很不统一，就全部处理为path 代码完成后，测试发现并不是每次生成都会成功，也没有错误，测试调试尝试各种办法，花了一个多小时，发现部署完成后，最少需要等待40秒，才可以正确完成issue的初始化， 怀疑跟github的api有关系，没有找到实锤，知道原因或者有更好的解决方案可以在下面留言给我，谢谢 sitemap.xml没有使用网站部署后的，因为想在部署后，直接执行脚本进行初始化，而deploy命令执行后，通过网络获取sitemap.xml不是最新的，具体更新时间没有规律，所有选择了读取本地生成在public下的sitemap.xml获取最新的链接，确保初始化顺利完成。 参考Gitment/Gitalk自动初始化 自动初始化 Gitalk 和 Gitment 评论]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nodejs</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用webStorm中的宏解决eslint无法保存自动修复的问题]]></title>
    <url>%2Fpost%2Fa0b405ae.html</url>
    <content type="text"><![CDATA[ESLint是什么ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。详细学习建议直接去看官方文档，eslint的文档详细易懂，没有比看官方文档更好的学习方式了。 目标在保存文件的时候，对所有类型文档应用editorconfig配置，对js启用eslint并自动进行--fix修复 三种武器 webStorm作为前端IDE，自身带有代码格式化和检查的功能，webStorm格式化配置比较复杂很难统一，对JavaScript的语法检查比较弱； editorconfig的初衷就是提供缩进、编码和换行上的一致性，语法检查能力没有，优势是简单，能够提供夸语言跨编辑器的能力，webStorm完全支持 eslint是专门的JavaScript代码检查工具，并提供格式化代码的能力 PS：在三者重合的能力区域，优先级先后顺序为 editorconfig &gt; webStorm &gt; eslint 实践配置editorconfig在项目根目录下新建文件.editorconfig文件，并配置。代码清单112345678910111213141516171819# top-most EditorConfig fileroot = true# Unix-style newlines with a newline ending every file[*]end_of_line = lfinsert_final_newline = truecharset = utf-8indent_style = spaceindent_size = 4# 忽略指定目录, unset的作用是删除该属性的效果[&#123;/node_modules/**, /build/**, /dist/**, *-lock.json &#125;]charset = unsetend_of_line = unsetinsert_final_newline = unsettrim_trailing_whitespace = unsetindent_style = unsetindent_size = unset 安装并配置eslint规范采用腾讯alloy团队开源的[AlloyTeam ESLint 规则][AlloyTeam ESLint 规则]。 eslint全局安装： 代码清单2 1npm install --save-dev eslint babel-eslint eslint-config-alloy 创建.eslintrc.json配置文件，并复制一下代码： 代码清单3 12345678910111213141516171819202122&#123; &quot;extends&quot;: [ &quot;eslint-config-alloy&quot; ], &quot;globals&quot;: &#123; // 这里填入你的项目需要的全局变量 // 这里值为 false 表示这个全局变量不允许被重新赋值，比如： // // jQuery: false, // $: false &#125;, &quot;rules&quot;: &#123; &quot;quotes&quot;: [ &quot;error&quot;, &quot;double&quot;, &#123; &quot;avoidEscape&quot;: true, &quot;allowTemplateLiterals&quot;: true &#125; ] &#125;&#125; 启用eslint 打开配置窗口，找到Languages &amp; Frameworks -&gt; JavaScript -&gt; Code Quality Tools -&gt; ESLint，勾选最上面的Enable，如下图 配置webStormSave Actions自动格式化代码Save Actions是webstorm的一个插件，主要用途就在编辑文件后保存的时候，进行格式化，这样我们就不用手动去操作了。打开setting -&gt; plugins搜索Save Actions，安装重启，搞定。 这里实现了项目的全部文件遵循editorconfig的配置。 webstorm导入eslint的配置eslint的虽然强大，但是格式化代码的规则缺被editorconfig和webStorm压的死死的 ，好在webstorm提供了导入eslint配置的操作，通过该操作可以让ide和webstorm保持一致，现在即使有冲突，也只有eslint和editorconfig发生有冲突，解决起来也简单。 导入操作很简单，只要在项目的.eslint.*文件上右键，选择Apply ESLint Code Style Rules就OK了。 这里实现了js文件遵守eslint的检测规则，下一步根据eslint规则自动检测修复javascript文件。 配置宏，实现eslint自动修复苦逼心路 eslint保存并修复这样的功能，vscode一个配置就搞定，webstorm这点有点蛋疼 早在两年前就有人向官方提过关于Allow to run ESLint fix on save的ISSUE，最近也有人在反馈，看来挺多人关注这个功能，具体详情看这里，官方的回复了一个原因两个建议： We believe that the save action and the actions that modify the code you’re working with should be separated. 我们认为保存操作和修改您正在使用的代码的操作是应该分开的。 意思是目前没有这个功能，建议使用file watcher(文件监视器)或者前面提到的第三方插件Save Actions，下面看下这两个方案的槽点。 Save Actions完全没有运行额外命令的能力，无法达到目的 file watcher方案老外同行实践的经历1和经历2，file watcher好是好，可是用在这里就比较烦人了，因为文件监视器发现文件发生了改变，就会执行eslint --fix进行修复，修复完成后写入到当前文件，这就触发了触发了文件缓存冲突，webstorm会不时的蹦出File Cache Conflict的小弹窗，验证影响coding的体验有木有。 终极大招——宏 IDE里宏最善于的就是合并重复的连续操作 打开设置 -&gt; Keymap 搜索 Fix ESLint Problems，双击配置快捷键，这里使用的是Ctrl + Shift + ;没有冲突； 菜单 -&gt; Edit -&gt; Macros -&gt; Start Macros Recording开始录制宏，这是右下角会有如图所示的状体； 按下步骤1设置的快捷键Ctrl + Shift + ;，然后按下Ctrl + S，然后点击右下角红色按钮结束录制，输入你想要保存的名字，这里保存为eslint fix and save； 为步骤三录制的宏添加快捷键，打开设置 -&gt; Keymap 搜索 eslint fix and save，双击配置快捷键，如果提示快捷键已存在，直接移除搞定，这里设置的额快捷键是Ctrl + S。 OK，搞定了，快快体验一把！！ 总结为什么折腾会让人兴奋？？？？]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用笔记]]></title>
    <url>%2Fpost%2Fd6ed9cc7.html</url>
    <content type="text"><![CDATA[配置markdown引擎例外目录现在有这样一个需求，这里的所有文件包括html、css、js、md等等任何一种文件。我需要的仅仅是希望hexo在generator的时候简单的将这个目录copy到public目录中而不做任何处理。 打开网站目录下的_config.yml，修改skip_render的配置:1skip_render: ['*.html', demo/**, test/*] 修改Hexo默认文件名称hexo默认以标题做为文件名称，可以通过修改站点下的_config.yml中的new_post_name属性来重置规则，比如可以设置为:year-:month-:day-:title.md ， 这样就会在文章标题前面添加年月日，这样可以更方便的通过日期来管理文章。 文章部分的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# 自动将页面滚动到&lt;!-- more --&gt;标记下的地方。scroll_to_more: false# Automatically saving scroll position on each post/page in cookies.# 自动保存每篇文章或页面上一次滚动的地方。save_scroll: false# Automatically excerpt description in homepage as preamble text.# 自动在首页对文章进行摘要描述作为前言文本。excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.# 不推荐使用自动摘要。# 请在文章中使用&lt;!-- more --&gt;标志来精确控制摘要长度。auto_excerpt: enable: true length: 200# Post meta display settings# 文章元数据展示设置post_meta: # 文本显示 item_text: true # 创建时间 created_at: true # 更新时间 # 这个更新时间有点问题，因为每次重新生成文章/部署时都会刷新更新时间，不建议使用 updated_at: false # 目录分类 categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcount# 文章字数展示设置post_wordcount: # 文本显示 item_text: true # 文章字数统计 wordcount: true # 阅读时长 min2read: true # 站点总字数统计 totalcount: true # 该post_wordcount的所有设置另起一行显示 separated_meta: true]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中的dangerouslySetHTML]]></title>
    <url>%2Fpost%2Fd457867e.html</url>
    <content type="text"><![CDATA[出于安全考虑的原因（XSS 攻击），在 React.js 当中所有的表达式插入的内容都会被自动转义，就相当于 jQuery 里面的 text(…) 函数一样，任何的 HTML 格式都会被转义掉： 12345678910111213141516class Editor extends Component &#123; constructor() &#123; super() this.state = &#123; content: '&lt;h1&gt;组件的dangerouslySetHTML属性&lt;/h1&gt;' &#125; &#125; render () &#123; return ( &lt;div className='editor-wrapper'&gt; &#123;this.state.content&#125; &lt;/div&gt; ) &#125;&#125; 假设上面是一个富文本编辑器组件，富文本编辑器的内容是动态的 HTML 内容，用 this.state.content 来保存。我希望在编辑器内部显示这个动态 HTML 结构，但是因为 React.js 的转义特性，页面上会将待遇作为文字原样显示。 表达式插入并不会把一个 渲染到页面，而是把它的文本形式渲染了。那要怎么才能做到设置动态 HTML 结构的效果呢？React.js 提供了一个属性 dangerouslySetInnerHTML，可以让我们设置动态设置元素的 innerHTML： 12345678910111213141516class Editor extends Component &#123; constructor() &#123; super() this.state = &#123; content: '&lt;h1&gt;组件的dangerouslySetHTML属性&lt;/h1&gt;' &#125; &#125; render () &#123; return ( &lt;div className='editor-wrapper' dangerouslySetInnerHTML=&#123;&#123;__html: this.state.content&#125;&#125; /&gt; ) &#125;&#125; 需要给 dangerouslySetInnerHTML 传入一个对象，这个对象的 __html 属性值就相当于元素的 innerHTML，这样我们就可以动态渲染元素的 innerHTML 结构了。 有写朋友会觉得很奇怪，为什么要把一件这么简单的事情搞得这么复杂，名字又长，还要传入一个奇怪的对象。那是因为设置 innerHTML 可能会导致跨站脚本攻击（XSS），所以 React.js 团队认为把事情搞复杂可以防止（警示）大家滥用这个属性。这个属性不必要的情况就不要使用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于React v16.3 新生命周期]]></title>
    <url>%2Fpost%2F205e832b.html</url>
    <content type="text"><![CDATA[React v16.3 版本新生命周期函数浅析及升级方案关于React v16.3 新生命周期React v15到v16.3, v16.4新生命周期总结以及使用场景React Fiber 架构学习React 的新引擎—React Fiber 是什么？深入理解React16之：（一）.Fiber架构]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5新特性之history]]></title>
    <url>%2Fpost%2F532e734.html</url>
    <content type="text"><![CDATA[historyhistory对象是用来记录浏览器访问历史的，可以将其理解为保存了一个有序列表的对象，每个对象都代表了一个页面信息（包括url、title等）。同时history也提供了back()、forward()、go()等方法来实现页面的切换，等同于浏览器本的前进/后退按钮的操作。 history中记录了浏览器窗口访问过的url，但是出于安全考虑，浏览器禁止通过程序获取 history 中的具体信息，只能通过length属性来获取 history 中的记录数，通过back()、forward()、go()方法进行页面切换。 html5的新特性html5为 history 引入了 pushState 和 replaceState 两个方法，这两个方法用来更新 history 对象中的列表信息。 此外还提供了一个事件window.onpopstate，通过浏览器动作修改 history 对象信息会触发该事件，比如用户点击前进/后退按钮。pushState 和 replaceState 两个方法不会触发window.onpopstate事件。 pushStatepushState方法有三个参数： 第一个参数是个对象，可以在onpopstate事件中通过event.state获取到，也可以在页面中通过history.state获取到。 第二个参数是个字符串，用来设置页面的 title。 第三个参数是个字符串，就是保存到 history 中的 url 。 下面是一个完整的html文件，文件名为demo.html。 把该文件放到web服务器上，从浏览器访问。123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;测试&lt;/title&gt; &lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick="doPushState()"&gt;pushState&lt;/button&gt; &lt;button onclick="count()"&gt;count&lt;/button&gt; &lt;script&gt; var index = 1; console.log(history.state); window.onpopstate = function () &#123; console.log(event.state); &#125;; function doPushState() &#123; history.pushState(&#123; a: "123123" &#125;, "newtitle", "test" + (index++) + ".html"); // if (index === 2) &#123; console.log(history.state); // &#125; &#125; function count() &#123; alert(window.history.length); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面首先会执行 $()方法，弹出代码中的location.href信息。 这时执行count按钮，显示为1，注意如果在ie或chrome的新的浏览器窗口打开，值可能为2，因为它们的窗口会加载系统默认的一个页面，不是一个空白的窗口。这时我们每点击一下pushState按钮，发现浏览器的地址会发生变化，先后变为test1.html , test2.html, test3.html, …….，并且通过点击count按钮发现，弹出的值加1. 这说明每调用一次pushState方法，history中就会新增加一条url记录。 但是，pushState 与普通的打开一个新页面不同。浏览器不会在调用pushState()方法后加载这个url，也就是说即使你写一个错误的url，也不会报错。pushState只是将一个记录添加进了 history 列表，并不去加载。 replaceStatereplaceState 方法和 pushState 方法有相同的三个参数，区别在于 replaceState 是用来修改 history 对象中记录的当前页信息，而不是新建。 onpopstatewindow对象的popstate事件，当进行页面的前进或回退时，会触发该事件，并且在事件响应函数中通过 history.state 或者 event.state 可以获取到 pushState方法和replaceState方法中第一个参数指定的对象。 应用现代新的前端框架都提供了基于 history 新特性的客户端路由。 在传统的 ajax 项目中，可以实现不需要刷新整个页面就可以进行局部页面的更新，但是无法通过前进/后退按钮回到操作前的页面，通过 history 新特性可以解决这个问题。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4配置小结]]></title>
    <url>%2Fpost%2Fd71eee63.html</url>
    <content type="text"><![CDATA[默认模式webpack4 引入了零配置的概念，通过配置不同mode，来提供默认设置，我们来看看 webpack 默认帮我们做了些什么?development 模式下，默认开启了NamedChunksPlugin 和NamedModulesPlugin方便调试，提供了更完整的错误信息，更快的重新编译的速度。123456789module.exports = &#123;+ mode: 'development'- devtool: 'eval',- plugins: [- new webpack.NamedModulesPlugin(),- new webpack.NamedChunksPlugin(),- new webpack.DefinePlugin(&#123; "process.env.NODE_ENV": JSON.stringify("development") &#125;),- ]&#125; production 模式下，由于提供了splitChunks和minimize，所以基本零配置，代码就会自动分割、压缩、优化，同时 webpack 也会自动帮你 Scope hoisting 和 Tree-shaking。 123456789module.exports = &#123;+ mode: 'production',- plugins: [- new UglifyJsPlugin(/* ... */),- new webpack.DefinePlugin(&#123; "process.env.NODE_ENV": JSON.stringify("production") &#125;),- new webpack.optimize.ModuleConcatenationPlugin(),- new webpack.NoEmitOnErrorsPlugin()- ]&#125; mini-css-extract-pluginwebpack4对 css 模块支持的完善以及在处理 css 文件提取的方式上也做了些调整，之前使用的extract-text-webpack-plugin将有mini-css-extract-plugin来代替，使用方式很简单，直接看文档就可以了。 有个特别需要注意的地方是mini-css-extract-plugin的默认文档配置，将文件名生成规则设置为了hash123456new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: devMode ? "[name].css" : "[name].[hash].css", chunkFilename: devMode ? "[id].css" : "[id].[hash].css"&#125;); 这里是不对的，hash值每次打包都不一样，这里将设置的hash会使长效缓存失效，参考webpack中hash/chunkhash/contenthash的区别，应该将hash改为contenthash mini-css-extract-plugin与extract-text-webpack-plugin最大的区别是：它在code spliting的时候会将原先内联写在每一个 js chunk bundle的 css，单独拆成了一个个 css 文件。 将 css 独立拆包最大的好处就是 js 和 css 的改动，不会影响对方。比如我改了 js 文件并不会导致 css 文件的缓存失效。而且现在它自动会配合optimization.splitChunks的配置，可以自定义拆分 css 文件，比如我单独配置了ant-design作为单独一个bundle,它会自动也将它的样式单独打包成一个 css 文件，不会像以前默认将第三方的 css 全部打包成一个几十甚至上百 KB 的app.xxx.css文件了。 压缩与优化webpack4中css的压缩需要使用 optimize-css-assets-webpack-plugin 这个插件，它不仅能帮你压缩 css 还能优化你的代码。12345678// 配置很简单optimization: &#123; minimizer: [ optimization: &#123; minimizer: [new OptimizeCSSAssetsPlugin()]; &#125; ]&#125; 看资料说optimize-css-assets-webpack-plugin这个插件默认使用了 cssnano 来作 css 优化，启用css module后就一直报错，cssnano网站一直打不开，后来参考了create-react-app的配置，添加了cssProcessorOptions配置项，将parse设置为postcss-safe-parser（需要npm安装）才ok。 12345new OptimizeCSSAssetsPlugin(&#123; cssProcessorOptions: &#123; parser: require("postcss-safe-parser"), &#125;&#125;) UglifyJsPlugin在mode为production的时候，默认开启了UglifyJsPlugin，但是一旦配置了optimization.minimizer，就需要手动去配置UglifyJsPlugin，如果你打包之后JavaScript没有被压缩，可以注意下这里，网上配置资料很多就不多说了。 打包速度这里有一篇介绍打包优化速度的文章保持 webpack 快速运行的诀窍：一本提高构建性能的现场指导手册 个人看法是，如果开发环境打包速度太慢，可以将第三方库通过dllPlugin进行预打包引入，基本这样之后基本可以节省几秒到十几秒。 如果是生产环境打包的话，三五分钟都是可以接受的，只要不是太变态的十几二十分钟，优化够用就行了]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]normalize.css介绍]]></title>
    <url>%2Fpost%2F67aef17c.html</url>
    <content type="text"><![CDATA[更新normalize.css 8.x之后的版本已经不支持ie8/9，如需支持，请选择7.0 原文地址 介绍官网上这么说的，我们创造normalize.css有下面这几个目的： 保护有用的浏览器样式而不是去掉他们。 一般化的样式：为大部分HTML元素提供。 修复浏览器自身的bug并保证各浏览器的一致性。 优化css可用性：用一些小技巧。 解释代码：用注释和详细的文档来。 Normalize支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表哥都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。 Normalize vs Reset Normalize.css 保护了有价值的默认值Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多磨人的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css会力求让这些样式保持一致并尽可能与现代标准符合。 Normalize.css 修复了浏览器的bug它修复了常见的桌面端与移动端浏览器的bug。这往往超出了Reset所能做到的范围。关于这一点，Normalize.css修复的问题包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。 Normalize.css 不会让你的调试工具变的杂乱使用Reset最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链，在Normalize.css中就不会有这样的问题，因为在我们的准则中对多选择器的使用是非常谨慎的，我们仅会有目的地对目标元素设置样式。 Normalize.css 是模块化的这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到的部分（比如表单的一般化）。 Normalize.css 拥有详细的文档Normalize.css的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在Github Wiki中有进一步的说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易的进行自己的测试。]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中scss全局变量的支持]]></title>
    <url>%2Fpost%2Fd282d429.html</url>
    <content type="text"><![CDATA[sass-resources-loader配置的全局文件会在每个scss文件中自动注入。 安装依赖12// 这个插件可以实现全局scss变量，或者说全局的scss文件npm install sass-resources-loader --save-dev 配置12345678910111213141516171819202122&#123; test: /\.scss$/, use: [ "style-loader", // 简洁方式 // 'css-loader?modules&amp;localIdentName=[local]-[hash:base64:10]', &#123; loader: "css-loader", options: &#123; module: true, localIdentName: "[local]-[hash:base64:10]" &#125; &#125;, "sass-loader", &#123; loader: "sass-resources-loader", options: &#123; resources: path.resolve(__dirname, "../src/assets/styles-variable.scss") &#125; &#125; ]&#125; sass-resources-loader的配置里resources对应的就是提供全局变量的scss文件。 最后使用create-react-app脚手架的同学，弹出配置后，搜索下sass-loader很快就可以解决了，感谢阅读！！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>webpack</tag>
        <tag>react</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Webpack中的sourcemap]]></title>
    <url>%2Fpost%2Fe2ad191f.html</url>
    <content type="text"><![CDATA[原文地址 Webpack中sourcemap的配置sourcemap是为了解决开发代码与实际运行代码不一致时帮助我们debug到原始开发代码的技术。尤其是如今前端开发中大部分的代码都经过编译，打包等工程化转换。比如开发环境下用scss写样式， 想在浏览器中在线编辑css那样编辑scss就不是那么容易了。从我自己看过的资料中， sourcemap的概念最早出现在12年， jquer1.9是较早支持sourcemap的库。这篇博客比较有代表性：Introduction to JavaScript Source Maps，阮一峰的文章JavaScript Source Map 详解也大量参考该博客。关于sourcemap的原理及作用，基本在这两篇文章中讲清楚了。回到webpack中的sourcemap，就我这几天的琢磨， 这方面资料相对比较零散，但凡搜索Webpack中sourcemap的配置， 总是能得到千篇一律的如下信息： Sourcemap type Quality Notes source-map： 原始代码 最好的sourcemap质量有完整的结果，但是会很慢eval： 生成代码 每个模块都被eval执行，并且存在@sourceURLeval-source-map： 原始代码 同样道理，但是最高的质量和最低的性能cheap-eval-source-map： 转换代码（行内） 每个模块被eval执行，并且sourcemap作为eval的一个dataurlcheap-module-eval-source-map： 原始代码（只有行内） 同样道理，但是更高的质量和更低的性能cheap-source-map： 转换代码（行内） 生成的sourcemap没有列映射，从loaders生成的sourcemap没有被使用cheap-module-source-map： 原始代码（只有行内） 与上面一样除了每行特点的从loader中进行映射 webpack官方文档的配置在这里 疑问反正我看完这些说明是云里雾里， 就我自己而言， 有3个疑问： eval和sourcemap有什么关系，eval模式是sourcemap吗？ 包含cheap关键字的配置中只有行内是什么意思？ 这几种不同的配置有什么区别？ 解答看似配置项很多， 其实只是五个关键字eval，source-map，cheap，module，inline的任意组合。这五个关键字每一项都代表一个特性， 这四种特性可以任意组合。它们分别代表以下五种特性（单独看特性说明有点不明所以，别急，往下看） eval：每个模块都使用 eval() 执行，并且都有 //@ sourceURL。此选项会非常快地构建。主要缺点是，由于会映射到转换后的代码，而不是映射到原始代码（没有从 loader 中获取 source map），所以不能正确的显示行数。 source-map：整个 source map 作为一个单独的文件生成。它为 bundle 添加了一个引用注释，以便开发工具知道在哪里可以找到它。 cheap：不包含列信息（关于列信息的解释下面会有详细介绍)也不包含loader的sourcemap module：包含loader的sourcemap（比如jsx to js ，babel的sourcemap） inline：将.map作为DataURI嵌入，不单独生成.map文件（这个配置项比较少见） 了解了以上各种不同特性， 再来逐一解答以上问题。 eval和sourcemap有什么关系，eval模式是sourcemap吗？eval和source-map都是webpack中devtool的配置选项。 eval模式是使用eval将webpack中每个模块包裹，然后在模块末尾添加模块来源//# souceURL， 依靠souceURL找到原始代码的位置。包含eval关键字的配置项并不单独产生.map文件（eval模式有点特殊， 它和其他模式不一样的地方是它依靠sourceURL来定位原始代码， 而其他所有选项都使用.map文件的方式来定位）。 包含source-map关键字的配置项都会产生一个.map文件，该文件保存有原始代码与运行代码的映射关系， 浏览器可以通过它找到原始代码的位置。（注：包含inline关键字的配置项也会产生.map文件，但是这个map文件是经过base64编码作为DataURI嵌入）。 举个栗子：eval-source-map是eval和source-map的组合，可知使用eavl语句包括模块，也产生了.map文件。webpack将.map文件作为DataURI替换eval模式中末尾的//# souceURL。按照我自己的理解， eval和.map文件都是sourcemap实现的不同方式，虽然大部分sourcemap的实现是通过产生.map文件， 但并不表示只能通过.map文件实现。下面是eval模式后产生的模块代码： 包含cheap关键字的配置中只有行内是什么意思？这里的列信息指的是代码的不包含原始代码的列信息。 官方文档对于包含cheap的解释是这样的： cheap-source-map - A SourceMap without column-mappings. SourceMaps from loaders are not used. 这句话翻译过来就是“在cheap-source-map模式下sourcemap不包含列信息，也不包含loaders的sourcemap”，这里的“column-mappings”就是代码列数的意思，是否包含loaders的sourcemap有什么区别将在之后提到。debug的时候大部分人都只在意代码的行数， 很少关注列数， 列数就是该行代码从第一个字符开始到定位字符的位置（包括空白字符）包含cheap关键字的模式不包含列信息，体现在webpack中就是：如果包含cheap关键字，则产生的.map文件不包含列信息。也就是说当你在浏览器中点击该代码的位置时， 光标只定位到行数，不定位到具体字符位置。而不包含cheap关键字时， 点击控制台log将会定位到字符位置。 包含列信息后点击原始代码的定位，注意光标位置：不包含列信息的光标位置： 这篇博客：Go to a line number at a specific column直观地展示了列数的概念。如果深入到webpack中的细节中体会该配置项，可以看这篇博客：SurviveJS：Source Maps ，该文章对比了webpack中所有配置项中.map文件的代码，这里截取eval-source-map和cheap-source-map的模式产生的.map文件代码中的mappings字段对比： 12345// devtool: 'eval-source-map'"mappings": "AAAAA,QAAQC,GAAR,CAAY,aAAZ",//devtool: 'cheap-source-map'"mappings": "AAAA", 注：这里使用了VLQ编码，（关于VLQ编码还可参考这里：前端构建：Source Maps详解） 在VLQ编码中，逗号,表示字符列分割，分号;表示行分割。包含cheap关键字的配置项不包含列信息，也就没有逗号。关于VLQ编码， 本文最初的阮一峰的文章中有所解释。而不包含loader的sourcemap指的是不包含loader的sourcemap，不包含它时候如果你使用了诸如babel等代码编译工具时， 定位到的原始代码将是经过编译后的代码位置，而非原始代码。 比如当我用babel编译JS的时候，如果包含不包含loaders的sourcemap，此时debug到的将是编译后的代码， 而非原始代码，如图（这是使用cheap-source-map模式未包含loaders的sourcemap情况下的截图， debug的位置与之前的对比截图是同一个地方）： 这几种不同的配置有什么区别？通过以上两个问题的解释， webpack中的sourcemap各个配置项异同应该有了一定认识，乍看之下各个配置项很难记忆， 但其实从每个关键字所代表的特性入手， 就能体会到他们的异同。他们在webpack中的主要区别一个体现在重构的性能上， 总的来说eval性能最好，source-map性能最低，但就我自身的实践来看大多用的是最完整的source-map，该模式对于不管是js还是css，scss等都能很好的覆盖， 相反其他模式都不完整， 在开发环境下重构性能似乎比不上功能的完善。 另外需要补充的是module关键字， 当加上module关键字webpack将会添加loader的sourcemap。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用babel-plugin-react-css-modules简化React中CSS模块的使用]]></title>
    <url>%2Fpost%2Fbb9071c9.html</url>
    <content type="text"><![CDATA[前言CSS 是前端领域中进化最慢的一块。在 React 中使用 css 是一件很痛苦的事情。从 从原生 css 到 css modules 到 CSS in JS。各种解决方案层出不穷。总结起来主要有两类: 彻底抛弃 CSS，使用 JS 或 JSON 来写样式，如时下的新宠 styled-components （github上两万多star），还有 styled-jsx，react-style等属于CSS in JS这一类。优点是能给 CSS 提供 JS 同样强大的模块化能力。 依旧使用 CSS，但使用 JS 来管理样式依赖，代表是 CSS Modules。CSS Modules 能最大化地结合现有 CSS 生态(预处理器/后处理器等)和 JS 模块化能力，几乎零学习成本。只要你使用 Webpack，可以在任何项目中使用。是目前最好的 CSS 模块化解决方案。这篇文章要介绍的babel-plugin-react-css-modules就是一个CSS模块化的轻量级解决方案。 为什么要有CSS Modules请看这里 CSS Modules 模块化方案CSS Modules 并不是React专用解决方法，适用于所有使用 webpack 等打包工具的开发环境。以 webpack 为例，在 css-loader 的 options 里打开modules：true 选项即可使用 Css Modules。一般配置如下12345678&#123; loader: "css-loader", options: &#123; importLoaders: 1, modules: true, localIdentName: "[local]___[hash:base64:5]" // 为了生成类名不是纯随机 &#125;,&#125; 使用方式 12345678910111213141516import React from 'react';import styles from './table.css'; export default class Table extends React.Component &#123; render () &#123; return &lt;div className=&#123;styles.table&#125;&gt; &lt;div className=&#123;styles.row&#125;&gt; &lt;/div&gt; &lt;/div&gt;; &#125;&#125;// 渲染结果：&lt;div class="table__table___32osj"&gt; &lt;div class="table__row___2w27N"&gt; &lt;/div&gt;&lt;/div&gt; 像这样，每次都要用style.xxx这种方式来写，如果有多个class还需通过字符串模板拼接，还可一使用classnames动态控制样式的显示。1234567npm install classnamesimport styles from './styles.css'import classNames from 'classnames'&lt;div className=&#123; styles.theTitle &#125;&gt;something&lt;/div&gt;&lt;div className=&#123; classNames(styles.theTitle, styles.title) &#125;&gt;something&lt;/div&gt; 能不能更简单？？？ 终于到babel-plugin-react-css-modules出场了。 babel-plugin-react-css-modules先来个对比，className换成styleName就ok了，其他跟使用className一样，有没有很简单123456789// css-modulesimport styles from './styles.css'&lt;div className=&#123; styles.theTitle &#125;&gt;something&lt;/div&gt;// babel-plugin-react-css-modulesimport './styles.css'&lt;div styleName="the-title"&gt;something&lt;/div&gt; 官方链接最早是react-css-modules这个插件，作者后来又开发了这个使用起来更为方便的新插件。配置起来也很简单。 安装依赖需要注意的是，babel-plugin-react-css-modules有一个运行时依赖，所以用–save安装比较好1npm i --save babel-plugin-react-css-modules 配置配置主要注意一下两点： 配置项中的generateScopedName的作用和css-loader中的localIdentName是一样的，都是设置编译之后的类名的格式。generateScopedName和localIdentName必须要配置，并且值必须相同。否则即使编译成功，不报错，也还是无法达到预期效果。 context要和webpack中context的配置一直，默认是项目根目录 12345678[ 'babel-plugin-react-css-modules', &#123; context: path.join(__dirname, '.'), exclude: 'node_modules', generateScopedName: generateScopedName &#125;] 然后就可以愉快的使用了 支持SCSS安装依赖12345678// 该插件让‘babel-plugin-react-css-modules’支持‘scss’npm install postcss-scss --save-dev// sass和scss的依赖库npm install node-sass --save-dev// sass-loader就不需要说明了吧npm install sass-loader --save-dev 配置sass-loader的配置很简单，就不说了，重点看下babel-plugin-react-css-modules的配置 12345678910["babel-plugin-react-css-modules", &#123; context: path.join(__dirname, '.'), exclude: "node_modules", filetypes: &#123; ".scss": &#123; "syntax": "postcss-scss" &#125; &#125;, generateScopedName: generateScopedName&#125;], filetypes这里是让这个插件支持scss。这里其实还可以添加插件，具体可以在官方文件中查看。 需要特别注意：所有从.js中引用.scss的代码，都不可以依赖webpack的resolve.modules配置，只能写相对路径了。即原来写import &#39;common/scss/global.scss&#39;要改成import &#39;./common/scss/global.scss&#39; 补充styleName出场了，className干嘛?? 依然可以通过className使用全局样式，babel-plugin-react-css-modules会自动合并styleName和className。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>webpack</tag>
        <tag>react</tag>
        <tag>babel</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React16的兼容及解决]]></title>
    <url>%2Fpost%2Fda9c835d.html</url>
    <content type="text"><![CDATA[React16的环境要求官方文档明确指出因为React16依赖集合类型Set和Map，如果需要支持IE11以下的浏览器需要使用全局的polyfill，解决方案也很简单。1npm install -S @babel/polyfill 在代码入口处引入map和set12345678910import 'core-js/es6/map';import 'core-js/es6/set';import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); React 也依赖于 requestAnimationFrame，你可以使用raf 包。1npm install -S raf 导入入口文件1import "raf/polyfill"; IE9和10静态方法继承的问题这个问题跟React无关，其实是babel的问题，在小于IE11的版本里，在做类的继承时，静态属性和方法是继承不到的，查看babel的文档可以找到解决方案 If you’re inheriting from a class then static properties are inherited from it via proto, this is widely supported but you may run into problems with much older browsers. NOTE: proto is not supported on IE &lt;= 10 so static properties will not be inherited. See the protoToAssign for a possible work around. 大概意思就是，正常的浏览器是没有问题的，在IE &lt;= 10的时候，因为不支持proto，所以不会继承静态属性。可以通过@babel/plugin-transform-proto-to-assign来解决。 1234// .babelrc&#123; "plugins": ["@babel/plugin-transform-proto-to-assign"]&#125; react-loadableIE10及以下都没有原生实现promise，react-loadable也没有内置替换方法，所以需要手动引入promise，在入口文件添加一下代码导入promise的polyfill 12// react-loadable 用到promiseimport "core-js/es6/promise";]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>react</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4中的react和redux的热更新]]></title>
    <url>%2Fpost%2Fda0f9ed2.html</url>
    <content type="text"><![CDATA[在之前一篇webpack4的热更新的最后留下了一点思考，传统的前端开发方式套上webpack去实现热更新是很麻烦的，因为html和JavaScript是分离的，创建和销毁JavaScript无法完全控制。在现在前端的开发方式中，html的所有元素都是由JavaScript控制的，那么是否可以很容易的实现热更新呢？？ 2018-12-20更新 react-hot-loader最新更新到了4.6.x，提供了一种新的API，官方介绍说可以提供更好的错误管理， 1234// App.jsimport &#123; hot &#125; from 'react-hot-loader/root'const App = () =&gt; &lt;div&gt;Hello World!&lt;/div&gt;export default hot(App) 需要特别注意的是，因为这种方式需要使用Object.assign，如果需要兼容IE11以下的浏览器，需要提供polyfill，如可以安装core-js添加import &quot;core-js/fn/object/assign 可以对比下4.6.x之前的写法123import &#123; hot &#125; from 'react-hot-loader'const App = () =&gt; &lt;div&gt;Hello World!&lt;/div&gt;export default hot(module)(App) 准备先来准备两个文件，React入口文件index.js和组件App.jsindex.js代码12345678910import React from "react";import ReactDOM from "react-dom";import App from "./App";import "./public/style.css";const wrapper = document.getElementById("root");ReactDOM.render( &lt;App /&gt;, wrapper); App.js代码，App中的Button组件非关键代码就不贴了12345678910111213141516171819202122import React from "react";import &#123; Button &#125; from "./components/button";import "./public/style.css";let App = (props) =&gt; &#123; return ( &lt;&gt; &lt;Button onClick=&#123;() =&gt; &#123; console.log(Button.c); console.log("test arrow function"); &#125;&#125; value="click me , don't answer you" /&gt; &lt;p&gt;看我实现热更新&lt;/p&gt; &lt;/&gt; );&#125;;export default App; 添加热更新代码首先按照webpack4的热更新中的步骤完成webpack.config.js的配置。然后修改上一节中的入口文件为：1234567891011121314151617181920212223import React from "react";import ReactDOM from "react-dom";import App from "./App";import "./public/style.css";const wrapper = document.getElementById("root");ReactDOM.render( &lt;App /&gt;, wrapper);// 增加热更新代码if (module.hot) &#123; module.hot.accept("./App", () =&gt; &#123; const App = require("./App").default; ReactDOM.render( &lt;App /&gt;, wrapper ); &#125;);&#125; 尝试更新App.js及其任意组件，体验下舒爽的热更新 使用react-hot-loader额，为什么还有react-hot-loader这么个东西，热更新不都已经实现了么，是的，可是并不完美，打开浏览器的控制台Elements标签，然后去更新App.js里面的p标签，你会发现button也跟着更新了，我没有更新button啊。。。。 当然如果页面足够简单也就无所谓了，可是如果组件很多，嵌套很深就不美好了，这个时候就要react-hot-loader登场了，使用很简单，跟着走就行了。 首先把index.js和App.js还原为文章最开始的样子 安装react-hot-loader@4.x 1npm install react-hot-loader 添加react-hot-loader/babel到你的.babelrc 1234// .babelrc&#123; "plugins": ["react-hot-loader/babel"]&#125; 修改App.js 123456789101112131415161718192021222324252627import React from "react";// 引入loaderimport &#123; hot &#125; from "react-hot-loader";import &#123; Button &#125; from "./components/button";import "./public/style.css";let App = (props) =&gt; &#123; return ( &lt;&gt; &lt;Button onClick=&#123;() =&gt; &#123; console.log(Button.c); console.log("test arrow function"); &#125;&#125; value="click me , don't answer you" /&gt; &lt;p&gt;看我实现热更新&lt;/p&gt; &lt;/&gt; );&#125;;// 增加热更新if (module.hot) &#123; App = hot(module)(App);&#125;export default App; 尝试更新App.js及其任意组件，体验下舒爽的热更新, 再也不用担心性能了 Redux热更新通过store.replaceReducer可以实现对redux的热替，直接上代码1234567891011121314151617import &#123; createStore &#125; from "redux";import reducer from "./reducer";// const store = createStore(reducer);export const configureStore = () =&gt; &#123; const store = createStore(reducer); if (module.hot) &#123; // Enable Webpack hot module replacement for reducers module.hot.accept("./reducer", () =&gt; &#123; const nextRootReducer = require("./reducer").default; store.replaceReducer(nextRootReducer); &#125;); &#125; return store;&#125;; 需要注意的是createStore不要放在App.js中，避免React组件的更新影响到store，放到index.js中就可以了123456789101112import React from "react";import ReactDOM from "react-dom";import App from "./App";import &#123; configureStore &#125; from "./redux/store";const store = configureStore();const wrapper = document.getElementById("root");ReactDOM.render( &lt;App store=&#123;store&#125;/&gt;, wrapper); 更新App.js12345678910111213141516171819202122232425262728import React from "react";// 引入loaderimport &#123; hot &#125; from "react-hot-loader";import &#123; Button &#125; from "./components/button";import "./public/style.css";// 引入Providerimport &#123; Provider &#125; from "react-redux";let App = (props) =&gt; &#123; return ( &lt;Provider store=&#123;props.store&#125;&gt; &lt;Button onClick=&#123;() =&gt; &#123; console.log(Button.c); console.log("test arrow function"); &#125;&#125; value="click me , don't answer you" /&gt; &lt;p&gt;看我实现热更新&lt;/p&gt; &lt;/Provider&gt; );&#125;;// 增加热更新if (module.hot) &#123; App = hot(module)(App);&#125;export default App; 修改 reducer 也可以实现热更新了 总结终于可以愉快的玩耍了！！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Warning: React version not specified in eslint-plugin-react settings]]></title>
    <url>%2Fpost%2F51247a7b.html</url>
    <content type="text"><![CDATA[问题及吐槽今天使用webpack4 + babel7搭建 React 运行环境启动测试的时候，发现eslint-plugin-react出现了一个警告，在之前版本的搭建过程中，并没有发现这个警告，虽然不会影响运行，但怎么也得看看到底怎么回事。 环境及版本：12345"eslint": "^5.12.0","eslint-config-alloy": "^1.4.2","eslint-loader": "^2.1.1","eslint-plugin-html": "^5.0.0","eslint-plugin-react": "^7.12.3", 下面进入正题，警告内容是这样的： Warning: React version not specified in eslint-plugin-react settings. See https://github.com/yannickcr/eslint-plugin-react#configuration 它说在eslint-plugin-react的插件配置的settings中没有指定具体的React版本，what! 这种事情插件不能自己搞定么，还需要去指定，打开给到的链接去看一波， You should also specify settings that will be shared across all the plugin rules.你应该在指定的所有插件规则共享的设置123456789101112&#123; &quot;settings&quot;: &#123; &quot;react&quot;: &#123; &quot;createClass&quot;: &quot;createReactClass&quot;, // Regex for Component Factory to use, // default to &quot;createReactClass&quot; &quot;pragma&quot;: &quot;React&quot;, // Pragma to use, default to &quot;React&quot; &quot;version&quot;: &quot;detect&quot;, // React version. &quot;detect&quot; automatically picks the version you have installed. // You can also use `16.0`, `16.3`, etc, if you want to override the detected value. &quot;flowVersion&quot;: &quot;0.53&quot; // Flow version &#125; &#125;&#125; 注意看这个配置&quot;version&quot;: &quot;detect&quot; 的注释，将React的version设置为detect，将会自动选择您安装的版本，当然你也可以选择其他版本，有想说脏话的冲动，我不使用已经安装的版本，安装这个版本有毛用，直接默认detect不就完了么，何苦呢！！！ issue上 因为这个警告也是叫声一片。 处理在.eslintrc.js中添加settings,代码如下：123456789101112&#123; &quot;extends&quot;: [ &quot;eslint-config-alloy/react&quot; ], plugins: [&quot;html&quot;], settings: &#123; react: &#123; pragma: &quot;React&quot;, version: &quot;detect&quot; &#125; &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>react</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4热更新]]></title>
    <url>%2Fpost%2F401303da.html</url>
    <content type="text"><![CDATA[在配置文件的output里添加publicPath在webpack配置文件中配置热更新插件在配置文件中引入webpack，并在插件中添加hmr插件1234plugins:[//热更新插件 new webpack.HotModuleReplacementPlugin()] 修改devServer的配置1234567devServer:&#123; host:'localhost', port:'8080', open:true//自动拉起浏览器 hot:true,//热更新，然后自动刷新 hotOnly:true // 修改hot为支持热更新&#125;, 问题完成上面4步操作后，打开页面，打开浏览器控制台，你会发现css已经实现了热更新，可是js修改的，控制台打印HMR很欢，可是像按钮绑定的函数依然是旧的，并没有更新，为了让它与 HMR 正常工作，我们需要使用 module.hot.accept 更新绑定到新的函数上，请参考这里 总结关于JavaScript代码改变带来的热更新问题，其实是很复杂的，因为在直接使用html/js/css的开发模式下，JavaScript是webpack指定的入口，可以控制，css通过JavaScript引入后，也可以被webpack控制，可是在传统的开发模式下，html是直接写在页面中的，不被js所控制，也就不被webpack所控制，在这种情况下，如果只是对JavaScript代码进行热更新，会导致一系列的问题，比如因为DOM不会被卸载而导致的事件重复绑定问题，所以在这种情况选择直接刷新页面反而是更好的。 webpack的官方文档在介绍这部分内容的，避开了这个问题。。。 以上是在配置webpack过程中的一些思考，有什么心得再更新吧]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中的runtimeChunk]]></title>
    <url>%2Fpost%2F97178d24.html</url>
    <content type="text"><![CDATA[webpack 4 提供了 runtimeChunk 能让我们方便的提取 manifest，以前我们需要这样配置1234new webpack.optimize.CommonsChunkPlugin(&#123; name: "manifest", minChunks: Infinity&#125;); 现在只要一行配置就可以了123&#123; runtimeChunk: true;&#125; 它的作用是将包含chunks 映射关系的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash 出来的，所以你每次改动都会影响它，如果不将它提取出来的话，等于app.js每次都会改变，导致缓存失效。 单独抽离 runtimeChunk 之后，每次打包都会生成一个runtimeChunk.xxx.js，其实这个文件非常的小，gzip 之后一般只有几 kb，但这个文件又经常会改变，我们每次都需要重新请求它，它的 http 耗时远大于它的执行时间了，所以建议不要将它单独拆包，而是将它内联到我们的 index.html 之中(index.html 本来每次打包都会变)。可以使用 inline-manifest-webpack-plugin或者 assets-webpack-plugin等来实现内联的效果。 1234567891011const InlineManifestWebpackPlugin = require("inline-manifest-webpack-plugin");new HtmlWebpackPlugin(&#123; template: paths.appHtml, filename: "index.html", // chunks sort by chunk Id chunksSortMode: "auto"&#125;),// 注意一定要在HtmlWebpackPlugin之后引用// inline 的name 和你 runtimeChunk 的 name保持一致// if you changed the runtimeChunk's name, you need to sync it herenew InlineManifestWebpackPlugin("manifest"),]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中hash、chunkhash和contenthash的区别]]></title>
    <url>%2Fpost%2Fa6a2aa2b.html</url>
    <content type="text"><![CDATA[hashhash 和每次 build 有关，没有任何改变的情况下，每次编译出来的 hash 都是一样的，但当你改变了任何一点东西，它的hash 就会发生改变。简单的说就是你改了任何东西，hash 就会和上次不一样了。 chunkhashchunkhash是根据具体每一个模块文件自己的的内容包括它的依赖计算所得的hash，所以某个文件的改动只会影响它本身的hash，不会影响其它文件。 contenthash它的出现主要是为了解决，让css文件不受js文件的影响。比如foo.css被foo.js引用了，所以它们共用相同的chunkhash值。但这样子是有问题的，如果foo.js修改了代码，css文件就算内容没有任何改变，由于是该模块的 hash 发生了改变，其css文件的hash也会随之改变。 这个时候我们就可以使用contenthash了，保证即使css文件所处的模块里有任何内容的改变，只要 css 文件内容不变，那么它的hash就不会发生变化。 contenthash 简单理解就是 moduleId.content 所生成的 hash。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决数据劫持时数组更新监控的问题]]></title>
    <url>%2Fpost%2F9cd69858.html</url>
    <content type="text"><![CDATA[动手模拟MVVM系列文章点击这里, 在实践数据劫持里的遗留问题： 当你修改数组的长度时，例如：arr.length = newLength 当你利用索引直接设置一个项时，例如：arr[index] = newValue 无法监控通过Array.prototype上的push、pop、shift、unshift、splice、sort、reverse、fill和copyWithin对数组的改变 今天写了个demo基本可以解决第三个问题，思路是通过一个对象代理数组原型上的九个方法（跟劫持数据的思路一样），当这九个方法被调用的时候，代理对象触发数据更新通知，思路实现代码如下： 代码清单1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 列出9个无法监控的方法var methodNames = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse", "fill", "copyWithin"];// 声明一个对象，该对象的[[proto]]指向Array.prototype，var arrProto = Object.create(Array.prototype);// 在对象arrProto上添加9个方法，用来覆盖Array.prototype上的同名方法// 这样就等于做了一个代理，在内部依然调用Array.prototype上的方法，methodNames.forEach((methodName) =&gt; &#123; arrProto[methodName] = function () &#123; let ret = Array.prototype[methodName].apply(this, [...arguments]); console.log(`调用$&#123;methodName&#125;方法: `, this); return ret; &#125;; &#125;);function dataIntercept(data) &#123; if (!data || typeof data !== "object") &#123; // console.log(`参数必须为对象`); return false; &#125; if (Array.isArray(data)) &#123; // 如果是数组类型， 将[[proto]]指向Array.prototype的代理，这样就实现了劫持 Object.setPrototypeOf(data, arrProto); data.map((item) =&gt; &#123; dataIntercept(item); &#125; ); &#125; else &#123; Object.keys(data).map((item, index) =&gt; &#123; var initData = data[item]; Object.defineProperty(data, item, &#123; enumerable: true, configurable: true, set: function (val) &#123; // console.log(`修改属性$&#123;item&#125;值为$&#123;val&#125;`); initData = val; &#125;, get: function () &#123; //console.log(`获取属性$&#123;item&#125;的值$&#123;initData&#125;`); return initData; &#125; &#125;); if (typeof initData === "object") &#123; dataIntercept(initData); &#125; &#125; ); &#125; &#125;var data = &#123; name: "daihaoxin", job: "coding", cities: [&#123; a: [4, 2, 3, 4] &#125;, "sh", "bj"]&#125;;dataIntercept(data);data.cities.push("hangzhou");console.log(data.cities);data.cities.pop();console.log(data.cities);data.cities[0].a.push(999);console.log(data.cities[0].a);data.cities.reverse();console.log(data.cities); 通过对Array.prototype设置代理，就实现了监控[&quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;reverse&quot;, &quot;fill&quot;, &quot;copyWithin&quot;]九个方法的调用。 对于第二个问题中arr[index] = newValue的操作，可以变通的通过调用splice实现。 代码清单212// Array.prototype.splicearr.splice(index, 1, newValue); 第一个问题遗留。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setInterval的问题及解决方案]]></title>
    <url>%2Fpost%2Fedfbf8c3.html</url>
    <content type="text"><![CDATA[问题 setInterval的定时器代码可能在下一次添加到队列之前，还没有执行完成。导致定时器代码连续执行，设置的间隔就没有意义。 javascript引擎的方案是，仅当队列中没有定时器代码实例的时候，才增加新的代码实例，这样就保证了定时器代码实例加入到队列中时，最小的时间间隔为指定间隔 javascript引擎的方案虽然解决了定时器代码实例加入队列的问题，但是又出现了新的问题，如果回调执行的时间比设定的时间间隔长，某些预定的执行会被跳过，另外因为执行时间的不确定性，会导致多次回调执行之间的间隔比预期的小 解决办法要解决这些问题，可以使用链式setTimeout来替代setInterval1234setTimeout(function fn()&#123; // 执行业务代码，执行完成后，设定一个任务 setTimeout(fn,interval);&#125;,interval) 这样就可以保证在当前定时器代码没有执行结束前，不会向队列中添加新的定时器代码实例，确保不会出现循环的定时器事件出现缺失； 而且可以确保在第一次定时器代码执行前，至少要等待指定的时间，避免了连续执行。 注意在定时器任务中，var timer=setTimeout(function(){})执行后，清除定时任务clearTimeout(timer)和timer=null是有区别的，timer只是一个定时任务的一个标示量，设置为null仅仅是改变了timer变量的值，对设定的任务没有影响，只有通过clearTimeout(timer)才是真的清除定时任务 扩展HTML5标准规定，setTimeout的最短时间间隔是4毫秒；setInterval的最短间隔时间是10毫秒，也就是说，小于10毫秒的时间间隔会被调整到10毫秒 大多数电脑显示器的刷新频率是60HZ，大概相当于每秒钟重绘60次。因此，最平滑的动画效的最佳循环间隔是1000ms/60，约等于16.6ms 为了节电，对于那些不处于当前窗口的页面，浏览器会将时间间隔扩大到1000毫秒。另外，如果笔记本电脑处于电池供电状态，Chrome和IE10+浏览器，会将时间间隔切换到系统定时器，大约是16.6毫秒]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之ES6遍历对象的五种武器]]></title>
    <url>%2Fpost%2F40104131.html</url>
    <content type="text"><![CDATA[准备先来准备一个测试对象obj。 代码清单1123456789101112131415161718192021222324252627282930var notEnum = Symbol("继承不可枚举symbol");var proto = &#123; [Symbol("继承可枚举symbol")]: "继承可枚举symbol", name: "继承可枚举属性"&#125;;// 不可枚举属性Object.defineProperty(proto, "age", &#123; value: "继承不可枚举属性"&#125;);// 不可枚举symbol属性Object.defineProperty(proto, notEnum, &#123; value: "继承不可枚举symbol"&#125;);var obj = &#123; job1: "自有可枚举属性1", job2: "自有可枚举属性2", [Symbol("自有可枚举symbol")]: "自有可枚举symbol"&#125;;// 继承Object.setPrototypeOf(obj, proto);// 不可枚举属性Object.defineProperty(obj, "address", &#123; value: "自有不可枚举属性"&#125;);// 不可枚举symbol属性var ownNotEnum = Symbol("自有不可枚举symbol");Object.defineProperty(obj, ownNotEnum, &#123; value: "自有不可枚举symbol"&#125;); 五种武器for…in这个是对象遍历界的老兵了，通过这种方式可以遍历对象自身及继承的所有可枚举属性(不包括Symbol类型)。 代码清单212345678for(var attr in obj)&#123; console.log(attr,"==",obj[attr]);&#125;/*job1 == 自有可枚举属性1job2 == 自有可枚举属性2name == 继承可枚举属性*/ Object.keys获取对象自身所有可枚举属性（不包括Symbol类型）组成的数组 代码清单31234567Object.keys(obj).map((attr)=&gt;&#123; console.log(attr,"==",obj[attr]);&#125;);/*job1 == 自有可枚举属性1job2 == 自有可枚举属性2*/ Object.getOwnPropertyNames获取对象自身所有类型为非Symbol的属性名称（包括不可枚举）组成的数组 代码清单412345678Object.getOwnPropertyNames(obj).map((attr)=&gt;&#123; console.log(attr,"==",obj[attr]);&#125;);/*job1 == 自有可枚举属性1job2 == 自有可枚举属性2address == 自有不可枚举属性*/ Object.getOwnPropertySymbols获取对象自身所有类型为Symbol的属性名称（包括不可枚举）组成的数组 代码清单51234567Object.getOwnPropertySymbols(obj).map((attr)=&gt;&#123; console.log(attr,"==",obj[attr]);&#125;);/*Symbol(自有可枚举symbol) == 自有可枚举symbolSymbol(自有不可枚举symbol) == 自有不可枚举symbol*/ Reflect.ownKeys获取一个对象的自身的所有（包括不可枚举的和Symbol类型）的属性名称组成的数组 代码清单612345678910Reflect.ownKeys(obj).map((attr)=&gt;&#123; console.log(attr,"==",obj[attr]);&#125;);/*job1 == 自有可枚举属性1job2 == 自有可枚举属性2address == 自有不可枚举属性Symbol(自有可枚举symbol) '==' '自有可枚举symbol'Symbol(自有不可枚举symbol) '==' '自有不可枚举symbol'*/ 总结武器库的说明书，根据需要选择合适的武器吧。 api 操作 自身属性 不可枚举属性 继承属性 Symbol属性 for…in 遍历 yes no yes no Object.keys 返回属性数组 yes no no no Object.getOwnPropertyNames 返回非Symbol属性数组 yes yes no no Object.getOwnPropertySymbols 返回Symbol属性数组 yes yes no yes Reflect.ownKeys 返回属性数组 yes yes no yes 五种武器里最牛的就是Reflect.ownKeys了，无论Symbol还是不可枚举通吃， 简直就是Object.getOwnPropertyNames和Object.getOwnPropertySymbols合体的效果。 扩展Object.values获取对象自身所有可枚举属性（不包括Symbol类型）的值组成的数组 代码清单71234567Object.values(obj).map((val)=&gt;&#123; console.log(val);&#125;);/*自有可枚举属性1自有可枚举属性2*/ Object.entries获取对象自身所有可枚举属性（不包括Symbol类型）的键值对数组 代码清单71234567Object.entries(obj).map((val)=&gt;&#123; console.log(val);&#125;);/*[ 'job1', '自有可枚举属性1' ][ 'job2', '自有可枚举属性2' ]*/ hasOwnProperty检测一个对象自身属性中是否含有指定的属性，返回boolean 引用自MDN: JavaScript 并没有保护 hasOwnProperty 属性名，因此某个对象是有可能存在使用这个属性名的属性，所以直接使用原型链上的 hasOwnProperty 方法 代码清单8123456789101112for(var attr in obj)&#123; if(Object.prototype.hasOwnProperty.call(obj,attr))&#123; console.log("自有属性：：",attr); &#125;else&#123; console.log("继承属性：：",attr); &#125;&#125;/*自有属性：： job1自有属性：： job2继承属性：： name*/ propertyIsEnumerable检测一个属性在指定的对象中是否可枚举，返回boolean 代码清单91234567891011121314Reflect.ownKeys(obj).map((attr) =&gt; &#123; if (Object.prototype.propertyIsEnumerable.call(obj, attr)) &#123; console.log("可枚举属性：：", attr); &#125; else &#123; console.log("不可枚举属性：：", attr); &#125;&#125;);/*可枚举属性：： job1可枚举属性：： job2不可枚举属性：： address可枚举属性：： Symbol(自有可枚举symbol)不可枚举属性：： Symbol(自有不可枚举symbol)*/ 参考MDN Object]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之原型链和继承]]></title>
    <url>%2Fpost%2F3adf5f9c.html</url>
    <content type="text"><![CDATA[这是一个被无数人写过的主题，有几篇讲的特别好，贴出来给自己打个mark，给大家看看，我就偷个小懒。 JavaScript Prototype(原型) 新手指南面向对象的 JavaScript – 深入了解 ES6 类javascript继承的写法JS 的 new 到底是干什么的？ 还有一张神图]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之函数柯里化]]></title>
    <url>%2Fpost%2Fc8159d62.html</url>
    <content type="text"><![CDATA[介绍部分来自JS函数式编程指南 介绍柯里化（curry）的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。回忆下之前讲作用域时提到的闭包概念，这里的一部分参数的缓存就是通过闭包实现的，仔细阅读下面的代码，你会发现无处不在的闭包。 curry函数可以一次性调用，也可以分多次调用，使用方式如下：123456789var add = function(x)&#123; return function(y)&#123; return x+y; &#125;&#125;var increment = add(1);var addTen = increment(10);increment(2); // 3addTen(2); // 3 这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用 add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数（helper function）使这类函数的定义和调用更加容易。 123456789101112131415var curry = require('lodash').curry;var match = curry(function(what, str) &#123; return str.match(what);&#125;);var replace = curry(function(what, replacement, str) &#123; return str.replace(what, replacement);&#125;);var filter = curry(function(f, ary) &#123; return ary.filter(f);&#125;);var map = curry(function(f, ary) &#123; return ary.map(f);&#125;); 上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里。到使用它们的时候你就明白这样做的原因是什么了。 1234567891011121314151617181920212223242526272829303132match(/\s+/g, "hello world");// [ ' ' ]match(/\s+/g)("hello world");// [ ' ' ]var hasSpaces = match(/\s+/g);// function(x) &#123; return x.match(/\s+/g) &#125;hasSpaces("hello world");// [ ' ' ]hasSpaces("spaceless");// nullfilter(hasSpaces, ["tori_spelling", "tori amos"]);// ["tori amos"]var findSpaces = filter(hasSpaces);// function(xs) &#123; return xs.filter(function(x) &#123; return x.match(/\s+/g) &#125;) &#125;findSpaces(["tori_spelling", "tori amos"]);// ["tori amos"]var noVowels = replace(/[aeiou]/ig);// function(replacement, x) &#123; return x.replace(/[aeiou]/ig, replacement) &#125;var censored = noVowels("*");// function(x) &#123; return x.replace(/[aeiou]/ig, "*") &#125;censored("Chocolate Rain");// 'Ch*c*l*t* R**n' 这里表明的是一种“预加载”函数的能力（有些地方也把这个称作延迟计算的能力），通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。这是闭包的应用 curry 的用处非常广泛，就像在 hasSpaces、findSpaces 和 censored 看到的那样，只需传给函数一些参数，就能得到一个新函数。只传给函数一部分参数通常也叫做局部调用（partial application），能够大量减少样板文件代码（boilerplate code）。 当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。哪怕输出是另一个函数，它也是纯函数。当然 curry 函数也允许一次传递多个参数，但这只是出于减少 () 的方便。 12345678910111213141516// 曾经使用模板的时候写过这样的代码function handleBar(template, data)&#123; return template.replace('&#123;&#123;name&#125;&#125;', data.name);&#125;handleBar("&lt;div&gt;我的名字&#123;&#123;name&#125;&#125;&lt;/div&gt;",&#123;name:"dhx"&#125;);handleBar("&lt;div&gt;&#123;&#123;name&#125;&#125;发表xx&lt;/div&gt;",&#123;name:"xingmu"&#125;);// 使用柯里化之后，代码就清晰多了function handleBar(template)&#123; return function(data)&#123; return template.replace('&#123;&#123;name&#125;&#125;', data.name); &#125;&#125;var nameRender = handleBar("&lt;div&gt;我的名字&#123;&#123;name&#125;&#125;&lt;/div&gt;");var nameRender2 = handleBar("&lt;div&gt;&#123;&#123;name&#125;&#125;发表xx&lt;/div&gt;");nameRender(&#123;name:"dhx"&#125;);nameRender2(&#123;name:"xingmu"&#125;); 封装一个curry函数的函数通过上一节的介绍我们知道，函数柯里化的过程，其实就是一个收集参数的过程，我们将每一次传入的参数都收集起来，并在完成参数的收集后，完成计算处理，我们可以尝试借助这个思路来封装。 1234567891011121314151617181920212223242526272829// 简单实现，参数只能从右到左传递function curry(fn) &#123; var argus= Array.prototype.slice.call(arguments,1); return function()&#123; var _argus = argus.concat([...arguments]); if(_argus.length &gt;= fn.length)&#123; // 参数收集完毕，执行 return fn.apply(null,_argus); &#125; // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 return curry.apply(null,[fn,..._argus]); &#125;&#125;// testvar abc = function (a, b, c) &#123; console.log([a,b,c]); return [a,b,c];&#125;;var curried = curry(abc);curried(1)(2)(3);// =&gt; [1, 2, 3]curried(1, 2)(3);// =&gt; [1, 2, 3]curried(1, 2, 3);// =&gt; [1, 2, 3] 柯里化与偏函数当把已知函数的一些参数固定，结果函数被称为偏函数，通过使用bind获得偏函数，也有其他方式实现。当我们不想一次一次重复相同的参数时，偏函数是很便捷的。如我们有send(from,to)函数，如果from总是相同的，可以使用偏函数简化调用。 而柯里化是用来转换函数调用从f(a,b,c)至f(a)(b)(c)的一种思路，也可通过柯里化的方式来实现偏函数。 总结curry 函数用起来非常得心应手，堪称手头必备工具，能够让函数式编程不那么繁琐和沉闷。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之作用域链及闭包]]></title>
    <url>%2Fpost%2F193d2fc5.html</url>
    <content type="text"><![CDATA[在执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象和this指向已经总结过了，今天就是要聊聊作用域的建立，以及闭包。 很多人将作用域链和调用栈混为一谈，一定要记住作用域链顺序和调用栈(执行上下文组成的链)的顺序没有关系。原因：JavaScript的作用域（scope）是静态作用域，作用域是在函数定义的时候就被确定了，所以作用域链也是在函数定义的时候就被确定了，是根据函数定义的位置来计算的。而调用栈是在函数执行时动态生成的，跟函数被调用相关，跟函数定义无关。 作用域链的作用作用域链（scope chain）的用途是保证对执行上下文有权访问的所有变量和函数的有序访问，作用域链的最前端始终都是当前执行的代码所在环境的变量对象。。 很拗口，画重点：作用域链是由函数代码所处位置的上层以及更上层函数的变量对象组成。。 放大镜里的作用域链前面说过作用域链是由函数定义的时候确定的，那么到底是怎么确定的，通过模拟静态作用域的语法分析树，来看下作用域链是怎么在定义的时候被确定的。1234567891011121314151617/*全局（window）域下的一段代码*/var a = 1,b = 2;function test(c, d)&#123; var e = 4; console.log(a); function foo(f,g) &#123; a = 11; var h = 5; function jec()&#123;&#125; function bar(k)&#123; console.log(k); &#125;; bar(60); &#125;; foo(40,50);&#125;test(10,20); 上面的代码很简单，定义了一些全局变量和全局方法，然后在方法内又定义局部变量和局部方法，运行时，JS 引擎会先通过语法分析和预解析得到语法分析树，我们重点就来看看这个树都有些什么信息。 为了清晰表示个各种对象间的引用关系，我们用一个简单的伪对象表示上面的代码的语法分析树。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 模拟建立一棵语法分析树，存储function内的变量和方法 */var SyntaxTree = &#123; // 全局对象在语法分析树中的表示 window: &#123; variables: &#123; a: &#123; value: 1 &#125;, b: &#123; value: 2 &#125; &#125;, functions: &#123; test: this.test &#125; &#125;, test: &#123; variables: &#123; e: undefined &#125;, functions: &#123; foo: this.foo &#125;, scope: this.window &#125;, foo: &#123; variables: &#123; h: undefined &#125;, functions: &#123; jec: this.jec, bar: this.bar &#125;, scope: this.test &#125;, jec: &#123; variables: &#123;&#125;, functions: &#123;&#125;, scope: this.foo &#125;, bar: &#123; variables: &#123; k: undefined &#125;, functions: &#123;&#125;, scope: &#123; myname: bar, scope: this.foo &#125; &#125;&#125;; 根据语法分析树中当前函数对应的scope属性，就可以勾勒出一个链，这个就是作用域链，变量查找就是跟着这条链条的变量对象查找的 PS：很多时候作用域链都被认为是包含的结构，其实并不是，它是一个单向通道的链条，以上例中的函数bar为例，我们可以通过一个数组来表示，它作用域链上的变量对象应该是这样的[VO(bar), VO(foo), VO(test), VO(window)]， 查找变量的先后顺序应该是这样的VO(bar) =&gt; VO(foo) =&gt; VO(test) =&gt; VO(window) 闭包闭包又称为词法闭包， 如果函数B访问了函数A执行上下文的变量对象，那么函数A就是一个闭包。而函数B，即使在创建它的函数A的上下文被销毁的时候，它依然存在。 看下一个闭包的代码： 1234567891011function A()&#123; var a = 10; var b = function()&#123; console.log(a); &#125; return b;&#125;var b = A();b(); 通过chrome的call stack可以看到形成一个闭包 闭包的变量查找规则和作用域链规则跟正常的函数是一样的，唯一不同的是变量a的释放时机，取决于b没有了引用。 面试必刷题利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 512345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 总结从语法分析树角度来分析作用域链，虽然自己感觉已经讲的很清楚了，但是理解作用域链不是一件简单的事情，如果有什么问题，欢迎给我留言。 理解了作用域链和变量对象，闭包看起来就很简单了，只是函数B运行时使用了函数A的变量对象，这时候A就被成为闭包。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章]]></title>
    <url>%2Fpost%2F689f05e1.html</url>
    <content type="text"><![CDATA[requestAnimationFrame更好的逐帧动画函数 — requestAnimationFrame 简介从setTimeout谈JavaScript运行机制requestAnimationFrame 动画接口你需要知道的requestAnimationFramejs动画—–setTimeout、setInterval、requestAnimationFrame谈谈requestAnimationFrame的动画循环 requestAnimationFrame SCSSSASS基础教程 javascript运行机制浏览器的渲染线程与JavaScript引擎线程是互斥的,这容易理解,因为JavaScript脚本是可操纵DOM元素,在修改这些元素属性同时渲染界面,那么渲染线程前后获得的元素数据就可能不一致了.在JavaScript引擎运行脚本期间,浏览器渲染线程都是处于挂起状态的,也就是说被”冻结”了.浏览器模型定时计数器并不是由JavaScript引擎计数的,因为JavaScript引擎是单线程的,如果处于阻塞线程状态就计不了时,它必须依赖外部来计时并触发定时,所以队列中的定时事件也是异步事件.JavaScript 运行机制详解：再谈Event LoopJavascript定时器学习笔记理解 JavaScript 的 async/awaitasync 函数的含义和用法 commonjs是同步的，为服务端设计的，不适用前端，所以有了使用define([依赖项列表],function(依赖项列表){})定义的 amd通用模块定义(Universal Module Definition) ，即我们通常说的 UMD ，就是用来解决这个特殊问题的。本质上，UMD 是一套用来识别当前环境支持的模块风格的 if/else 语句。123456789101112131415161718192021// UMD 风格编写的 sum 模块//sum.umd.js(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['add', 'reduce'], factory); &#125; else if (typeof exports === 'object') &#123; // Node, CommonJS-like module.exports = factory(require('add'), require('reduce')); &#125; else &#123; // Browser globals (root is window) root.sum = factory(root.add, root.reduce); &#125;&#125;(this, function (add, reduce) &#123; // private methods // exposed public methods return function(arr) &#123; return reduce(arr, add); &#125;&#125;)); 在当前的JavaScript模块系统中，你必须执行代码，来找出什么是 导入 和 什么是 导出。这是 ECMAScript 6 与这些模块系统（注：指 CMD，AMD）决裂的主要原因： 通过将模块系统构建到JavaScript语言中，您可以在语法上强制执行静态模块结构。让我们先来看看这意味着什么，带来什么好处。 模块的静态结构，意味着您可以在编译时确定导入和导出（静态） – 你只需要看看源代码，你不必执行它，webpack的打包优化也依赖这一点。下面是两个 CommonJS 模块的例子，告诉你为什么 CommonJS 模块在编译时确定导入和导出是不可能的。在第一示例中，你必须运行代码才可以找出它导入的是什么： 安全带你了解CSRF和XSS（一）漏洞科普：对于XSS和CSRF你究竟了解多少web前端安全主要会涉及以下几种 reactReact key值的作用和使用详解React沉思录Redux深度揭秘 HTTP缓存机制Cache-Control 在 HTTP 响应头中，用于指示代理和 UA 使用何种缓存策略）。比如： no-cache 为本次响应不可直接用于后续请求（在没有向服务器进行校验的情况下） no-store 为禁止缓存（不得存储到非易失性介质，如果有的话尽量移除，用于敏感信息） private为仅 UA 可缓存 public为大家都可以缓存。 must-revalidate 如果缓存过期，必须去源服务器进行有效性验证面试精选之http缓存 彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法 HTTP缓存控制小结-IMWEB HTTP Cache 为什么让人很困惑 使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control 面试前端面试之道收集的前端面试题和答案【半月刊】前端高频面试题及答案汇总【半月刊 2】前端高频面试题及答案汇总前端进阶系列最新前端面试题攻略如何通过饿了么 Node.js 面试 其他使用原生 JS 实现事件委托EventTarget.addEventListenerMutation Observer API聊聊我对现代前端框架的认知Daily-Interview-Question系列专题怎样防止重复发送 Ajax 请求？使用JavaScript 写Web路由web性能优化－预加载 git 用远程覆盖本地12git fetch --allgit reset --hard origin/master 深入浅出js什么是 JS 原型链 ES6let 声明会提升（hoist）吗 JS变量封禁大法：薛定谔的X 这是CommonJS模块和ECMAScript模块之间的关键区别，因为在评估包装函数时动态定义CommonJS模块的导出，因此ESM的导出是在词法上定义的。也就是说，ESM导出的符号是在实际评估JavaScript代码之前解析的。 1&lt;meta http-equiv="refresh" content="2；URL=http://www.lxxyx.win/"&gt; //意思是2秒后跳转向我的博客]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手模拟MVVM之五双向数据流及事件绑定]]></title>
    <url>%2Fpost%2F76f04810.html</url>
    <content type="text"><![CDATA[MVVM (Model-View-ViewModel) 是一种用于把数据和UI分离的设计模式。 前一篇已经完成了单项model到view的单向数据更新，今天来继续完善代码，实现数据从view到model的更新，以及事件绑定的部分。 思路view到model的更新： 首先， 在view中增加一个input，并添加v-model=&quot;job&quot;指令 然后在Complie解析模板的时候，如果是节点，则判断节点属性的key，去匹配v-model指令 匹配到指令后，添加v-model对应的key的观察者，完成绑定 事件绑定：在Compile解析模板的时候，如果是节点，则去判断节点属性的key是否以v-on开头，如果是则为节点绑定v-on后面的事件类型，事件回调函数为v-on开头的属性的值， 记得在初始化的时候配置methods，并绑定this为MVVM 演示地址 完整代码地址 总结很粗糙，细节问题很多，只是模拟了mvvm实现的基本思路， demo中很多细节没有考虑，比如事件委托绑定、更新节点的粒度等，多读源码继续提升。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手模拟MVVM之四单向数据流的实现]]></title>
    <url>%2Fpost%2F7446b8ea.html</url>
    <content type="text"><![CDATA[MVVM (Model-View-ViewModel) 是一种用于把数据和UI分离的设计模式。 概念Model表示应用程序使用的数据，比如一个用户账户信息(名字、头像、电子邮件等)。它并不具有任何行为逻辑，它只是数据，因而它不会对信息进行再次加工，不会影响浏览器展示数据。数据的格式化展示是由View处理的。 View是与用户进行交互的桥梁，它包括了一些数据绑定，事件，和行为，这些都会直接影响Model和ViewModel。 ViewModel充当数据转换器，可以被看作是MVC中的Controller，它主要负责数转换（用一定的业务逻辑），它负责将Model的变化反应到View上，而当View自身有变化时也会同步Model进行改变。你可以把ViewModel看作一个藏在View后面的好帮手，它把View需要的数据暴露给它，并且富于View一定的行为能力。 优点 UI与逻辑的分离。 写unit测试比较方便，毕竟测ViewModel要比测个种Event方便多了。 清理思路今天先来完成一个从model =&gt; view的单项数据流，即当model改变的时候，view会自动更新。 顺便说一个套路，就是在写一个组件或者库的时候，要有面向接口编程的思路，什么意思？ 就是在开始之前，要先考虑的是组件/库怎么被使用（别人怎么去调用），当然如果不用调用就能完成就更好了，手动滑稽。 假设有如下代码，data 里的name、job会和视图中大括号中的name、job一一映射，修改 data 里的值，会直接引起视图中对应数据的变化。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;name&#125;&#125; 是一个 &#123;&#123;job&#125;&#125;&lt;/div&gt; &lt;script&gt; let mvvm = new MVVM(&#123; el: "#app", data: &#123; name: "dhx", job:"jser" &#125; &#125;); setTimeout(function () &#123; Object.assign(mvvm.$data, &#123; name:"xingmu", job:"csser" &#125;); &#125;,2000) &lt;/script&gt;&lt;body&gt; 该如何通过实践MVVM来实现这种调用方式呢？结合前面预习过的数据劫持和观察者模式： 主题（subject）是什么？ 观察者（observer）是什么？ 观察者何时订阅主题？ 主题何时通知更新？ 主题应该是data的name和job属性，观察者是视图里大括号中的name、job；MVVM初始化的时候，去解析el模板里大括号中的name、job的时候订阅主题，当name和job发生改变的时候，通知观察者更新内容。 完整代码和注释演示地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;name&#125;&#125; 是一个 &#123;&#123;job&#125;&#125;&lt;/div&gt; &lt;p&gt;PS: 两秒钟后，文字自动变化，你也可以通过控制台使用mvvm.name或者mvvm.job改变变量的值&lt;/p&gt; &lt;script&gt; // 没有改变 class Subject &#123; constructor() &#123; this.id = Symbol(); this.observers = []; &#125; addObserver(observer) &#123; this.observers.push(observer); &#125; removeObserver(observer) &#123; let index = this.observers.indexOf(observer); if (index &gt; -1) &#123; this.observers.splice(index, 1); &#125; &#125; notify() &#123; this.observers.forEach(function (observer) &#123; observer.update(); &#125;); &#125; &#125; // 观察者 class Observe &#123; constructor(mvvm, key, callback) &#123; this.mvvm = mvvm; this.key = key; // 需要观察的属性key this.callback = callback; // 属性变化时候的回调函数 this.subjects = &#123;&#125;; // 订阅的主题列表 this.value = this.mvvm[this.key]; // 获取当前key的值 &#125; update() &#123; // 缓存每一次的新值，用于比较更新 let [oldVal, value] = [this.value, this.mvvm[this.key]]; this.value = value; this.callback.call(this.mvvm, oldVal, value); &#125; subscribeTo(subject) &#123; // 记录订阅的主题列表，如果已经订阅，则不在添加 if (!this.subjects[subject.id]) &#123; subject.addObserver(this); this.subjects[subject.id] = subject; &#125; &#125; &#125; class Compile &#123; constructor(mvvm) &#123; this.mvvm = mvvm; this.analyze(mvvm.$el); &#125; analyze(node) &#123; if (node.nodeType === Node.ELEMENT_NODE) &#123; // 如果节点是element，继续递归 Array.from(node.childNodes).map((item) =&gt; &#123; this.analyze(item); &#125;); &#125; else if (node.nodeType === Node.TEXT_NODE) &#123; // 如果是文本节点，则去处理文本替换 this.compileText(node); &#125; &#125; compileText(node) &#123; // 找出文本中所有的&#123;&#123;&#125;&#125;包裹的变量key let reg = /&#123;&#123;(.+?)&#125;&#125;/g; let match; while (match = reg.exec(node.nodeValue)) &#123; // console.log(match); let raw = match[0]; let key = match[1].trim(); // 为key设置一个观察者 this.mvvm.currentObserve = new Observe(this.mvvm, key, (oldVal, newVal) =&gt; &#123; // 当接收到属性值变化的通知时，执行更新 node.nodeValue = node.nodeValue.replace(oldVal, newVal); &#125;); // 替换文本节点中的变量 node.nodeValue = node.nodeValue.replace(raw, this.mvvm[key]); // 此时观察者订阅已完成，销毁 this.mvvm.destroyCurrentObserve(); &#125; &#125; &#125; // mvvm class MVVM &#123; constructor(options) &#123; this.init(options); // 初始化mvvm this.dataIntercept(); // 数据劫持 new Compile(this); // 解析el模板 &#125; init(options) &#123; this.$data = options.data; this.$el = document.querySelector(options.el); this.bindData(); this.currentObserve = null; &#125; destroyCurrentObserve() &#123; this.currentObserve = null; &#125; bindData() &#123; // this代理this.$data里的属性 Object.keys(this.$data).map((key) =&gt; &#123; Object.defineProperty(this, key, &#123; enumerable: true, configurable: true, get() &#123; return this.$data[key]; &#125;, set(val) &#123; this.$data[key] = val; &#125; &#125;); &#125;); &#125; dataIntercept() &#123; /** * 代码跟数据劫持相比，多了创建主题、取值的时候订阅主题和设置值的时候发出通知 */ let fn = (data) =&gt; &#123; if (!data || typeof data !== "object") &#123; return false; &#125; Object.keys(data).map((key, index) =&gt; &#123; let initData = data[key]; // 为每个key创建一个主题 let subject = new Subject(); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, set: (val) =&gt; &#123; // console.log(`修改属性$&#123;key&#125;值为$&#123;val&#125;`); initData = val; subject.notify(); // 如果key的值发生了变化，通知所有的观察者 &#125;, get: () =&gt; &#123; if (this.currentObserve) &#123; // 如果this.currentObserve存在，就在获取属性的时候 // 订阅当前key的变化 this.currentObserve.subscribeTo(subject); &#125; // console.log(`获取属性$&#123;key&#125;的值$&#123;initData&#125;`); return initData; &#125; &#125;); if (typeof initData === "object") &#123; dataIntercept(initData); &#125; &#125;); &#125;; fn(this.$data); &#125; &#125; let mvvm = new MVVM(&#123; el: "#app", data: &#123; name: "dhx", job: "jser" &#125; &#125;); setTimeout(function () &#123; mvvm.name = "xingmu"; mvvm.job = "csser"; &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 问题总结在更新文本节点的时候，如果文本节点中存在和初始化变量值一样的内容，会被后面的更新替换掉，这一块需要再考虑考虑，如果你有的好的想法，欢迎交流。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手模拟MVVM之三实践观察者模式]]></title>
    <url>%2Fpost%2Fcf3255c4.html</url>
    <content type="text"><![CDATA[一个典型的观察者模式应用场景是用户在一个网站订阅主题，多个用户（观察者Observer）都可以订阅某个主题（Subject），当主题内容更新时订阅该主题的用户都能收到通知。 代码实践先来定义一个主题Subject，通过new Subject()创建一个主题对象，该对象内部维护订阅当前主题的观察者数组。主题对象上有一些方法，如添加观察者（addObserver）、删除观察者（removeObserver）、通知观察者更新（notify）。 当notify被调用时，实际上调用全部观察者observer自身的update方法。123456789101112131415161718// Subjectfunction Subject() &#123; this.observers = []&#125;Subject.prototype.addObserver = function(observer) &#123; this.observers.push(observer)&#125;Subject.prototype.removeObserver = function(observer) &#123; var index = this.observers.indexOf(observer) if(index &gt; -1)&#123; this.observers.splice(index, 1) &#125;&#125;Subject.prototype.notify = function() &#123; this.observers.forEach(function(observer)&#123; observer.update() &#125;)&#125; 然后定义观察者Observer，new Observer()创建一个观察者对象，该对象有一个update方法，当收到主题的变更通知时，update方法会被调用。123456function Observer(name) &#123; this.name = name;&#125;Observer.prototype.update=function()&#123; console.log(this.name + ' update...')&#125; 使用写好的Subject和Observe测试下： 123456789101112131415161718// 创建主题var subject = new Subject()//创建观察者1var observer1 = new Observer('dhx')//主题添加观察者1subject.addObserver(observer1)//创建观察者2var observer2 = new Observer('jack')//主题添加观察者2subject.addObserver(observer2)//主题通知所有的观察者更新subject.notify()// 输出// dhx update...// jack update... 一点改进在上面的代码中，添加订阅主题的操作是主题进行的，不太符正常的情形，正常应该是观察者去主动关注主题，所以我们对Observe添加订阅主题的方法。修改后的Observe； 123456789101112131415161718192021222324252627282930function Observer(name) &#123; this.name = name;&#125;Observer.prototype.update=function()&#123; console.log(this.name + ' update...')&#125;// 添加关注主题的方法Observer.prototype.subscribeTo=function(subject)&#123; subject.addObserver(this);&#125;// 修改后调用改为// 创建主题var subject = new Subject()//创建观察者1var observer1 = new Observer('dhx')//主题添加观察者1subject.addObserver(observer1)//创建观察者2var observer2 = new Observer('jack')//主题添加观察者2subject.addObserver(observer2)//主题通知所有的观察者更新subject.notify()// 输出// dhx update...// jack update... 到此基本完成观察者模式的代码。 换成 ES6的写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 主题class Subject &#123; constructor() &#123; this.observers = []; &#125; addObserver(observer) &#123; this.observers.push(observer); &#125; removeObserver(observer) &#123; let index = this.observers.indexOf(observer); if (index &gt; -1) &#123; this.observers.splice(index, 1); &#125; &#125; notify() &#123; this.observers.forEach(function (observer) &#123; observer.update(); &#125;); &#125;&#125;// 观察者class Observer&#123; constructor(name) &#123; this.name = name; &#125; update() &#123; console.log(this.name + " update..."); &#125; // 添加关注主题的方法 subscribeTo(subject) &#123; subject.addObserver(this); &#125;&#125;// 调用// 创建主题var subject = new Subject();//创建观察者1var observer1 = new Observer("dhx");//主题添加观察者1subject.addObserver(observer1);//创建观察者2var observer2 = new Observer("jack");//主题添加观察者2subject.addObserver(observer2);//主题通知所有的观察者更新subject.notify();// 输出// dhx update...// jack update... 总结感谢阅读，欢迎提出问题，一起进步！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之理解静态作用域]]></title>
    <url>%2Fpost%2Fbc77487f.html</url>
    <content type="text"><![CDATA[什么是作用域 【维基百科】作用域（scope）是指是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。作用域类别影响变量的绑定方式，根据语言使用静态作用域还是动态作用域，变量的取值可能会有不同的结果。 通俗点说，就是作用域规定了如何查找变量。 静态作用和动态作用域的概念关于静态作用域和动态作用于在维基百科中是这样介绍的： 静态作用域又叫做词法作用域，采用词法作用域的变量叫词法变量。词法变量有一个在编译时静态确定的作用域。词法变量的作用域可以是一个函数或一段代码，该变量在这段代码区域内可见（visibility）；在这段区域以外该变量不可见（或无法访问）。词法作用域里，取变量的值时，会检查函数定义时的文本环境，捕捉函数定义时对该变量的绑定。大多数现在程序设计语言都是采用静态作用域规则，如C/C++、C#、Python、Java、JavaScript……相反，采用动态作用域的变量叫做动态变量。只要程序正在执行定义了动态变量的代码段，那么在这段时间内，该变量一直存在；代码段执行结束，该变量便消失。这意味着如果有个函数f，里面调用了函数g，那么在执行g的时候，f里的所有局部变量都会被g访问到。而在静态作用域的情况下，g不能访问f的变量。动态作用域里，取变量的值时，会由内向外逐层检查函数的调用链，并打印第一次遇到的那个绑定的值。显然，最外层的绑定即是全局状态下的那个值。采用动态作用域的语言有Pascal、Emacs Lisp、Common Lisp（兼有静态作用域）、Perl（兼有静态作用域）。C/C++是静态作用域语言，但在宏中用到的名字，也是动态作用域。 这么长一大段到底再说什么？总结一下就是一句话，两个点： 动态作用域和静态作用域，决定的是作用域链的序列 静态作用域中，变量的引用在编译的阶段就可以确定，跟程序执行的顺序无关。 12345678910// 注：以下是伪代码，不针对任何一种语言。a=2;function foo()&#123; print(a); // 这里输出2，而不是3&#125;function bar()&#123; a=3; foo();&#125;bar(); 动态作用域中，变量引用需要在程序运行时才能确定。 12345678910// 注：以下是伪代码，不针对任何一种语言。a=2;function foo()&#123; print(a); // 这里输出3，而不是2&#125;function bar()&#123; a=3; foo();&#125;bar(); // 2 JavaScript中的静态作用域JavaScript 采用的是静态作用域（注意：with和eval的语义无法仅通过静态技术实现，实际上，只能说JS的作用域机制非常接近lexical scope。），即使一个函数定义的地方和使用的地方会相隔十万八千里，但是函数执行时，它能访问哪些变量，不能访问哪些变量，是由函数定义时的函数的作用域决定的，而函数的作用域是由定义时的位置决定的。 123456789var a=2;function foo()&#123; console.log(a);&#125;function bar()&#123; var a=3; foo();&#125;bar(); // 输出2 通过分析可知，执行 foo 函数： 先从 foo 函数是否有局部变量a 没有找到为a的局部变量 在函数作用域上，依次查找上面一层，找到a等于 2， 输出 2 测试下面是《JavaScript权威指南》里的代码，看下两个函数的执行结果是多少？ 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 答案：local scope JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 – 《JavaScript权威指南》 参考javascript的词法作用域动态作用域和词法域的区别是什么？]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手模拟MVVM之二实践数据劫持]]></title>
    <url>%2Fpost%2F7d25504d.html</url>
    <content type="text"><![CDATA[所谓的数据劫持，说白了就是在数据变动的时候，可以执行一些自定义的操作，而通过Object.defineProperty来设置对象属性的setter和getter方法刚好可以做到这一点，所以只要学会的Object.defineProperty的使用，数据劫持是很简单的。 代码实践 先准备一个对象 1234var data=&#123; name:"daihaoxin", job:"coding"&#125; 获取对象的属性描述符 1234567891011121314151617console.log(Object.getOwnPropertyDescriptors(data));// 输出&#123; "name": &#123; "value": "daihaoxin", "writable": true, "enumerable": true, "configurable": true &#125;, "job": &#123; "value": "coding", "writable": true, "enumerable": true, "configurable": true &#125;&#125; 下面我们将data的属性转换为存取描述符 12345678910111213141516171819202122Object.keys(data).map((item,index)=&gt;&#123; var initData = data[item]; Object.defineProperty(data, item, &#123; enumerable: true, configurable: true, set: function(val) &#123; console.log(`修改属性$&#123;item&#125;值为$&#123;val&#125;`); // 注意这里不能直接使用 data[item]=val，这样会引发重复设置属性值的死循环 initData = val; &#125;, get: function() &#123; console.log(`获取属性$&#123;item&#125;的值$&#123;initData&#125;`); // 注意这里不能使用data[item]，同样会引发重复获取属性值的死循环 return initData; &#125; &#125;);&#125;);// 尝试修改属性的值试一试data.name="xingmu"; // 修改属性name值为xingmudata.name; // 获取属性name的值xingmudata.job="jser"; // 修改属性job值为jserdata.job; // 获取属性job的值jser 通过Object.getOwnPropertyDescriptors对比前后两次的属性描述符，可以看到已经成功转换了 封装为函数，有两点需要注意 对参数做为空和类型验证 对复杂属性进行递归处理12345678910111213141516171819202122232425262728293031323334function dataIntercept(data) &#123; if(!data || typeof data !== 'object')&#123; console.log(`参数必须为对象`); return false; &#125; Object.keys(data).map((item,index)=&gt;&#123; var initData = data[item]; Object.defineProperty(data, item, &#123; enumerable: true, configurable: true, set: function(val) &#123; console.log(`修改属性$&#123;item&#125;值为$&#123;val&#125;`); initData = val; &#125;, get: function() &#123; console.log(`获取属性$&#123;item&#125;的值$&#123;initData&#125;`); return initData; &#125; &#125;); if(typeof initData === 'object')&#123; dataIntercept(initData) &#125; &#125;);&#125;var data = &#123; name: "daihaoxin", job: "coding"&#125;dataIntercept(data);// 尝试修改属性的值试一试data.name="xingmu"; // 修改属性name值为xingmudata.name; // 获取属性name的值xingmudata.job="jser"; // 修改属性job值为jserdata.job; // 获取属性job的值jser 上面的 dataIntercept 函数实现了一个数据监听，当监听某个对象后，我们可以在用户读取或者设置属性值的时候做个拦截，做我们想做的事 总结这个dataIntercept能够实现预定的基本功能，但是对于属性值为数组类型的处理上还有些问题，无法监控数组的变化原因： 当你修改数组的长度时，例如：arr.length = newLength 当你利用索引直接设置一个项时，例如：arr[index] = newValue 无法监控通过Array.prototype上的push、pop、shift、unshift、splice、sort、reverse、fill和copyWithin对数组的改变 参考为什么defineProperty不能检测到数组长度的“变化”]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手模拟MVVM之一预备姿势]]></title>
    <url>%2Fpost%2F86bf8f08.html</url>
    <content type="text"><![CDATA[MVVM框架在目前的js开发中逐渐成为主流，我一直在想它是怎么做到这一点的，本着好奇和想深入学习的源故，经过一番研究，自己实现了一个非常简单的MVVM框架，本系列基本展示MVVM框架的设计思路，有其意，无其形，勉强可以一看。 从MVVM实现角度看，在真正开始代码之前，还需要具备一定的知识储备。 Object.defineProperty通过Object.defineProperty中的setter、getter来劫持model中各个属性，当数据在变动的时候发布数据的订阅者，触发相应的监听回调。Object.defineProperty是ES5新增的一个API，vue2.0中使用它来做的双向数据绑定，关于它的知识建议直接看MDN（我是传送门）。 注意以下几点： configurable、enumerable和writable的默认值是false，value默认值undefined configuration可以控制configuration、enumeration和是否可删除 configuration和writable、value的关系文章没有写的特别清除，下面的表格是我在chrome下测试的结果，你也可以试一试。两个结论： 只有在configuration和writable均为false的时候：writable不可修改的，defineProperty不可修改属性值 普通方式是否可以修改属性值，是由writable决定的 configuration writable writable是否可修改 defineProperty是否可修改属性值 普通方式是否可修改属性值（a.b） true true Yes Yes Yes true false Yes Yes No false true Yes Yes Yes false false No No No 数据描述符和存取描述符是描述付的两种形式，必须是两者之一，不能混合使用 类型 configurable enumerable value writable get set 数据描述符 Yes Yes Yes Yes No No 存取描述符 Yes Yes No No Yes Yes 理解观察者（发布订阅）模式通过观察者模式化可以实现V和M之间的互相绑定，在MVVM初始化的时候view去订阅model中的属性，当订阅的属性发生变化的时候，去通知view做出更新。 网上有很多文章都在写观察者模式和发布订阅模式的区别，其实两者并无区别，两者并无区别，两者并无区别，重要的事情说三遍，从代码实现的角度去理解模式，从字面上去抠，没意思。 不理解这个模式的，可以去看这里 我是传送门1我是传送门2 总结介绍一下自己动手实现MVVM的准备知识，下一篇怎么通过Object.definePrototype实现数据劫持。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>动手模拟</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记之选择器]]></title>
    <url>%2Fpost%2F27f2f4d0.html</url>
    <content type="text"><![CDATA[css优先级的计算优先级的计算首先是 选择器权重 的优先级计算，然后是 声明先后顺序 的优先级计算。 选择器的权重分为了三个级别，权重由大到小一次为id选择器、class选择器、元素选择器， 也就是优先计算id选择器的权重，如果相等再计算class选择器的权重，以此类推。当三个级别的权重都相等时，后面的样式声明覆盖前面的，将是最终结果。123456789* /* a=0 b=0 c=0 */LI /* a=0 b=0 c=1 */UL LI /* a=0 b=0 c=2 */UL OL+LI /* a=0 b=0 c=3 */H1 + *[REL=up] /* a=0 b=1 c=1 */UL OL LI.red /* a=0 b=1 c=3 */LI.red.level /* a=0 b=2 c=1 */#x34y /* a=1 b=0 c=0 */#s12:not(FOO) /* a=1 b=0 c=1 */ 下面举个栗子：123456789101112131415161718&lt;div class="lizi" id="lizi"&gt; &lt;div class="child_lizi"&gt;栗子&lt;/div&gt;&lt;/div&gt;&lt;style&gt;div&#123; height:30px; /*id = 0 , class = 0 , label = 1*/&#125;.lizi&#123; height:120px; /*id=0, class=1 , label=0 */&#125;.lizi .child_lizi&#123; height:80px; /* id = 0 , class = 2 , label = 0 */&#125;div .child_lizi&#123; height:135px; /* id = 0 , class = 1 , label = 1*/&#125;&lt;/style&gt; 由上可知，id选择器权重相等，class选择器第三条权重最大，最终结果.lizi .child_lizi的声明是最终值。 简洁高效的css所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找。 不要在ID选择器前使用标签名，因为ID选择器是唯一的，加上div反而增加不必要的匹配 123#DIV#divBox /*更好写法：*/#divBox 不要再class选择器前使用标签名 尽量少使用层级关系 123divBox p .red&#123;color:red;&#125; /*更好写法：*/.red&#123;..&#125; 使用class代替层级关系 123#divBox ul li a&#123;display:block;&#125; /*更好写法：*/.block&#123;display:block;&#125; 基本选择器 选择器 含义 * 通用元素选择器，匹配任何元素 E 标签选择器，匹配所有使用E标签的元素 .info class选择器，匹配所有class属性中包含info的元素 #footer id选择器，匹配所有id属性等于footer的元素 示例：123456* &#123; margin:0; padding:0; &#125;p &#123; font-size:2em; &#125;.info &#123; background:#ff0; &#125;p.info &#123; background:#ff0; &#125;#info &#123; background:#ff0; &#125;p#info &#123; background:#ff0; &#125; 选择器关系选择器 选择器 含义 E,F 多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔 E F 后代选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔 E &gt; F 子选择器，匹配所有E元素的直接子元素F E + F 相邻兄弟选择器，匹配所有紧随E元素之后的同级元素F E ~ F 一般兄弟选择器, 匹配任何在E元素之后的同级F元素 12345div p &#123; color:#f00; &#125;#nav li &#123; display:inline; &#125;div &gt; strong &#123; color:#f00; &#125;p + p &#123; color:#f00; &#125;p ~ ul &#123; background:#ff0; &#125; 属性选择器 选择器 含义 E[attr] 匹配所有具有attr属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如”[cheacked]”。以下同。） E[attr=val] 匹配所有attr属性等于”val”的E元素 E[attr~=val] 匹配所有attr属性具有多个空格分隔的值，其中一个值等于”val”的E元素 E[attr &#124; =val] 具有属性attr且属性值为val或以val-开始的任何元素E E[attr^=”val”] css3属性attr的值以”val”开头的元素 E[attr$=”val”] css3属性attr的值以”val”结尾的元素 E[attr*=”val”] css3属性attr的值包含”val”字符串的元素 123456p[title] &#123; color:#f00; &#125;div[class=error] &#123; color:#f00; &#125;td[headers~=col1] &#123; color:#f00; &#125;p[lang|=en] &#123; color:#f00; &#125;blockquote[class=quote][cite] &#123; color:#f00; &#125;div[id^="nav"] &#123; background:#ff0; &#125; 伪元素伪元素表示DOM外部的某种文档结构。在CSS2之前规范不明确的时候，伪元素和伪类都使用单冒号(:)来表示。而CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类。 为了兼容过去的写法，CSS3之前的伪元素仍然可以使用单冒号(:)来表示，浏览器是可以解析的。比如 :before 和 ::before 都可以被浏览器解析。但是CSS3之后出现的伪元素必须用双冒号表示，不再支持单冒号的形式。 选择器 含义 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 E::first-line 匹配E元素的第一行 E::first-letter 匹配E元素的第一个字母 ::selection 匹配突出显示的文本 ::placeholder 占位 123456789.cbb:before &#123; content:""; display:block; height:17px; &#125;a:after &#123; content: " (" attr(href) ") "; &#125;p:first-line &#123; font-weight:bold; color;#600; &#125;.preamble:first-letter &#123; font-size:1.5em; font-weight:bold; &#125; 结构伪类 选择器 含义 :root 匹配文档的根元素，对于HTML文档，就是HTML元素 E:nth-child(n) 匹配其父元素的第n个子元素E，第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素E，第一个编号为1 E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1) E:only-child 匹配父元素下唯一的子元素E，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:nth-of-type(n) 匹配其父元素的第n个E的同类型元素 E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1) E:nth-last-of-type(n) 匹配其父元素的倒数第n个E的同类型元素 E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1) E:only-of-type 匹配父元素下同E相同标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 E:not(exception) 匹配不符合not条件的E元素 12345678910111213141516171819202122p:nth-child(3) &#123; color:#f00; &#125;p:nth-child(odd) &#123; color:#f00; &#125;p:nth-child(even) &#123; color:#f00; &#125;p:nth-child(3n+0) &#123; color:#f00; &#125;p:nth-child(3n) &#123; color:#f00; &#125;tr:nth-child(2n+11) &#123; background:#ff0; &#125;tr:nth-last-child(2) &#123; background:#ff0; &#125;p:last-child &#123; background:#ff0; &#125;p:only-child &#123; background:#ff0; &#125;p:empty &#123; background:#ff0; &#125;p:not(.fancy) &#123; color: green;&#125; 状态伪类 选择器 含义 :link 未访问链接 :visited 已访问链接，一般不使用 :hover 鼠标悬停的状态，可用于任意元素，不限于链接 :active 被激活时的状态，不仅限于链接，可用于任何具有tabindex属性的元素 :focus 获得焦点时状态，不仅限于链接，可用于任何具有tabindex属性的无线 :enabled 已启用的界面元素 :disabled 已禁用的界面元素 :checked 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素 :required 应用于具有必填属性required的表单控件 :target 该选择器定位当前活动页面内定位点的目标元素 :valid： 应用于有效元素 :invalid 应用于空的必填元素，以及未能与type或pattern属性所定义的需求相匹配的元素 :read-only 应用于其内容无法供用户修改的元素 :read-write 应用于其内容可供用户修改的元素，比如输入框 :in-range 应用于具有范围限制的元素，其中该值位于限制内；比如具有min和max属性的number和range输入框； :out-of-range 与:in-range选择相反，其中该值在限制范围外 1input[type="text"]:disabled &#123; background:#ddd; &#125; 参考真正理解”CSS选择器的优先级”]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之this到底指向哪里?]]></title>
    <url>%2Fpost%2F9ed6caf6.html</url>
    <content type="text"><![CDATA[在执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象总结过了，今天就是要确定this的指向。 本文最最核心的一句话就是：this是在函数调用的时候确定的，一定要牢牢记住，其次，在函数执行过程中，this一旦被确定，就不可更改了。 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn()&#123; this= obj; // 这句话试图修改this，运行后会报错 console.log(this.a);&#125;fn(); this是什么重点：this是一个对象，是对象和函数之间达成关联关系的纽带，是在函数调用的时候确定。 怎么确定this的指向因为this是在函数调用的时候确定的，所以this的指向是很灵活的，所以很多人对this的指向总是似懂非懂。那么这里可以告诉大家一个套路，也是本文唯一的套路，按照这个套路走，以后this的问题再也难不倒你了。 当你不能确定this指向哪里的时候，尝试把函数的调用转换为 call/apply 的形式，call/apply 的第一个参数就是this的指向！ call/apply手动指定thiscall/apply可以自行手动设置this的指向。所有的函数都具有着两个方法，它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。call/apply的具体使用这里就不讲了，如果不熟悉call/apply的用法 送你传送门 12345678function fn(param) &#123; console.log(this.a,param);&#125;var obj = &#123; a: "我是this的属性a"&#125;fn.call(obj,"我是参数param"); // 我是this的属性a 我是参数param call/apply第一个参数如果传入的是简单数据类型，会被自动包装为对象 123456function f()&#123; console.log(this)&#125;f.call(10); // Number &#123;10&#125;f.call(true); // Boolean &#123;true&#125;f.call("str"); // String &#123;"str"&#125; call/apply第一个参数如果没传，或者传入的是null/undefined的时候，this的指向跟是否在严格模式下有关。 非严格模式下，this指向全局对象（浏览器是window）。 123456function f()&#123; console.log(this)&#125;f.call(); // Window &#123;postMessage: ƒ,...&#125;f.call(null); // Window &#123;postMessage: ƒ,...&#125;f.call(undefined); // Window &#123;postMessage: ƒ,...&#125; 严格模式下，this指向null/undefined 12345678"use strict"function f()&#123; console.log(this)&#125;f.call(); // undefinedf.call(null); // nullf.call(undefined); // undefined 几个栗子只要掌握call/apply，结合是否严格模式，你就会发现虚无缥缈的this已经有迹可循了，下面例子中的函数调用代码都可以通过转换的call模式代码直接替换。 纯粹的函数调用 1234567891011121314151617181920// 非严格模式var x = 1;function test() &#123; console.log(this.x);&#125;// 在心里将test()翻译为call模式，test.call(),非严格模式// 所以this===window，所以输出window.xtest(); // 1// 严格模式"use strict"var x = 1;function test() &#123; console.log(this.x);&#125;// 在心里将test()翻译为call模式，test.call(),严格模式// 所以this===undefined，所以输出window.xtest(); // Uncaught TypeError: Cannot read property 'x' of undefined 作为对象方法的调用 12345678910function test() &#123; console.log(this.x);&#125;var obj = &#123; x:3, m:test&#125;;// 在心里将test()翻译为call模式，obj.m.call(obj)，这时this===obj，所以输出obj.xobj.m(); // 3 作为构造函数调用, this就指向构造出来的新对象 12345678function Test() &#123; this.x = 3;&#125;// 在心里将test()翻译为call模式// var obj = &#123;&#125;; Test.call(obj); // 这时this===obj，所以输出obj.xvar obj = new Test();obj.x; // 3 通过call/apply改变this指向，将类数组对象转换为数组, 12345678910111213141516function exam(a, b, c, d, e) &#123; // 先看看函数的自带属性 arguments 什么是样子的 console.log(arguments); // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变 var arg = [].slice.call(arguments); console.log(arg);&#125;exam(2, 8, 9, 10, 3);// &#123; &apos;0&apos;: 2, &apos;1&apos;: 8, &apos;2&apos;: 9, &apos;3&apos;: 10, &apos;4&apos;: 3 &#125;// [ 2, 8, 9, 10, 3 ]// 也常常使用该方法将DOM中的nodelist转换为数组// [].slice.call( document.getElementsByTagName(&apos;li&apos;) ); 根据自己的需要灵活修改this指向 12345678910var foo = &#123; name: 'joker', showName: function() &#123; console.log(this.name); &#125;&#125;var bar = &#123; name: 'rose'&#125;foo.showName.call(bar); 总结我们可以将平时通过括号、通过.、通过new去使用函数的方式，看做是call/apply的语法糖，是简写版，想要深入理解函数的调用，就要学好call。关于this的部分已经总结完了，希望这篇文章有助于你准确的理解this关键字，能够真正学到东西。 参考this 的值到底是什么？一次说清楚你怎么还没搞懂 this？JS 的 new 到底是干什么的？Javascript 的 this 用法全方位解读this]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续更新之文章链接列表]]></title>
    <url>%2Fpost%2F7a2a665d.html</url>
    <content type="text"><![CDATA[webpack用 webpack 实现持久化缓存手摸手，带你用合理的姿势使用webpack4（下）Webpack 中的 sideEffects 到底该怎么用？ babel7印记中文之babel7Babel 7 于今天发布[译] Babel 7.0 带来的很酷的事情babel 7 教程babel到底该如何配置？一口(很长的)气了解 babel 彻底理解浏览器的缓存机制JavaScript运行机制深入浅出学习 JavaScript Class(类) 中的 Private(私有) 和 Public(公有) 属性【译】JS新语法：私有属性 在行在行–张克军 使用pkg打包Node.js应用手机上也可以愉快地搞nodejs开发基于webpack4制作项目开发的demo配置(含babel、less等常用开发插件) bind vs currybind vs curry 212345678910111213function curry(fn) &#123; var argus= Array.prototype.slice.call(arguments,1); return function()&#123; var _argus = argus.concat([...arguments]); if(_argus.length &gt;= fn.length)&#123; // 参数收集完毕，执行 return fn.apply(null,_argus); &#125; var fn2 = fn.bind(null,..._argus) // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 return curry(fn2); &#125;&#125;]]></content>
      <tags>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之详解变量对象]]></title>
    <url>%2Fpost%2Fd3a3d138.html</url>
    <content type="text"><![CDATA[在javascript笔记之JS解释执行过程里说过，当函数准备执行的时候，创建了执行上下文，执行上下文（Execute Context）有创建（预编译）和执行两个阶段，在创建阶段做了三件事创建变量对象（Variable Object）、建立作用域链（Scope Chain）、确定this指向（this value），也就是说一个执行上下文的数据结构应该是这样的： 12345EC=&#123; VO: &#123;&#125;, scopeChain:&#123;&#125;, thisValue:&#123;&#125;&#125;; 今天先来重点了解一下变量对象(VO)，其他两个先不关注。 变量对象的定义在我们的程序中会定义很多变量和函数，那么对于解释器来说，它是从哪里找到这些变量和函数的？是的，就是变量对象中。 变量对象（variable object，缩写为VO）是一个抽象的概念，指代与执行上下文相关的特殊对象，是在函数被调用，但是尚未执行的时刻被创建的，这个创建变量对象的过程实际就是函数内数据(函数参数、内部变量、内部函数)初始化的过程。 也就是说变量对象里包含了函数内部的一下内容： 内部变量（variables） 内部函数（functions） 参数列表（arguments） VO就是执行上下文的一个属性,从数据结构上来说，应该VO是这样的： 1234567VO = &#123; arguments:&#123;&#125;, variable1:undefined, variable2:undefined, functionName1:&lt;Function Reference&gt;, functionName2:&lt;Function Reference&gt;,&#125; 为了更好的理解变量对象，下面通过一个例子来探讨下。 1234567891011121314151617function test(a) &#123; var b = 2; console.log(foo()); function foo() &#123; return "function foo"; &#125; var bar = function()&#123;&#125;; b = 3; var foo = "foo"; console.log(foo);&#125;test(1); 根据执行上下文的两个阶段，test函数的执行顺序为： 123456789101112131415161718192021222324// 1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。arguments=&#123; 0: 1, length: 1, //...&#125;// 2. 将所有函数声明放入变量对象中function foo() &#123; return "function foo";&#125;// 3. 将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时不会有undefined的赋值var a = undefined;var b = undefined;var bar = undefined;// 执行阶段需要执行的代码a=1;b=2;console.log(foo());bar = function()&#123;&#125;;b = 3;foo = "foo";console.log(foo); 通过上面的分析，也就清楚了为什么会有变量提升，这时候的test函数的VO是这样的： 12345678910VO = &#123; arguments:&#123; 0: 1, length: 1 &#125;, a:undefined, b:undefined, foo: &lt;bar reference&gt; ,// 表示foo的地址引用 bar: undefined&#125; 全局上下文中的变量对象 全局对象（Global object）是在进入任何执行上下文之前就已经创建了的对象；这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。 我们上面说的都是函数上下文中的变量对象，是根据执行上下文中的数据（参数、变量、函数）确定其内容的，是不能直接访问VO对象的，因为它只是内部机制的一个实现。 全局上下文中的变量对象则有所不同。以浏览器为例，全局变量对象是window对象，全局上下文在执行前的初始化阶段，全局变量、函数都被挂载在window上。因此全局上下文的变量对象可以通过VO的属性名称来间接访问，而其它上下文不行。 eval的上下文也有所不同，因为eval基本不被使用，忽略 12345678910111213// 以浏览器中为例，全局对象为window// 全局上下文windowEC = &#123; Window: &#123; Math: &lt;...&gt;, String: &lt;...&gt;, //... //... &#125;, VO: Window, scopeChain: &#123;&#125;, this: Window&#125; 活动对象前面我们说过执行上下文有创建和执行两个阶段，当创建阶段后，就进入了执行阶段。在未进入执行阶段之前，变量对象中的属性都是不能访问！但是进入执行阶段之后，变量对象转变为了活动对象(active object，缩写为AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。所以活动对象实际就是变量对象在真正执行时的另一种形式。 如果面试的时候被问到变量对象和活动对象有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。 总结在这篇文章里，我们深入学习了跟执行上下文相关的变量对象。通过理解变量对象的创建过程，就是明白解释器是怎么去查找变量和函数，代码的执行顺序是怎样的，也就知道为什么会有变量提升了。 参考变量对象详解变量对象]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom中append、appendChild和innerHTML的区别]]></title>
    <url>%2Fpost%2Fa280f2c0.html</url>
    <content type="text"><![CDATA[appendChildNode.appendChild方法将一个节点添加到指定父节点的子节点列表末尾，只能传一个节点，且不直接支持传字符串，返回追加的 Node 节点； 若需要添加一个字符串，需要使用document.createTextElement(字符串)先创建文本节点，然后再添加创建的文本节点。 若被插入的节点已经存在于当前文档的文档树中,则那个节点会首先从原先的位置移除,然后再插入到新的位置。 若需要保留这个子节点在原先位置的显示,则你需要先用Node.cloneNode方法复制出一个节点的副本,然后在插入到新位置. 这个方法只能将某个子节点插入到同一个文档的其他位置,如果你想跨文档插入,你需要先调用document.importNode方法. 123// 创建一个新的段落p元素,然后添加到body的最尾部var p = document.createElement("p");document.body.appendChild(p); appendParentNode.append 方法在 ParentNode的最后一个子节点之后插入一组 Node 对象或 DOMString 对象。被插入的 DOMString 对象等价为 Text 节点。 与 Node.appendChild() 的差异： ParentNode.append()允许追加 DOMString 对象，而 Node.appendChild() 只接受 Node 对象。 ParentNode.append() 没有返回值，而 Node.appendChild() 返回追加的 Node 对象。 ParentNode.append() 可以追加几个节点和字符串，而 Node.appendChild() 只能追加一个节点。 浏览器支持： chrome 54+ ie 9+ firefox 49+ 插入一个元素节点12345var parent = document.createElement("div");var p = document.createElement("p");parent.append(p);console.log(parent.childNodes); // NodeList [ &lt;p&gt; ] 插入文本1234var parent = document.createElement("div");parent.append("Some domString"," ","Some text");console.log(parent.textContent); // "Some domString Some text" innerHTML 添加的是纯字符串，不能获取内部元素的属性； 不同于 appendChild 添加到的是 dom 对象，返回的也是 dom 对象，可以通过 dom 对象访问获取元素的各种属性。 性能待完善]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之理解执行上下文]]></title>
    <url>%2Fpost%2F8d875b1e.html</url>
    <content type="text"><![CDATA[每次当控制器转到ECMAScript可执行代码的时候，即会进入到一个执行上下文。执行上下文(简称-EC)是ECMA-262标准里的一个抽象概念，用于同可执行代码(executable code)概念进行区分。标准规范没有从技术实现的角度定义EC的准确类型和结构，这应该是具体实现ECMAScript引擎时要考虑的问题。 调用栈（活动的执行上下文组）在逻辑上组成一个堆栈。堆栈底部永远都是全局上下文(global context)，而顶部就是当前（活动的）执行上下文。堆栈在EC类型进入和退出上下文的时候被修改（推入或弹出）。 本来想写一篇关于执行上下文和调用栈的内容，在简书上看到了波神写的一篇博文，讲的特别清楚，我就不献丑了，链接在这里我是传送门，拿去不谢。 特别注意：调用栈和作用域链没有关系，作用域链是由函数所在的位置确定的，而调用栈是函数执行的时候确定的，代码位置和执行位置，可能隔着十万八千里。 自己一点理解，因为JavaScript单线程的特性，为了保证程序在函数执行完成以后，能够回到原来的地方继续执行，程序需要记住当前的位置，这个记住当前的位置的过程，就是将当前位置放入调用栈，当执行完成，并且没有形成闭包时，弹出调用栈。 下面三个链接，可以通过动画的方式，很直观的看到调用栈的整个过程。 普通调用 1+1+1 嵌套调用 1&gt;2&gt;3 递归]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]总结伪类与伪元素]]></title>
    <url>%2Fpost%2F6f6a2b64.html</url>
    <content type="text"><![CDATA[原文地址： http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/ 伪类与伪元素先说一说为什么css要引入伪元素和伪类，以下是css2.1 Selectors章节中对伪类与伪元素的描述： CSS introduces the concepts of pseudo-elements and pseudo-classes to permit formatting based on information that lies outside the document tree. 直译过来就是：css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释： 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。 伪类与伪元素的区别这里通过两个例子来说明两者的区别。 下面是一个简单的html列表片段：1234&lt;ul&gt; &lt;li&gt;我是第一个&lt;/li&gt; &lt;li&gt;我是第二个&lt;/li&gt;&lt;/ul&gt; 如果想要给第一项添加样式，可以在为第一个添加一个类，并在该类中定义对应样式： 尽量少使用层级关系 123456789&lt;style&gt;li.first-item &#123; color: orange&#125;&lt;/style&gt;&lt;ul&gt; &lt;li class="first-item"&gt;我是第一个&lt;/li&gt; &lt;li&gt;我是第二个&lt;/li&gt;&lt;/ul&gt; 如果不用添加类的方法，我们可以通过给设置第一个的:first-child伪类来为其添加样式。这个时候，被修饰的元素依然处于文档树中。123456789&lt;style&gt;li:first-child &#123; color: orange&#125;&lt;/style&gt;&lt;ul&gt; &lt;li class="first-item"&gt;我是第一个&lt;/li&gt; &lt;li&gt;我是第二个&lt;/li&gt;&lt;/ul&gt; 下面是另一个简单的html段落片段：1&lt;p&gt;Hello World, and wish you have a good day!&lt;/p&gt; 如果想要给该段落的第一个字母添加样式，可以在第一个字母中包裹一个元素，并设置该span元素的样式：1234&lt;p&gt; &lt;span class="first"&gt;H&lt;/span&gt; ello World, and wish you have a good day!&lt;/p&gt; 如果不创建一个元素，我们可以通过设置的:first-letter伪元素来为其添加样式。这个时候，看起来好像是创建了一个虚拟的元素并添加了样式，但实际上文档树中并不存在这个元素。1234567&lt;style&gt;p:first-letter &#123; font-size: 5em;&#125;&lt;/style&gt;&lt;p&gt;Hello World, and wish you have a good day!&lt;/p&gt; 从上述例子中可以看出，伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。 伪元素是使用单冒号还是双冒号？CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号(::)，:hover和:active等伪类使用单冒号(:)。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号(::)表示方法。 然而，除了少部分伪元素，如::backdrop必须使用双冒号，大部分伪元素都支持单冒号和双冒号的写法，比如::after，写成:after也可以正确运行。对于伪元素是使用单冒号还是双冒号的问题，w3c标准中的描述如下： Please note that the new CSS3 way of writing pseudo-elements is to use a double colon, eg a::after { … }, to set them apart from pseudo-classes. You may see this sometimes in CSS. CSS3 however also still allows for single colon pseudo-elements, for the sake of backwards compatibility, and we would advise that you stick with this syntax for the time being. 大概的意思就是：虽然CSS3标准要求伪元素使用双冒号的写法，但也依然支持单冒号的写法。为了向后兼容，我们建议你在目前还是使用单冒号的写法。如果是移动端那就无所谓了 后记某些伪类或伪元素仍然处于试验阶段，在使用前建议先在Can I Use等网站查一查其浏览器兼容性。处于试验阶段的伪类或伪元素会在标题中标注。]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>html/css</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可爱的webstorm]]></title>
    <url>%2Fpost%2F2503a2de.html</url>
    <content type="text"><![CDATA[侧边栏如何出现npm选项卡如果你的项目里面有 package.json，直接在 package.json 上面点右键Show npm Scripts，就会有 npm 的选项卡了。同理，代码里面有 gulp 或 grunt 的配置文件也是一样的操作。 代码地图插件在设置-&gt;plugin查找CodeGlance并安装 多行编辑 方式一： webstorm多点编辑，一般是 按住 alt 键，再用鼠标单击需要添加内容的部位。 方式二：首先选中需要修改内容的段落，然后按快捷键 shift + alt + insert，接下来就只需要用方向键来调整位置。 方式三： 首先选中需要修改内容的段落，然后右键，选择Column Section Mode，接下来就只需要用方向键来调整位置。 对选中的内容添加双引号、单引号、中括号、大括号、小括号Editer –&gt; General –&gt; Smart Keys, 勾选Surfound selection on typing quote or brace 未保存的文件显示星号Editor –&gt; General –&gt; Editor Tabs 勾选 Mark modified (*) 自动保存 代码超过一行的时候，会出现横向滚动条，设置换行及缩进在编辑界面左边的行号上右键 选择 Soft-Wrap Current Files是仅对当前文件启用换行， 选择 Soft-Wrap All Files 启用全局的配置，相当于下面图片上的修改方式。]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新单位vw、vh、vmin、vmax的使用详解]]></title>
    <url>%2Fpost%2F4dcb0c22.html</url>
    <content type="text"><![CDATA[基本说明vw、vh、vmin、vmax 的含义（1）vw、vh、vmin、vmax 是一种视窗单位，也是相对单位。它相对的不是父节点或者页面的根节点。而是由视窗（Viewport）大小来决定的，单位 1，代表类似于 1%。视窗（Viewport）是你的浏览器实际显示内容的区域—，换句话说是你的不包括工具栏和按钮的网页浏览器。 （2）具体描述如下：vw：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）vh：视窗高度的百分比vmin：当前 vw 和 vh 中较小的一个值vmax：当前 vw 和 vh 中较大的一个值 vw、vh 与 % 百分比的区别（1）% 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的。（2）vw、vh 优势在于能够直接获取高度，而用 % 在没有设置 body 高度的情况下，是无法正确获得可视区域的高度的，所以这是挺不错的优势。 vmin、vmax 用处做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。 浏览器兼容性（1）桌面 PCChrome：自 26 版起就完美支持（2013年2月）Firefox：自 19 版起就完美支持（2013年1月）Safari：自 6.1 版起就完美支持（2013年10月）Opera：自 15 版起就完美支持（2013年7月）IE：自 IE10 起（包括 Edge）到现在还只是部分支持（不支持 vmax，同时 vm 代替 vmin） （2）移动设备Android：自 4.4 版起就完美支持（2013年12月）iOS：自 iOS8 版起就完美支持（2014年9月） 参考http://www.hangge.com/blog/cache/detail_1715.html]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]CSS Modules 详解及 React 中实践]]></title>
    <url>%2Fpost%2Fc37c88ce.html</url>
    <content type="text"><![CDATA[原文地址 CSS 模块化的解决方案有很多，但主要有两类。一类是彻底抛弃 CSS，使用 JS 或 JSON 来写样式。Radium，jsxstyle，react-style 属于这一类。优点是能给 CSS 提供 JS 同样强大的模块化能力；缺点是不能利用成熟的 CSS 预处理器（或后处理器） Sass/Less/PostCSS，:hover 和 :active 伪类处理起来复杂。另一类是依旧使用 CSS，但使用 JS 来管理样式依赖，代表是 CSS Modules。CSS Modules 能最大化地结合现有 CSS 生态和 JS 模块化能力，API 简洁到几乎零学习成本。发布时依旧编译出单独的 JS 和 CSS。它并不依赖于 React，只要你使用 Webpack，可以在 Vue/Angular/jQuery 中使用。是我认为目前最好的 CSS 模块化解决方案。近期在项目中大量使用，下面具体分享下实践中的细节和想法。 CSS 模块化遇到了哪些问题？CSS 模块化重要的是要解决好两个问题：CSS 样式的导入和导出。灵活按需导入以便复用代码；导出时要能够隐藏内部作用域，以免造成全局污染。Sass/Less/PostCSS 等前仆后继试图解决 CSS 编程能力弱的问题，结果它们做的也确实优秀，但这并没有解决模块化最重要的问题。Facebook 工程师 Vjeux 首先抛出了 React 开发中遇到的一系列 CSS 相关问题。加上我个人的看法，总结如下： 全局污染 CSS 使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的样式都是全局生效，样式可能被错误覆盖，因此产生了非常丑陋的 !important，甚至 inline !important 和复杂的选择器权重计数表，提高犯错概率和使用成本。Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它的做法有点极端，样式彻底局部化，造成外部无法重写样式，损失了灵活性。 命名混乱 由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复杂，容易形成不同的命名风格，很难统一。样式变多后，命名将更加混乱。 依赖管理不彻底 组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样式。但现在的做法是除了要引入 JS，还要再引入它的 CSS，而且 Saas/Less 很难实现对每个组件都编译出单独的 CSS，引入所有模块的 CSS 又造成浪费。JS 的模块化已经非常成熟，如果能让 JS 来管理 CSS 依赖是很好的解决办法。Webpack 的 css-loader 提供了这种能力。 无法共享变量 复杂组件要使用 JS 和 CSS 来共同处理样式，就会造成有些变量在 JS 和 CSS 中冗余，Sass/PostCSS/CSS 等都不提供跨 JS 和 CSS 共享变量这种能力。 代码压缩不彻底 由于移动端网络的不确定性，现在对 CSS 压缩已经到了变态的程度。很多压缩工具为了节省一个字节会把 ‘16px’ 转成 ‘1pc’。但对非常长的 class 名却无能为力，力没有用到刀刃上。 上面的问题如果只凭 CSS 自身是无法解决的，如果是通过 JS 来管理 CSS 就很好解决，因此 Vjuex 给出的解决方案是完全的 CSS in JS，但这相当于完全抛弃 CSS，在 JS 中以 Object 语法来写 CSS，估计刚看到的小伙伴都受惊了。直到出现了 CSS Modules。 CSS Modules 模块化方案CSS Modules 内部通过 ICSS 来解决样式导入和导出这两个问题。分别对应 :import 和 :export 两个新增的伪类。 12345678:import("path/to/dep.css") &#123; localAlias: keyFromDep; /* ... */&#125;:export &#123; exportedKey: exportedValue; /* ... */&#125; 但直接使用这两个关键字编程太麻烦，实际项目中很少会直接使用它们，我们需要的是用 JS 来管理 CSS 的能力。结合 Webpack 的 css-loader 后，就可以在 CSS 中定义样式，在 JS 中导入。 启用 CSS Modules12// webpack.config.jscss?modules&amp;localIdentName=[name]__[local]-[hash:base64:5] 加上 modules 即为启用，localIdentName 是设置生成样式的命名规则。 123/* components/Button.css */.normal &#123; /* normal 相关的所有样式 */ &#125;.disabled &#123; /* disabled 相关的所有样式 */ &#125; 123456/* components/Button.js */import styles from './Button.css';console.log(styles);buttonElem.outerHTML = `&lt;button class=$&#123;styles.normal&#125;&gt;Submit&lt;/button&gt;` 生成的 HTML 是1&lt;button class="button--normal-abc53"&gt;Submit&lt;/button&gt; 注意到 button--normal-abc53 是 CSS Modules 按照 localIdentName 自动生成的 class 名。其中的 abc53是按照给定算法生成的序列码。经过这样混淆处理后，class 名基本就是唯一的，大大降低了项目中样式覆盖的几率。同时在生产环境下修改规则，生成更短的 class 名，可以提高 CSS 的压缩率。 上例中 console 打印的结果是： 1234Object &#123; normal: 'button--normal-abc53', disabled: 'button--disabled-def884',&#125; CSS Modules 对 CSS 中的 class 名都做了处理，使用对象来保存原 class 和混淆后 class 的对应关系。 通过这些简单的处理，CSS Modules 实现了以下几点： 所有样式都是 local 的，解决了命名冲突和全局污染问题 class 名生成规则配置灵活，可以此来压缩 class 名 只需引用组件的 JS 就能搞定组件所有的 JS 和 CSS 依然是 CSS，几乎 0 学习成本 样式默认局部使用了 CSS Modules 后，就相当于给每个 class 名外加加了一个 :local，以此来实现样式的局部化，如果你想切换到全局模式，使用对应的 :global。1234567891011121314151617181920212223.normal &#123; color: green;&#125;/* 以上与下面等价 */:local(.normal) &#123; color: green; &#125;/* 定义全局样式 */:global(.btn) &#123; color: red;&#125;/* 定义多个全局样式 */:global &#123; .link &#123; color: green; &#125; .box &#123; color: yellow; &#125;&#125; ### Compose 来组合样式对于样式复用，CSS Modules 只提供了唯一的方式来处理：composes 组合 123456789101112/* components/Button.css */.base &#123; /* 所有通用的样式 */ &#125;.normal &#123; composes: base; /* normal 其它样式 */&#125;.disabled &#123; composes: base; /* disabled 其它样式 */&#125; 123import styles from './Button.css';buttonElem.outerHTML = `&lt;button class=$&#123;styles.normal&#125;&gt;Submit&lt;/button&gt;` 生成的 HTML 变为 1&lt;button class="button--base-daf62 button--normal-abc53"&gt;Submit&lt;/button&gt; 由于在 .normal 中 composes 了 .base，编译后会 normal 会变成两个 class。 composes 还可以组合外部文件中的样式。12345678910111213/* settings.css */.primary-color &#123; color: #f40;&#125;/* components/Button.css */.base &#123; /* 所有通用的样式 */ &#125;.primary &#123; composes: base; composes: primary-color from './settings.css'; /* primary 其它样式 */&#125; 对于大多数项目，有了 composes 后已经不再需要 Sass/Less/PostCSS。但如果你想用的话，由于 composes 不是标准的 CSS 语法，编译时会报错。就只能使用预处理器自己的语法来做样式复用了。 class 命名技巧CSS Modules 的命名规范是从 BEM 扩展而来。BEM 把样式名分为 3 个级别，分别是： Block：对应模块名，如 Dialog Element：对应模块中的节点名 Confirm Button Modifier：对应节点相关的状态，如 disabled、highlight综上，BEM 最终得到的 class 名为 dialog__confirm-button--highlight。使用双符号 __ 和 -- 是为了和区块内单词间的分隔符区分开来。虽然看起来有点奇怪，但 BEM 被非常多的大型项目和团队采用。我们实践下来也很认可这种命名方法。 CSS Modules 中 CSS 文件名恰好对应 Block 名，只需要再考虑 Element 和 Modifier。BEM 对应到 CSS Modules 的做法是： 123/* .dialog.css */.ConfirmButton--disabled &#123;&#125; 你也可以不遵循完整的命名规范，使用 camelCase 的写法把 Block 和 Modifier 放到一起： 123/* .dialog.css */.disabledConfirmButton &#123;&#125; 如何实现CSS，JS变量共享 注：CSS Modules 中没有变量的概念，这里的 CSS 变量指的是 Sass 中的变量。 上面提到的 :export 关键字可以把 CSS 中的 变量输出到 JS 中。下面演示如何在 JS 中读取 Sass 变量：123456/* config.scss */$primary-color: #f40;:export &#123; primaryColor: $primary-color;&#125; 12345/* app.js */import style from 'config.scss';// 会输出 #F40console.log(style.primaryColor); CSS Modules 使用技巧CSS Modules 是对现有的 CSS 做减法。为了追求简单可控，作者建议遵循如下原则： 不使用选择器，只使用 class 名来定义样式 不层叠多个 class，只使用一个 class 把所有样式定义好 所有样式通过 composes 组合来实现复用 不嵌套 上面两条原则相当于削弱了样式中最灵活的部分，初使用者很难接受。第一条实践起来难度不大，但第二条如果模块状态过多时，class 数量将成倍上升。 一定要知道，上面之所以称为建议，是因为 CSS Modules 并不强制你一定要这么做。听起来有些矛盾，由于多数 CSS 项目存在深厚的历史遗留问题，过多的限制就意味着增加迁移成本和与外部合作的成本。初期使用中肯定需要一些折衷。幸运的是，CSS Modules 这点做的很好： 如果我对一个元素使用多个 class 呢？ 没问题，样式照样生效。 如何我在一个 style 文件中使用同名 class 呢？ 没问题，这些同名 class 编译后虽然可能是随机码，但仍是同名的。 如果我在 style 文件中使用伪类，标签选择器等呢？ 没问题，所有这些选择器将不被转换，原封不动的出现在编译后的 css 中。也就是说 CSS Modules 只会转换 class 名和 id 选择器名相关的样式。 但注意，上面 3 个“如果”尽量不要发生。 CSS Modules 结合 React 实践在 className 处直接使用 css 中 class 名即可。 1234/* dialog.css */.root &#123;&#125;.confirm &#123;&#125;.disabledConfirm &#123;&#125; 12345678910111213141516import classNames from 'classnames';import styles from './dialog.css';export default class Dialog extends React.Component &#123; render() &#123; const cx = classNames(&#123; [styles.confirm]: !this.state.disabled, [styles.disabledConfirm]: this.state.disabled &#125;); return &lt;div className=&#123;styles.root&#125;&gt; &lt;a className=&#123;cx&#125;&gt;Confirm&lt;/a&gt; ... &lt;/div&gt; &#125;&#125; 注意，一般把组件最外层节点对应的 class 名称为 root。这里使用了 classnames 库来操作 class 名。如果你不想频繁的输入 styles.**，可以试一下 react-css-modules，它通过高阶函数的形式来避免重复输入 styles.**。 CSS Modules 结合历史遗留项目实践好的技术方案除了功能强大炫酷，还要能做到现有项目能平滑迁移。CSS Modules 在这一点上表现的非常灵活。 外部如何覆盖局部样式当生成混淆的 class 名后，可以解决命名冲突，但因为无法预知最终 class 名，不能通过一般选择器覆盖。我们现在项目中的实践是可以给组件关键节点加上 data-role 属性，然后通过属性选择器来覆盖样式。 如12345// dialog.jsreturn &lt;div className=&#123;styles.root&#125; data-role='dialog-root'&gt; &lt;a className=&#123;styles.disabledConfirm&#125; data-role='dialog-confirm-btn'&gt;Confirm&lt;/a&gt; ...&lt;/div&gt; 1234// dialog.css[data-role="dialog-root"] &#123; // override style&#125; 因为 CSS Modules 只会转变类选择器，所以这里的属性选择器不需要添加 :global。 如何与全局样式共存前端项目不可避免会引入 normalize.css 或其它一类全局 css 文件。使用 Webpack 可以让全局样式和 CSS Modules 的局部样式和谐共存。下面是我们项目中使用的 webpack 部分配置代码： 1234567891011121314module: &#123; loaders: [&#123; test: /\.jsx?$/, loader: 'babel' &#125;, &#123; test: /\.scss$/, exclude: path.resolve(__dirname, 'src/styles'), loader: 'style!css?modules&amp;localIdentName=[name]__[local]!sass?sourceMap=true' &#125;, &#123; test: /\.scss$/, include: path.resolve(__dirname, 'src/styles'), loader: 'style!css!sass?sourceMap=true' &#125;]&#125; 1234567/* src/app.js */import './styles/app.scss';import Component from './view/Component'/* src/views/Component.js */// 以下为组件相关样式import './Component.scss'; 目录结构如下：12345678src├── app.js├── styles│ ├── app.scss│ └── normalize.scss└── views ├── Component.js └── Component.scss 这样所有全局的样式都放到 src/styles/app.scss 中引入就可以了。其它所有目录包括 src/views 中的样式都是局部的。 总结CSS Modules 很好的解决了 CSS 目前面临的模块化难题。支持与 Sass/Less/PostCSS 等搭配使用，能充分利用现有技术积累。同时也能和全局样式灵活搭配，便于项目中逐步迁移至 CSS Modules。CSS Modules 的实现也属轻量级，未来有标准解决方案后可以低成本迁移。如果你的产品中正好遇到类似问题，非常值得一试。]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>转载</tag>
        <tag>webpack</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React文档阅读笔记]]></title>
    <url>%2Fpost%2F760f092a.html</url>
    <content type="text"><![CDATA[组件props 被用来在组件之间传递数据，是不可以变的，也不应该被改变。 组件属性React DOM 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。比如 class 变成了 className，而 tabindex 则对应着 tabIndex。 可以传递任何字符串常量或者{}包裹的JavaScript表达式作为属性值。当传递一个字符串常量时，该值会被解析为HTML非转义字符串，&lt;MyComponent message=&quot;&amp;lt;3&quot; /&gt;和&lt;MyComponent message={&quot;&lt;3&quot;} /&gt;是等价的 如果没有给属性传值，它默认为 true。因此下面两种用法是等价的：&lt;MyTextBox autocomplete /&gt;和&lt;MyTextBox autocomplete={true} /&gt;，不建议使用默认值，应该显式指定。 组件属性中的的 key 和 ref 不会出现在 props 中， 如果组件中需要使用与key相同的值，可以通过自定义属性传递。 组件的 key 可以在某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此在渲染一组组件的时候，应当给数组中的每一个元素赋予唯一的标识，这个表示在这一组元素中应该是独一无二的。 123456const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt;); 组件的渲染React 组件都是 immutable 不可变的。当元素被创建之后，你是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子。即便我们每秒都创建了一个描述整个UI树的新元素，React DOM 也只会更新渲染文本节点中发生变化的内容。 false、null、undefined 和 true 作为子组件的时候，它们不会直接被渲染。下面的表达式是等价的：123456&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; 通过这个特性，我们可以对 React 组件进行条件渲染，写出如下的代码：123&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125;&lt;/div&gt; 需要注意的是，上面的代码在showHeader的值为0的时候也是成立的，这时候就会渲染出0，所以在这样使用的时候，要确保 &amp;&amp; 前面的表达式始终为布尔值 如果需要类似false、null、undefined 和 true 可以渲染，需要转换为字符串。 事件处理在 React 中，事件绑定的是一个{}包裹起来的函数，而不是一个字符串，当需要阻止事件的默认行为时，必须明确使用preventDefault。 在 React 的事件处理中，event 对象是SyntheticEvent的实例，这是一个合成对象，它对原生的事件对象做了兼容性的封装，并拥有和原生事件对象相同的属性和方法，包括 stopPropagation() 和 preventDefault()，但是没有浏览器兼容问题。如果因为一些因素，需要底层的浏览器事件对象，只要使用nativeEvent属性就可以获取到它了。 event 对象会在事件处理函数执行完成后，对象将会被重用，并且所有属性会被置空。如果想以一个异步的方式来访问事件属性，需要调用event.persist()。这样会在池中删除合成事件，并且在用户代码中保留对事件的引用。 state 直接更新 state 不会触发重新渲染，需要通过 setState 更新 React 通过将多个 setState 调用合并成一个调用来提高性能， 所以在 setState 之后直接通过this.state.xxx获取属性值，可能不及预期。 通过 setState 传入函数的方法，可以修复 2 中的问题 1234567891011// 方法1this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;));// this.state.xxxx 可以获取预期值// 方法2this.setState(&#123; counter: prevState.counter + props.increment&#125;,()=&gt;&#123; // this.state.xxxx 可以获取预期值&#125;); 通过 setState() 单独更新一个属性的时候，React 将自动合并属性值到当前的 state。 RefsRefs 提供了一种方式，用于访问在 render 方法中创建的 DOM 节点或 React 元素。使用 ref 的时候，可以通过 defaultValue 设置定初始值。 ref的值React 会在组件加载时将 DOM 元素传入 current 属性，在卸载时则会改回 null。ref 的更新会发生在componentDidMount 或 componentDidUpdate 生命周期钩子之前。 当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref 。 当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。 你不能在函数式组件上使用 ref 属性，因为它们没有实例。但是，依然可以在函数式组件内部使用 ref , 只要它指向一个 DOM 元素或者 class 组件即可 123456789101112131415161718192021222324function CustomTextInput(props) &#123; // 这里必须声明 textInput，这样 ref 回调才可以引用它 let textInput = null; function handleClick() &#123; textInput.focus(); &#125; return ( &lt;div&gt; &lt;input type="text" ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; );&#125; 何时使用 Refs 如果可以通过声明式实现，则尽量避免使用 refs。 下面是几个适合使用 refs 的情况： 处理焦点、文本选择或媒体控制。 触发强制动画。 集成第三方 DOM 库 如何使用refs 16.3版本之后可以使用 React.createRef() 创建 refs, 通过 current 获取 123456789101112class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; click()&#123; const node = this.myRef.current; &#125; render() &#123; return &lt;div onClick=&#123;this.click&#125; ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; 回调 Refs 不同于传递 createRef() 创建的 ref 属性，你会传递一个函数。这个函数接受 React 组件的实例或 HTML DOM 元素作为参数，以存储它们并使它们能被其他地方访问。 React 将在组件挂载时将 DOM 元素传入ref 回调函数并调用，当卸载时传入 null 并调用它。ref 回调函数会在 componentDidMout 和 componentDidUpdate 生命周期函数前被调用 123456789101112131415161718192021222324252627282930313233343536373839class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = null; this.setTextInputRef = element =&gt; &#123; this.textInput = element; &#125;; this.focusTextInput = () =&gt; &#123; // 直接使用原生 API 使 text 输入框获得焦点 if (this.textInput) this.textInput.focus(); &#125;; &#125; componentDidMount() &#123; // 渲染后文本框自动获得焦点 this.focusTextInput(); &#125; render() &#123; // 使用 `ref` 的回调将 text 输入框的 DOM 节点存储到 React // 实例上（比如 this.textInput） return ( &lt;div&gt; &lt;input type="text" ref=&#123;this.setTextInputRef&#125; /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.focusTextInput&#125; /&gt; &lt;/div&gt; ); &#125;&#125; String 类型的 Refs，不建议使用，已过时，并在未来可能被移除。现有代码建议使用回调函数的方式替代 字符形式的ref有个需要注意的问题是在哪里渲染，就会挂载在那个组件身上 1234567891011class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); &#125; click()&#123; const node = this.refs.ref; &#125; render() &#123; return &lt;div onClick=&#123;this.click&#125; ref="ref" /&gt;; &#125;&#125; 如果 ref 回调以内联函数的方式定义，在更新期间它会被调用两次，第一次参数是 null ，之后参数是 DOM 元素。这是因为在每次渲染中都会创建一个新的函数实例。因此，React 需要清理旧的 ref 并且设置新的。通过将 ref 的回调函数定义成类的绑定函数的方式可以避免上述问题，但是大多数情况下无关紧要。 PortalsPortals 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。12// 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或碎片。第二个参数（container）则是一个 DOM 元素。ReactDOM.createPortal(child, container) 通常讲，当你从组件的 render 方法返回一个元素，该元素仅能装配 DOM 节点中离其最近的父元素：12345678render() &#123; // React mounts a new div and renders the children into it return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; );&#125; 然而，有时候将其插入到 DOM 节点的不同位置也是有用的，对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上“跳出（break out）”其容器。例如，对话框、hovercards以及提示框： 12345678render() &#123; // React does *not* create a new div. It renders the children into `domNode`. // `domNode` is any valid DOM node, regardless of its location in the DOM. return ReactDOM.createPortal( this.props.children, domNode, );&#125; 尽管 portal 可以被放置在 DOM 树的任何地方，但在其他方面其行为和普通的 React 子节点行为一致。如上下文特性依然能够如之前一样正确地工作，无论其子节点是否是 portal，由于 portal 仍存在于 React 树中，而不用考虑其在 DOM 树中的位置。 这包含事件冒泡。一个从 portal 内部会触发的事件会一直冒泡至包含 React 树 的祖先。 受控组件在React中，&lt;input type=&quot;file&quot; /&gt; 始终是一个不受控制的组件，因为它的值只能由用户设置，而不是以编程方式设置。以下示例显示如何创建ref节点以访问提交处理程序中的文件：12345678910111213141516171819202122232425262728293031323334353637class FileInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; event.preventDefault(); alert( `Selected file - $&#123;this.fileInput.files[0].name&#125;` ); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Upload file: &lt;input type="file" ref=&#123;input =&gt; &#123; this.fileInput = input; &#125;&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt; &lt;/form&gt; ); &#125;&#125;ReactDOM.render( &lt;FileInput /&gt;, document.getElementById('root')); &lt;input type=&quot;text&quot;&gt;、 &lt;textarea&gt;, 和 &lt;select&gt; 都十分类似 - 他们都通过传入一个value属性来实现对组件的控制。 在react项目开发中，input标签经常使用onChange方法获取输入值改变state：&lt;input type=&quot;text&quot; id=&quot;redeemNum&quot; value={state.num} onChange={(e) =&gt; this.inputChange(e.target.value)}/&gt;，但是，在IE9下发现 e.target.value 取值一直为undefined。在IE中，e.target 指的是window，查阅React文档发现：对于 &lt;input&gt;和&lt;textarea&gt;，onChange通常应该用代替DOM的内置onInput事件进行处理函数。解决方法：&lt;input type=&quot;text&quot; id=&quot;redeemNum&quot; value={state.num} onInput={(e) =&gt; this.inputChange(e.target.value)}/&gt; 扩展JSXJSX是JavaScript XML的简写，本质上是React.createElement(component,props,...children)的语法糖，通过在线 Babel 编译器可以很清楚的看到JSX实现的细节。 大写开头的 JSX 标签表示一个 React 组件，小写开头的 JSX 标签表示一个 html 规范中的元素，表达式无法作为 jsx 标签出现&lt;components[props.storyType] story={props.story} /&gt;，这种是错误的 JSX 防注入攻击你可以放心地在 JSX 当中使用用户输入： 123const title = response.potentiallyMaliciousInput;// 直接使用是安全的：const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; React DOM 在渲染之前默认会 过滤 所有传入的值。它可以确保你的应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm使用不完全乱指]]></title>
    <url>%2Fpost%2Fff8acdd6.html</url>
    <content type="text"><![CDATA[配置123456789101112// 配置列表npm config list// 获取指定配置npm config get key// egnpm config get registry// 指定配置npm config set key=value// egnpm config set registry=https://registry.npm.taobao.org// 删除指定配置npm config delete key NPM依赖包版本号~和^和*的区别~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0* 这意味着安装最新版本的依赖包 推荐使用~，只会修复版本的bug，比较稳定使用^或者* ，更新后会有可能导致项目不稳定， 锁定依赖可以将需要安装的模块版本前缀默认设置成波浪号(~):1npm config set save-prefix="~" 对于那些偏执的认为任何更新（模块的行为）会破坏系统的人，可以配置npm仅安装精确版本号的模块：1npm config set save-exact true 定义默认的npm init使用 npm init 初始化一个新的项目，这个过程会提示输入很多项目的配置，并创建一个 package.json 文件。 如果不想每次开始一个新的项目都需要重新输入同样的信息，可以使用 -y 标记表示你能接受 package.json 文件的一堆默认值：1npm init -y 也可以通过config设置一些的默认值：12npm config set init.author.name &lt;name&gt;npm config set init.author.email &lt;email&gt; 安装及升级包12345678// 只安装package.json配置中的dependencies包： npm install --product// 查看可升级的包npm outdated// 查看全局可升级的包npm -g outdated // 升级包npm update [package] 也可以使用npm-check来检查npm依赖包是否有更新，错误以及不在使用的，也可以使用npm-check进行包的更新。 查看指定包的信息12345npm [show|view|info|v] &lt;package name&gt;// 所有版本信息npm info &lt;package name&gt; versions// 最新稳定版信息npm info &lt;package name&gt; versions 查看安装包版本123456// 本地包npm [list|ls|la|ll] &lt;packageName&gt; // 全局安装包npm [list|ls|la|ll] &lt;packageName&gt; -g // 通过depth限制输出的模块层级：npm [list|ls|la|ll] -g --depth=0 运行命令npm run 可以运行 package.json 中script里面的脚本。 由于 npm 脚本就是 Shell 脚本，因此可以使用 Shell 通配符。*表示任意文件名，**表示任意一层子目录12"lint": "jshint *.js""lint": "jshint **/*.js" 如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。1"test": "tap test/\*.js" 命令传参向 npm 脚本传入参数，要使用--标明。123"lint": "jshint **.js"// 向上面的npm run lint命令传入参数，必须写成下面这样npm run lint -- --reporter checkstyle &gt; checkstyle.xml 也可以在package.json里面再封装一个命令。 12"lint": "jshint **.js","lint:checkstyle": "npm run lint -- --reporter checkstyle &gt; checkstyle.xml" 命令的执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&amp;符号。 1npm run script1.js &amp; npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。 1npm run script1.js &amp;&amp; npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。 钩子npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。123"prebuild": "echo I run before the build script","build": "cross-env NODE_ENV=production webpack","postbuild": "echo I run after the build script" 用户执行npm run build的时候，会自动按照下面的顺序执行。1npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild 可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。123"clean": "rimraf ./dist &amp;&amp; mkdir dist","prebuild": "npm run clean","build": "cross-env NODE_ENV=production webpack" npm 默认提供下面这些钩子。 prepublish，postpublish preinstall，postinstall preuninstall，postuninstall preversion，postversion pretest，posttest prestop，poststop prestart，poststart prerestart，postrestart 自定义的脚本命令也可以加上pre和post钩子。比如myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。 注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5开始，prepublish将只在npm publish命令之前运行。 npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。12345678910111213const TARGET = process.env.npm_lifecycle_event;if (TARGET === 'test') &#123; console.log(`Running the test task!`);&#125;if (TARGET === 'pretest') &#123; console.log(`Running the pretest task!`);&#125;if (TARGET === 'posttest') &#123; console.log(`Running the posttest task!`);&#125; 简写命令四个常用的 npm 脚本有简写形式。 npm start是npm run start npm stop是npm run stop的简写 npm test是npm run test的简写 npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写 npm start和npm stop都比较好理解，而npm restart是一个复合命令，实际上会执行stop、restart、start三个命令，具体的执行顺序如下。 prerestart prestop stop poststop restart prestart start poststart postrestart 获取package.json配置npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。1234567&#123; "name": "foo", "version": "1.2.5", "scripts": &#123; "view": "node view.js" &#125;&#125; 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。123// view.jsconsole.log(process.env.npm_package_name); // fooconsole.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用$npm_package_name和$npm_package_version取到这两个值。 npm_package_前缀也支持嵌套的package.json字段。1234567"repository": &#123; "type": "git", "url": "xxx"&#125;,scripts: &#123; "view": "echo $npm_package_repository_type"&#125; 上面代码中，可以通过npm_package_repository_type取到repository字段的type属性。下面是另外一个例子。123"scripts": &#123; "install": "foo.js"&#125; 上面代码中npm_package_scripts_install变量的值等于foo.js。 获取全局配置npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。1"view": "echo $npm_config_tag" 注意package.json里面的config对象，可以被环境变量覆盖。12345&#123; "name" : "foo", "config" : &#123; "port" : "8080" &#125;, "scripts" : &#123; "start" : "node server.js" &#125;&#125; 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。1$ npm config set foo:port 80 最后，npm run env命令可以列出所有环境变量。 参考npm scripts 使用指南 [译]10个 NPM 使用技巧]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之Number和Math]]></title>
    <url>%2Fpost%2F474ce87a.html</url>
    <content type="text"><![CDATA[Number当运算符为减（-）、乘（*）、除（/）、取模（%）、小于（&lt;）和大于（&gt;），参与运算的分别为数字和字符串时，字符串自动转换为数字参与运算，并返回结果。字符串做自增和自减运算的时候，也会隐式尝试转换为数字。 Number.NaN 表示“非数字”（Not-A-Number） Number.isFinite() 方法用来检测传入的参数是否是一个有穷数（finite number）。全局的isFinite()函数相比，不会对参数进行强制转换 123456Number.isFinite(Infinity); // falseNumber.isFinite(NaN); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(0); // trueNumber.isFinite(2e64); // trueNumber.isFinite("121"); // false, 全局函数 isFinite('0') 会返回 true Number.isInteger() 方法用来判断给定的参数是否为整数。没有隐式转换 123456789Number.isInteger(0); // trueNumber.isInteger(1); // trueNumber.isInteger(-100000); // trueNumber.isInteger(0.1); // falseNumber.isInteger(Math.PI); // falseNumber.isInteger(Infinity); // falseNumber.isInteger(-Infinity); // falseNumber.isInteger("10"); // false Number.isNaN() 方法确定传递的值是否为NaN。和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。 12345678Number.isNaN(NaN); // trueNumber.isNaN(Number.NaN); // trueNumber.isNaN(0 / 0) // true// 下面的都返回 falseNumber.isNaN(true);Number.isNaN(null);Number.isNaN(37);Number.isNaN("37"); numObj.toFixed(digits) 方法使用定点表示法来格式化一个数，digits表示小数点后的数字个数（介于0到20之间），默认为0 该方法返回一个数值的字符串表现形式，不使用指数计数法，采用四舍五入去除多余的位数 12345678(1.23e+20).toFixed(2); // 返回 "123000000000000000000.00"(1.23e-10).toFixed(2); // 返回 "0.00"12345.6789.toFixed(); // 返回 "12346"：进行四舍五入，不包括小数部分12345.6789.toFixed(1); // 返回 "12345.7"：进行四舍五入2.34.toFixed(1); // 返回 "2.3"2.34.toFixed(6); // 返回 "2.340000"， 位数不够用0填充-2.34.toFixed(1); // 返回 -2.3 （由于操作符优先级，负数不会返回字符串）(-2.34).toFixed(1); // 返回 "-2.3" （若用括号提高优先级，则返回字符串） numObj.toPrecision(precision)以定点表示法或指数表示法表示的一个数值对象的字符串表示，四舍五入到 precision 参数指定的显示数字位数。 12345678var numObj = 5.123456;console.log("numObj.toPrecision() is " + numObj.toPrecision()); //输出 5.123456console.log("numObj.toPrecision(5) is " + numObj.toPrecision(5)); //输出 5.1235console.log("numObj.toPrecision(2) is " + numObj.toPrecision(2)); //输出 5.1console.log("numObj.toPrecision(1) is " + numObj.toPrecision(1)); //输出 5// 注意：在某些情况下会以指数表示法返回console.log((1234.5).toPrecision(2)); // "1.2e+3" numObj.toExponential(fractionDigits) 方法以指数表示法返回该数值字符串表示形式。fractionDigits可选。一个整数，用来指定小数点后有几位数字。默认情况下用尽可能多的位数来显示数字。 123456var numObj = 77.1234;alert("numObj.toExponential() is " + numObj.toExponential()); //输出 7.71234e+1alert("numObj.toExponential(4) is " + numObj.toExponential(4)); //输出 7.7123e+1alert("numObj.toExponential(2) is " + numObj.toExponential(2)); //输出 7.71e+1alert("77.1234.toExponential() is " + 77.1234.toExponential()); //输出 7.71234e+1alert("77 .toExponential() is " + 77 .toExponential()); //输出 7.7e+1 Math Math.PI 表示一个圆的周长与直径的比例，约为 3.14159： Math.max和Math.min, 如果没有参数，则结果为 -Infinity。如果有任一参数不能被转换为数值，则结果为 NaN。 123var arr = [1, 2, 3];var max = Math.max(...arr);var min = Math.min(...arr); 小数部分的操作，下面的操作都会对参数进行强制转换 Math.floor()返回一个小于等于一个给定数字的最大整数，简称向下取整 Math.ceil()返回一个大于等于一个给定数字的最大整数，简称向上取整 Math.round()返回一个四舍五入后的整数 Math.trunc()返回删除掉数字的小数部分和小数点后的数，不管参数是正数还是负数。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之ES6的Class]]></title>
    <url>%2Fpost%2Fc726a015.html</url>
    <content type="text"><![CDATA[ES6入门教程学习笔记 通过typeof xxxxClass可以得到返回值为function，但是与普通function不同的是class不存在变量提升。 只有通过static显式定义的才是class静态属性（不可枚举），只有通过this显式定义的才是实例属性，其他方法是定义在prototype上的原型方法（不可枚举，es5的实现是可枚举的） class声明的类必须使用new来调用，使用apply、call等方式调用会直接报错。 new.target返回当前紧跟在new后面的类，只可以在constructor中使用。 XXXClass.name总是返回紧跟在class关键字后面的字符，如果不存在，则返回引用变量的字面量值 class作为构造函数的语法糖，同时存在着prototype和[[proto]]两条继承线，子类原型对象（prototype）的[[proto]]指向父类的原型对象（prototype），子类的[[proto]]指向父类，通过这方式实现了子类继承父类的静态方法，子类原型对象继承了父类的原型对象。 ES6继承和ES5继承之间的区别 ES5的继承实质是先创建子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。 ES6的继承实质是通过父类的构造函数完成this的创建（super(...arguments)）,然后再用子类的构造函数修改this，所以必须先调用super，才能使用this。 继承中的super super()代表的是父类的构造函数，但是返回的是子类的实例，super()相当于Parent.prototype.constructor.call(this),作为函数super只可以用在构造函数中。 super作为对象在普通函数使用时指向父类的原型对象，super.parentMethod相当于Parent.prototype.method.call(this)，被调用函数的this指向子类实例对象。 super作为对象在静态方法使用时指向父类，super.parentParentMethod相当于Parent.method.call(this)，this指向子类。 super在普通函数中，取值或者调用函数的时候指向Parent.prototype，给属性赋值的时候，指向子类的当前实例对象this. ES6可以实现原声构造函数（Boolean/String/Number/Object/Array/Function/RegExp/Error）的继承 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 123456789101112function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;); 上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。 123456var colors = new MyArray();colors[0] = "red";colors.length // 0colors.length = 0;colors[0] // "red" 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。 ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。 1234567891011121314151617181920212223242526272829class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;var x = new VersionedArray();x.push(1);x.push(2);x // [1, 2]x.history // [[]]x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3]x.history // [[], [1, 2]]x.revert();x // [1, 2] 上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。 下面是一个自定义Error子类的例子，可以用来定制报错时的行为。 1234567891011121314151617181920212223class ExtendableError extends Error &#123; constructor(message) &#123; super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; &#125;&#125;class MyError extends ExtendableError &#123; constructor(m) &#123; super(m); &#125;&#125;var myerror = new MyError('ll');myerror.message // "ll"myerror instanceof Error // truemyerror.name // "MyError"myerror.stack// Error// at MyError.ExtendableError// ... 总结完！ 参考http://es6.ruanyifeng.com/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取屏幕宽高width(),outerWidth,innerWidth,clientWidth的区别]]></title>
    <url>%2Fpost%2Fd5bb6d22.html</url>
    <content type="text"><![CDATA[$(window).width()与$(window).height()$(window).width()与$(window).height()获得的是屏幕可视区域的宽高，不包括滚动条与工具条。12$(window).width() = width + padding$(window).height() = height + padding document.documentElement.clientWidth与document.documentElement.clientHeightdocument.documentElement.clientWidth与document.documentElement.clientHeight获得的是屏幕可视区域的宽高，不包括滚动条与工具条，跟jquery的$(window).width()与$(window).height()获得的结果是一样的。 12document.documentElement.clientWidth = width + paddingdocument.documentElement.clientHeight = height + padding window.innerWidth与window.innerHeightwindow.innerWidth与window.innerHeight获得的是可视区域的宽高，但是window.innerWidth宽度包含了纵向滚动条的宽度，window.innerHeight高度包含了横向滚动条的高度。 IE 8 及更早 IE版本不支持这两个属性。 12window.innerWidth = width + padding + border + 纵向滚动条宽度window.innerHeight = height + padding + border + 横向滚动条高度 window.outerWidth与window.outerHeightwindow.outerWidth与window.outerHeight获得的是加上工具条与滚动条窗口的宽度与高度。12window.outerWidth = width + padding + border + 纵向滚动条宽度window.outerHeight = height + padding + border + 横向滚动条高度 + 工具条高度 document.body.clientWidth与document.body.clientHeightdocument.body.clientWidth获得的也是可视区域的宽度，但是document.body.clientHeight获得的是body内容的高度，如果内容只有200px，那么这个高度也是200px,如果想通过它得到屏幕可视区域的宽高，需要样式设置，如下： 12345678body &#123; height: 100%; overflow: hidden;&#125;body, div, p, ul &#123; margin: 0; padding: 0;&#125; offsetWidth &amp; offsetHeight返回内容的宽高 + padding + border + 滚动条 offsetLeft &amp; offsetTop所有HTML元素拥有offsetLeft和offsetTop属性来返回元素的X和Y坐标 1.相对于已定位元素的后代元素和一些其他元素（表格单元），这些属性返回的坐标是相对于祖先元素 2.一般元素，则是相对于文档，返回的是文档坐标 offsetParent属性指定这些属性所相对的父元素，如果offsetParent为null，则这些属性都是文档坐标 12345678910111213//用offsetLeft和offsetTop来计算e的位置function getElementPosition(e)&#123; var x = 0,y = 0; while(e != null) &#123; x += e.offsetLeft; y += e.offsetTop; e = e.offsetParent; &#125; return &#123; x : x, y : y &#125;;&#125; scrollWidth &amp; scrollHeight这两个属性是元素的内容区域加上内边距，在加上任何溢出内容的尺寸. 因此，如果没有溢出时，这些属性与clientWidth和clientHeight是相等的。 scrollLeft &amp; scrollTop指定的是元素的滚动条的位置 scrollLeft和scrollTop都是可写的属性，通过设置它们来让元素中的内容滚动。 兼容性 window innerWidth 和 innerHeight 属性与outerWidth和outerHeight属性IE8以及以下不支持。 测试浏览器IE，火狐，谷歌，360浏览器，Safari都支持document.documentElement.clientWidth与document.documentElement.clientHeight。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之ES6模块]]></title>
    <url>%2Fpost%2Fba7de985.html</url>
    <content type="text"><![CDATA[本文全部内容来自ES6入门教程，这里只做笔记，请直接参考阮一峰老师《ES6入门教程》 介绍在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 CommonJS 的模块本质就是一个对象，当我们reuqire一个模块的时候，会引入整个模块，也就是把整个对象给搬了过来，然后访问对象上的属性。这种模块加载方式我们称之为动态加载，因为只有在运行时才能得到这个对象。动态加载的好处是灵活方便，可以根据条件判断选择性地加载模块；坏处是要么不加载，要加载就是整个模块，没办法只加载用到部分（因此没法做 Tree-Shaking），而且没法在编译阶段做“静态优化”（实现 Tree-Shaking的另一个阻碍）。代码清单11234567891011// CommonJS模块，这段代码的实质是在`程序运行时`整体加载fs模块所有的方法到_fs对象，然后结构这个对象获得需要的3的方法let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile;// ES6模块， 这段代码的实质是在程序编译时，从fs模块加载三个方法，其他的不加载import &#123; stat, exists, readFile &#125; from 'fs'; ESM 采用静态加载的方式，牺牲一部分灵活性（Dynamic Import 提案弥补了这一缺陷，现已进入 Stage-3，主流环境都已经支持，可以期待在 ES2019 中见到它），换取“静态优化”的可能性，大家熟悉的 Tree-Shaking、类型检测等功能都要归功于此。 严格模式es的模块自动采用严格模式，不管有没有使用use strict。严格模式的部分内容。严格模式本身属于 ES5 的内容，ES6 并没有对其做修改，只是强制启用。换个角度理解，未来其实也就没有严格模式一说了，所有 JavaScript 代码都必须遵守严格模式的规则。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 语法要点export命令export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内， export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。注意export后面的大括号，并不是对象，更不是对象的简写代码清单2123456789// 报错export 1;// 报错var m = 1;export m;// 报错let bb = &#123;&#125;export bb; 正确的写法12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; import命令import命令具有提升效果，会提升到整个模块的头部，首先执行。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次 模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。代码清单312345import * as circle from './circle';// 下面两行都是不允许的circle.foo = 'hello';circle.area = function () &#123;&#125;; export和 import的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。代码清单31234567891011121314export &#123; foo, bar &#125; from 'my_module';// 可以简单理解为import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出，这种写法不包括default，import的时候包括defaultexport * from 'my_module';// 导出defaultexport &#123; default &#125; from "my_module";export &#123; default as a &#125; from "my_module"; es6模块和commonjs模块的差异它们有两个重大差异。 CommonJS 模块输出的是一个值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块里的导出变量是和模块绑定在一起的，输出的是一个只读引用，只有需要的时候才会去到自身的模块去取值。恩，ES6的模块是单例的 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。因为commonjs加载的是一个脚本运行完成时生成的对象，而es6的对外接口是一种静态定义，在代码解析阶段就会生成。 CommonJS 模块的加载原理CommonJS 的一个模块，就是一个脚本文件。。123456&#123; id: "...", exports: &#123; ... &#125;, loaded: true, ...&#125; 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。 module的加载实现浏览器加载传统加载默认情况下，浏览器是同步加载的javascript脚本，即渲染引擎遇到script标签就会停下来下载脚本然后执行，执行完成后，再继续渲染。 浏览器也允许异步下载脚本，通过在script标签中添加defer和async实现。 代码清单512&lt;script src="path/to/myModule.js" defer&gt;&lt;/script&gt;&lt;script src="path/to/myModule.js" async&gt;&lt;/script&gt; defer要等待整个页面这场渲染完成后，才会去执行脚本；async在下载完成后，中断渲染，立即执行如果有多个defer，会按照出现在的顺序执行；async无法保证顺序。 ES6模块的加载规则浏览器要加载es6模块，也需要使用script标签，但是要加入type=module属性来标示加载的是一个es6模块。任何使用 type=”module” 加载的脚本都是以 严格模式(strict mode) 加载的。 代码清单61&lt;script type="module" src="./foo.js"&gt;&lt;/script&gt; 浏览器对于type=module的标签都是进行异步加载，等到页面渲染结束，再执行模块代码，如果页面有多个type=module模块，会按照出现的顺序依次执行。 代码清单7123&lt;script type="module" src="./foo.js"&gt;&lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type="module" src="./foo.js" defer&gt;&lt;/script&gt; 当然也可以开启async，这样只要模块下载完成，就执行该模块。 不支持模块的浏览器怎么办？结合使用 type=module 和 nomodule，通过nomodule为不支持的浏览器添加专门的代码。12&lt;script type="module" src="module.js"&gt;&lt;/script&gt;&lt;script nomodule src="fallback.js"&gt;&lt;/script&gt; 新问题不支持nomodule的浏览器怎么办？ 凉拌。。。 node加载Node 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。Node 的import命令是异步加载，这一点与浏览器的处理方法相同。 ES6 模块加载 CommonJS 模块CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。 代码清单81234567891011// a.jsmodule.exports = &#123; foo: 'hello', bar: 'world'&#125;;// 等同于export default &#123; foo: 'hello', bar: 'world'&#125;; import命令加载上面的模块，module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象{ default: module.exports }。下面是获取module.exports输出的代码。代码清单912345678910111213141516171819202122232425// 写法一import baz from './a';// baz = &#123;foo: 'hello', bar: 'world'&#125;;// 写法二import &#123;default as baz&#125; from './a';// baz = &#123;foo: 'hello', bar: 'world'&#125;;// 写法三import * as baz from './a';// baz = &#123;// get default() &#123;return module.exports;&#125;,// get foo() &#123;return this.default.foo&#125;.bind(baz),// get bar() &#123;return this.default.bar&#125;.bind(baz)// &#125;// 不正确， 因为fs是 CommonJS 格式，只有在运行时才能确定readFile接口，而import命令要求编译时就确定这个接口。解决方法就是改为整体输入import &#123; static &#125; from 'express';// 正确的写法一import * as express from 'express';const app = express.default();// 正确的写法二import express from 'express';const app = express(); CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。代码清单10123// foo.jsmodule.exports = 123;setTimeout(_ =&gt; module.exports = null); 上面代码中，对于加载foo.js的脚本，module.exports将一直是123，而不会变成null。 Commonjs加载es6模块 import()是用来实现动态import，类似require的用法，弥补了ESM纯静态方案在动态加载上方案上的缺陷。import()根据传入的参数按需加载模块，并在加载完成时返回一个 Promise 对象，后续就可以在then()里访问获取到的模块。 CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。代码清单1112345678910111213// es.mjslet foo = &#123; bar: 'my-default' &#125;;export default foo;// cjs.jsconst es_namespace = await import('./es.mjs');// es_namespace = &#123;// get default() &#123;// ...// &#125;// &#125;console.log(es_namespace.default);// &#123; bar:'my-default' &#125; 上面代码中，default接口变成了es_namespace.default属性。 下面是另一个例子。代码清单121234567891011121314// es.jsexport let foo = &#123; bar:'my-default' &#125;;export &#123; foo as bar &#125;;export function f() &#123;&#125;;export class c &#123;&#125;;// cjs.jsconst es_namespace = await import('./es');// es_namespace = &#123;// get foo() &#123;return foo;&#125;// get bar() &#123;return foo;&#125;// get f() &#123;return f;&#125;// get c() &#123;return c;&#125;// &#125; 内部变量ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。 首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。 arguments require module exports __filename __dirname 循环加载CommonJS 模块的循环加载CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。代码清单1312345exports.done = false;var b = require('./b.js');console.log('在 a.js 之中，b.done = %j', b.done);exports.done = true;console.log('a.js 执行完毕'); 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，此时缓存中的a的exports只有done=false，等待b.js执行完毕，再往下执行。 再看b.js的代码。代码清单1412345exports.done = false;var a = require('./a.js');console.log('在 b.js 之中，a.done = %j', a.done);exports.done = true;console.log('b.js 执行完毕'); 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 a.js已经执行的部分，只有一行。代码清单151exports.done = false; 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。代码清单16123var a = require('./a.js');var b = require('./b.js');console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); 执行main.js，运行结果如下。代码清单171234567$ node main.js在 b.js 之中，a.done = falseb.js 执行完毕在 a.js 之中，b.done = truea.js 执行完毕在 main.js 之中, a.done=true, b.done=true 上面的代码证明了两件事： 在b.js之中，a.js没有执行完毕，只执行了第一行。 main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。1exports.done = true; 总之，CommonJS 输入的是被输出值的拷贝，不是引用。 ES6 模块的循环加载ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from &#39;foo&#39;），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 请看下面这个例子。代码清单181234567891011// a.mjsimport &#123;bar&#125; from './b';console.log('a.mjs');console.log(bar);export let foo = 'foo';// b.mjsimport &#123;foo&#125; from './a';console.log('b.mjs');console.log(foo);export let bar = 'bar'; 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。代码清单19123$ node --experimental-modules a.mjsb.mjsReferenceError: foo is not defined 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？ 让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。 解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。代码清单2012345678910111213// a.mjsimport &#123;bar&#125; from './b';console.log('a.mjs');console.log(bar());function foo() &#123; return 'foo' &#125;export &#123;foo&#125;;// b.mjsimport &#123;foo&#125; from './a';console.log('b.mjs');console.log(foo());function bar() &#123; return 'bar' &#125;export &#123;bar&#125;; 这时再执行a.mjs就可以得到预期结果。代码清单2112345$ node --experimental-modules a.mjsb.mjsfooa.mjsbar 这是因为函数具有提升作用，在执行import {bar} from &#39;./b&#39;时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。代码清单22123456// a.mjsimport &#123;bar&#125; from './b';console.log('a.mjs');console.log(bar());const foo = () =&gt; 'foo';export &#123;foo&#125;; 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。 总结完！ 参考http://es6.ruanyifeng.com/#docs/module-loader]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2Fpost%2Ff134a8e5.html</url>
    <content type="text"><![CDATA[代码支持的语言：c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir 基本技巧链接常用写法12文字链接 [链接名称](http://链接网址)网址链接 &lt;http://链接网址&gt; 高级链接技巧1234567[链接名][链接代号]例如： [Google][1]这个链接用 1 作为网址变量， [Yahoo!][yahoo] 这个链接用 yahoo 作为网址变量.然后在文档的结尾或其他地方为变量赋值（网址）[1]: http://www.google.com/ 谷歌[yahoo]: http://www.yahoo.com/ 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！ 粗体斜体123*斜体文本* _斜体文本_**粗体文本** __粗体文本__***粗斜体文本*** ___粗斜体文本___ 标题1234567标题：#h1级标题##h2级标题###h3级标题####h4级标题#####h5级标题######h6级标题 列表普通无序列表 123- 列表文本前使用 [减号+空格]+ 列表文本前使用 [加号+空格]* 列表文本前使用 [星号+空格] 普通有序列表1231. 列表前使用 [数字+空格]2. 我们会自动帮你添加数字7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 列表嵌套123456789101112131415161718191. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格4. 列表里代码段： (```) 请无视括号，这里代码的位置 (```)××××××××或者直接空八个，引入代码块（请把前面的8个×当做空格） 引用普通引用12&gt; 引用文本前使用 [大于号+空格]&gt; 折行可以不加，新起一行都要加上哦 引用里嵌套引用123&gt; 最外层引用&gt; &gt; 多一个 &gt; 嵌套一层引用&gt; &gt; &gt; 可以嵌套很多层 引用里嵌套列表123&gt; - 这是引用里嵌套的一个列表&gt; - 还可以有子列表&gt; * 子列表需要从 - 之后延后四个空格开始 引用里嵌套代码块1同上，列表中嵌套代码块 换行如果另起一行，只需在当前行结尾加 2 个空格 12在当前行的结尾加 `2` 个空格这行就会新起一行 如果是要起一个新段落，只需要空出一行即可。 高级技巧代码块1使用 &lt;pre&gt;&lt;/pre&gt; 元素同样可以形成代码块 如你不需要代码高亮，可以指定代码语言为nohighlight Markdown编辑表格时如何输入竖线？竖线用&amp;#124;或者&amp;#x7C;来代替 表格对齐1234| 左对齐标题 | 右对齐标题 | 居中对齐标题 || :------| ------: | :------: || 短文本 | 中等文本 | 稍微长一点的文本 || 稍微长一点的文本 | 短文本 | 中等文本 | 参考Markdown 编辑器语法指南]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NVM管理Nodejs版本]]></title>
    <url>%2Fpost%2Ffd885007.html</url>
    <content type="text"><![CDATA[前言ECMA标准不断推出，nodejs需要不断向标准靠拢，版本迭代很快，新的特性不断加入，所以我们的项目之间可能要使用不同的nodejs版本，比方说：你可能同时进行两个项目，而不同项目所使用的node版本是不一样的；又或者你要用更新的版本是做一些实验。这种情况下，如果没有NVM自己去安装和维护多个版本的node也是一件比较麻烦的事情。这就是NVM的价值。 nvm不支持Windows本文使用环境是linux，替代解决办法是使用nvm-windows或者nodist, 所有命令是一样的,不同的是安装和设置默认下载仓库, 自行搜索解决。 安装/升级script方式123curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash或者wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash Git安装(最低要求的git版本是v1.7.0) 将此repo克隆在用户的根目录中 12cd ~/ git clone https://github.com/creationix/nvm.git .nvm 检查最新版本并激活 1234cd ~/.nvm git checkout v0.33.6# 激活nvm. nvm.sh 将一下代码添加到~/.bashrc, ~/.profile, or ~/.zshrc, 以便在登录的时候,自动获取nvm 123export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion 验证安装12# 如果安装成功，应输出“nvm”, nvm 安装完成后，可能要重启一下 shell 才有 nvm 这个命令。command -v nvm 配置镜像服务器nvm 默认是从 http://nodejs.org/dist/ 下载的, 国外服务器, 必然很慢,好在 nvm 以及支持从镜像服务器下载包12# 从淘宝镜像下载node v4的最新版本NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install 4 如果你不想每次都输入环境变量 NVM_NODEJS_ORG_MIRROR, 建议将一下代码加入到 .bashrc 文件中，这样就会自动从淘宝镜像上下载:12export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodesource $NVM_DIR/nvm.sh 配置需要全局安装的npm包在$NVM_DIR文件夹添加default-packages,即可在安装指定node版本后,自动全局安装指定的npm包的最新版本,示例:123456# $NVM_DIR/default-packagesexpress-generatorgulpnode-gyppm2supervisor 使用 .nvmrc 配置项目的 node 版本如果你的系统设置 node 版本与项目所需的版本不同，则可在项目根目录或其任意父级目录中创建 .nvmrc 文件，在文件中指定使用的 node 版本号.1234cd &lt;项目根目录&gt; #进入项目根目录echo 8 &gt; .nvmrc #添加 .nvmrc 文件nvm use #无需指定版本号，会自动使用 .nvmrc 文件中配置的版本node -v #查看 node 是否切换为对应版本 问题sudo node出现node: command node found ，这是因为nvm安装在当前用户下，在/usr/local/bin/下找不到node命令，可以通过建立软链接的方法解决。 123sudo ln -s "$NVM_BIN/node" "/usr/local/bin/node"sudo ln -s "$NVM_BIN/npm" "/usr/local/bin/npm"sudo ln -s "$NVM_BIN/npx" "/usr/local/bin/npx" 附录默认别名 node：最新版本 node iojs：最新版本 io.js stable：此别名已被弃用，只能真正适用于node v0.12和较早版本。目前，这个别名被node替代。 unstable：这个别名指向node v0.11- 最后一个“不稳定”node，1.0之后，所有节点版本都是稳定的。 无论何时当nvm连接到https://nodejs.org，它将为所有可用的LTS行重新创建适当的本地别名。这些别名（存储在 $NVM_DIR/alias/lts）下，由nvm管理，您不应该修改，删除或创建这些文件，以免导致可能不支持的错误。 命令说明1234567891011121314151617181920212223242526272829303132333435363738394041424344nvm --help #显示帮助信息nvm --version #Print out the installed version of nvmnvm install [-s] &lt;version&gt; #下载制定版本的node, [-s]表示强制从源代码安装. 如果.nvmrc存在,则使用.nvmrc --reinstall-packages-from=&lt;version&gt; #将指定版本的全局npm包安装到当前版本 --lts #安装时，只能从LTS（长期支持）版本中进行选择 --lts=&lt;LTS name&gt; #安装时，只能选择特定LTS版本，参数LTS name可以在$NVM_DIR/alias/lts目录可以查看 --skip-default-packages #安装时，如果存在default-packages文件,请跳过 --latest-npm #安装后，尝试升级到node版本上的最新的npm版本nvm uninstall &lt;version&gt; #卸载指定版本nvm uninstall --lts #卸载长期支持版本,默认使用别名 lts/* , 如果存在.nvm uninstall --lts=&lt;LTS name&gt; #卸载指定别名的长期支持版本nvm use [--silent] &lt;version&gt; #指定当前使用的版本. 如果存在.nvmrc,则使用.nvmrc --lts #参见上面说明 --lts=&lt;LTS name&gt; #参见上面说明nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] #在指定node版本上指定命令. 如果存在.nvmrc,则使用.nvmrc --lts #参见上面说明 --lts=&lt;LTS name&gt; #参见上面说明nvm run [--silent] &lt;version&gt; [&lt;args&gt;] #在指定的版本下运行node程序.使用&lt;args&gt;作为参数,如果存在.nvmrc,则使用.nvmrc --lts #如果存在lts版本,则使用lts版本的node --lts=&lt;LTS name&gt; #如果存在指定别名的lts版本,则使用nvm current #当前已激活的node版本nvm ls #已安装的node列表nvm ls &lt;version&gt; #已安装的指定版本的node列表nvm ls-remote #列出可用于安装的远程版本 --lts #列出可用于安装的远程LST版本nvm ls-remote &lt;version&gt; #列出可用于安装的远程版本，指定version number,则给定的&lt;version&gt;匹配 --lts #列出可用于安装的远程LST版本，指定verison number,则给定的&lt;version&gt;匹配 --lts=&lt;LTS name&gt; #列出可用于安装的指定的远程LST版本，指定verison number,则给定的&lt;version&gt;匹配nvm version &lt;version&gt; #查看本地指定版本的versionnvm version-remote &lt;version&gt; #查看远程指定版本的version --lts #只显示LTS（长期支持）版本的version --lts=&lt;LTS name&gt; #只显示指定LTS（长期支持）版本的versionnvm deactivate #从当前shell中禁用nvm的效果,即去除已激活的node,可以通过nvm use命令重新激活nvm alias [&lt;pattern&gt;] #显示以&lt;pattern&gt;开始的所有别名,如果没有指定,则显示所有别名nvm alias &lt;name&gt; &lt;version&gt; #为指定的版本设置别名nvm unalias &lt;name&gt; #删除名为&lt;name&gt;的别名nvm install-latest-npm #升级当前版本node的npm到最新版本nvm reinstall-packages &lt;version&gt; #将指定版本的全局npm包安装到当前版本nvm unload #从shell中卸载nvm命令, 可以通过 . nvm.sh重新激活nvm which [&lt;version&gt;] #显示nvm的node安装路径,也可选择指定node版本. 如果存在.nvmrc,则使用.nvmrcnvm cache dir #显示nvm缓存目录的路径nvm cache clear #清空nvm的缓存目录$NVM_DIR/.cache 参考NVM官网]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码规范之Editorconfig]]></title>
    <url>%2Fpost%2F22dd8928.html</url>
    <content type="text"><![CDATA[写在前面.editorconfig主要用于在不同编辑器及IDE中提供代码一致性。例如缩进、换行、编码等，只有几个简单的配置项，官网用一个页面就讲完了 editorconfig简单，很简单，这仅仅是个工具，工具又怎么会搞的太难 谁在用常见于github上的项目，包括 bootstrap、angular，html5-boilerplate 等明星项目都在使用。 支持怎么样主流的编辑器都提供了支持，部分通过插件支持。jetbrains家的idea、webstorm等提供了原生支持，atom、sublime、vscode等需要插件支持。 怎么用在项目根目录下新建.editorconfig，并配置规则，下面是官方示例123456789101112131415161718192021222324252627282930313233# EditorConfig is awesome: https://EditorConfig.org# top-most EditorConfig fileroot = true# Unix-style newlines with a newline ending every file[*]end_of_line = lfinsert_final_newline = true# Matches multiple files with brace expansion notation# Set default charset[*.&#123;js,py&#125;]charset = utf-8# 4 space indentation[*.py]indent_style = spaceindent_size = 4# Tab indentation (no size specified)[Makefile]indent_style = tab# Indentation override for all JS under lib directory[lib/**.js]indent_style = spaceindent_size = 2# Matches the exact files either package.json or .travis.yml[&#123;package.json,.travis.yml&#125;]indent_style = spaceindent_size = 2 当你打开一个文档即将coding的时候，EditorConfig插件就查找当前被编辑文件所在的目录有么有一个名为 .editorconfig 的文件，如果没有，则开始依次逐级向上查找当前目录的父目录，直到到达工程根目录，或者找到配置了root=true的配置文件。 如果一个工程中出现多个配置文件，EditorConfig配置文件的读取层级是自上而下的（类似于css规则），最深层的配置文件，最后读取。配置规则也是按照读取的顺序来生效，所以路径上离代码最近的配置规则，优先级最高。 注意：Windows 用户在项目根目录创建.editorconfig文件，可以先创建.editorconfig.文件，系统会自动重名为.editorconfig。 配置文件 属性不区分大小写。当他们被插件识别的时候，统一转为小写。通常，如果一个属性没有被设置，编辑器将使用自身的默认设置，换句话说就是，如果有属性没被设置，EditorConfig也不会应用自己的默认设置，只有明确设置了属性，这部分规范才会应用到编辑器。 属性列表： 属性名 作用 root 特殊的属性，必须在配置文件的顶部，在所有的section之外首先设置，设置为true 的时候将结束EditorConfig对配置文件的向上查找 indent_style 设置缩进风格，tab或者space indent_size 用来定义缩进的列数，如果indent_style为tab，则此属性默认为tab_width。 tab_width 设置tab缩进的列数。默认是indent_size。 end_of_line 设置为lf，cr，crlf来规定如果要换行，换行符如何生成 charset 设置字符集：latin1, utf-8, utf-8-bom, utf-16be or utf-16le，不建议使用utf-8-bom。 trim_trailing_whitespace 设为true时，去掉行尾的空白字符 insert_final_newline 设为true时，会确保文件在保存的时候，底部总是以一个新行结尾 通配符： 符号 作用 * 匹配除&#124;之外的任意字符串 ** 匹配任何字符串 ? 匹配任意单个字符 [name] 匹配name字符 [!name] 匹配非name字符 {s1,s2,s3} 匹配给定的任何字符串（以逗号分隔）（自EditorConfig Core 0.11.0起可用） {num1..num2} 匹配num1和num2之间的任何整数，其中num1和num2可以是正数或负数 示例123456789101112131415161718root = true# [*.&#123;js, py&#125;] 匹配js/py文件并单独设置indent_style = spaceindent_size = 4# 只匹配py结尾文件[*.py]indent_style = tab# 匹配指定目录下js文件[lib/**.js]indent_style = spaceindent_size = 2# Matches the exact files either package.json or .travis.yml[&#123;package.json, .travis.yml&#125;]indent_style = spaceindent_size = 4 配置例外 对于所有的属性来讲，如果属性值被设置为：unset,就意味着移除该属性对编辑器的作用，即使该属性之前已经被设置过了。 123456789101112131415[*]end_of_line = lfinsert_final_newline = truecharset = utf-8indent_style = spaceindent_size = 4# 忽略指定目录, unset的作用是删除该属性的效果[&#123;/node_modules/**, /build/**, /dist/**, *-lock.json &#125;]charset = unsetend_of_line = unsetinsert_final_newline = unsettrim_trailing_whitespace = unsetindent_style = unsetindent_size = unset 在webstorm中使用Webstorm默认支持它，配置完成后，不必重新启动Webstorm，它会自动获取配置。 总结editorconfig很简单，直接看官方文档就行了。]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之ES6箭头函数]]></title>
    <url>%2Fpost%2F82450d4e.html</url>
    <content type="text"><![CDATA[介绍使用箭头=&gt;定义的函数，称为箭头函数。相比于常规函数的写法，箭头函数的写法更加简洁。箭头函数的设计初衷是要实现类似纯函数的效果，而要实现这样的效果，就必须剔除外部状态，所以在定义一个箭头函数的时候，普通函数常见的this/arguments/caller等会造成副作用的属性是统统没有的。 箭头函数只能用赋值式写法，不能用声明式写法 1234const test = (name) =&gt; &#123; console.log(name)&#125;test('Jerry') 如果参数只有一个，可以不加括号，如果没有参数或者参数多于一个就需要加括号 123456789const test = name =&gt; &#123; console.log(name)&#125;test('Jerry')const test2 = (name1, name2) =&gt; &#123; console.log(name1 + ' and ' + name2)&#125;test2('Tom', 'Jerry') 如果函数体只有一句话，可以不加花括号 1const test = name =&gt; console.log(name) 如果函数体没有括号，可以不写return，箭头函数会帮你return 12const add = (p1, p2) =&gt; p1 + p2add(10, 25) 箭头函数的特性 箭头函数中没有自己的this，箭头函数中使用的this是通过查找作用域链来确定的，通过call、apply和bind只能传递参数，无法指定this 在没有箭头函数之前，函数作用域经常要将一个this绑定要函数上，通常使用self=this、call、apply或者bind。在es6中就可以利用箭头函数的这个特性 123456789101112131415161718192021222324252627282930313233// 在es5的时代，我们通常这样做var Ball = function (x, y) &#123; this.x = x; this.y = y; // 指定self为外层作用域的this var self = this; setInterval(function () &#123; self.x += 10; self.y += 10; console.log(self.x, self.y); &#125;, 1000);&#125;;new Ball( 0, 0 );// 10 10 // 1s// 20 20 // 2s// 30 30 // 3s// ...// 用箭头函数重写var Ball = function (x, y) &#123; this.x = x; this.y = y; setInterval(()=&gt;&#123; this.x += 10; this.y += 10; console.log(this.x, this.y); &#125;, 1000);&#125;;new Ball( 0, 0 );// 10 10 // 1s// 20 20 // 2s// 30 30 // 3s// ... 没有自己的arguments，箭头函数中使用arguments是通过查找作用域链来确定的，如果需要访问箭头函数中的所有参数，可以通过rest参数的方式 123456789function f() &#123; var a = (...rest)=&gt;&#123; console.log([...arguments]); console.log(rest); &#125;; a(10,122,23);&#125;f(1,2,3); 不能作为构造函数，即无法使用new关键字调用，所以也没有 new.target 属性 没有自己的super，，箭头函数中使用的super是通过查找作用域链来确定的 没有prototype属性1234const test = name =&gt; &#123; console.log(name)&#125;console.log(test); // undefined 箭头函数不能滥用对于一下情境，箭头函数是不适用的： 定义对象原型属性的时候，使用箭头函数，会使this的指向飞到外太空 动态this的时候，比如绑定dom事件，dom事件处理函数的this是根据不同的事件源来生成的，这个时候this是动态的，如果使用箭头函数，会绑定静态上下文，造成使用上的问题 对象字面量12345let a = &#123; foo: 1, bar: () =&gt; console.log(this.foo)&#125;a.bar() //undefined 以上代码中的a并不能构成作用域，所以查找this的时候，会到全局作用域去搜索，所以this会指向window（global） 总结完！ 参考https://github.com/mqyqingfeng/Blog/issues/85]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决deepin中雷鸟邮件客户端没有桌面图标]]></title>
    <url>%2Fpost%2F77d07f53.html</url>
    <content type="text"><![CDATA[markdown现在已经是写文档的神兵利器，拥有一款可以直接用markdown写邮件的客户端，就是无比幸福的事情，今天在我的深度linux上安装了thunderbird雷鸟邮件客户端，并安装了markdown here的插件，写起邮件来真是贼爽。 下载雷鸟邮件客户端点这里想使用markdown here点这里 在linux下安装运行thunderbird都很顺利，唯一不爽的是一切正常后，并没有在应用程序中找到thunderbird快捷图标。 在/usr/share/applications/下面也没有找到thunderbird.desk文件，所以只有自己造一个了。 解决方法 网上搜索一个thunderbird图片，然后在这里转换为xmp格式，备用 创建thunderbird.desktop文件 12$ cd /usr/share/applications$ vi thunderbird.desktop 配置thunderbird.desktop 在thunderbird.desktop中输入如下内容, 里面的文件路径根据自己文件存放位置不同来写的。 12345678[Desktop Entry]Name=ThunderbirdComment=Read/Write Mail/News with Mozilla ThunderbirdExec=/usr/bin/thunderbirdIcon=第一步获取的xmp文件的位置Terminal=falseType=ApplicationCategories=Application;Network; 保存并退出thunderbird.desktop，再打开“应用程序就会发现thunderbird的图标，点击可以正常运行。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之ES6尾调用优化]]></title>
    <url>%2Fpost%2Fca057aeb.html</url>
    <content type="text"><![CDATA[ES6入门教程 什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。1234567891011121314151617181920// 情况一调用函数g之后，还有赋值操作function f(x)&#123; let y = g(x); return y;&#125;// 情况二属于调用后还有相加的操作function f(x)&#123; return g(x) + 1;&#125;// 情况三等同于下面的代码function f(x)&#123; g(x);&#125;function f(x)&#123; g(x); return undefined;&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 优化函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 12345function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 1234567function factorial(n, total) &#123; if (n === 1) return total; total = n * total; return factorial(n - 1, total);&#125;factorial(5, 1) // 120 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。 非尾递归的 Fibonacci 数列实现如下。12345678function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 12345678function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。12345678910function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。 第二种方法就简单多了，就是采用 ES6 的函数默认值。123456function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 上面代码中，参数total有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 问题目前V8引擎并没有优化尾递归，V8团队认为做尾递归优化存在一系列问题，因此倾向于支持用显示的语法来实现，而非做优化。 尾递归优化的实现尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。123456789function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。 但目前V8引擎并没有优化尾递归，V8团队认为做尾递归优化存在一系列问题，因此倾向于支持用显示的语法来实现，而非做优化。 蹦床函数（trampoline）可以将递归执行转为循环执行。123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 1234567function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125; 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 12trampoline(sum(1, 100000))// 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 1234567891011121314151617181920212223242526272829function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】JavaScript instanceof 运算符深入剖析]]></title>
    <url>%2Fpost%2F5f54049b.html</url>
    <content type="text"><![CDATA[写在前面isPrototypeOf和instanceof都是用来判断继承关系的，但是两者在使用上还是有些细微差别的，这里做个总结： A.isPrototypeOf(B)是说B的原型链上有没有A B instanceof A 是说B的原型链有没有A的原型A.prototype.isPrototypeOf(B) 等价于 B instanceof A12345// 检查 baz 对象是否继承自 Fooif (Foo.prototype.isPrototypeOf(baz)) &#123; // do something safe&#125;// 等价于： baz instanceof Foo 下面的内容来自IBM developerWorks instanceof 运算符简介在 JavaScript 中，判断一个变量的类型尝尝会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如： 清单 1. instanceof 示例12var oStringObject = new String("hello world"); console.log(oStringObject instanceof String); // 输出 "true" 这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是”true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。 instanceof 运算符的常规用法通常来讲，使用 instanceof 就是判断一个实例是否属于某种类型。例如： 清单 2. instanceof 常规用法1234// 判断 foo 是否是 Foo 类的实例function Foo()&#123;&#125; var foo = new Foo(); console.log(foo instanceof Foo)//true 另外，更重的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型。例如： 清单 3. instanceof 在继承中关系中的用法12345678// 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例function Aoo()&#123;&#125; function Foo()&#123;&#125; Foo.prototype = new Aoo();//JavaScript 原型继承 var foo = new Foo(); console.log(foo instanceof Foo)//true console.log(foo instanceof Aoo)//true 上面的代码中是判断了一层继承关系中的父类，在多层继承关系中，instanceof 运算符同样适用。 你真的了解 instanceof 操作符吗？看了上面的代码示例，是不是觉得 instanceof 操作符很简单，下面来看点复杂的用法。 清单 4. instanceof 复杂用法1234567console.log(Object instanceof Object);//true console.log(Function instanceof Function);//true console.log(Number instanceof Number);//false console.log(String instanceof String);//false console.log(Function instanceof Object);//true console.log(Foo instanceof Function);//true console.log(Foo instanceof Foo);//false 看了上面的代码是不是又晕头转向了？为什么 Object 和 Function instanceof 自己等于 true，而其他类 instanceof 自己却又不等于 true 呢？如何解释？要想从根本上了解 instanceof 的奥秘，需要从两个方面着手：1，语言规范中是如何定义这个运算符的。2，JavaScript 原型继承机制。 详细剖析 ECMAScript-262 edition 3 中 instanceof 运算符的定义语言规范对中 instanceof 运算符的定义如下： 清单 5. 规范中 instanceof 运算符定义123456789101112131415161718192021222324252627282930313233343511.8.6 The instanceof operator The production RelationalExpression: RelationalExpression instanceof ShiftExpression is evaluated as follows: 1. Evaluate RelationalExpression. 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2) 3. Evaluate ShiftExpression. 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4) 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object， //抛出异常 /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */ 6. If Result(4) does not have a [[HasInstance]] method, throw a TypeError exception. // 相当于这样调用：Result(4).[[HasInstance]](Result(2)) 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2). 8. Return Result(7). // 相关的 HasInstance 方法定义 15.3.5.3 [[HasInstance]] (V) Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2) When the [[HasInstance]] method of F is called with value V, the following steps are taken: 1. If V is not an object, return false.// 如果 V 不是 object，直接返回 false 2. Call the [[Get]] method of F with property name "prototype".// 用 [[Get]] 方法取 // F 的 prototype 属性 3. Let O be Result(2).//O = F.[[Get]]("prototype") 4. If O is not an object, throw a TypeError exception. 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]] 6. If V is null, return false. // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 true；否则，到 Step 8 返回 Step 5 继续循环 7. If O and V refer to the same object or if they refer to objects joined to each other (section 13.1.2), return true. 8. Go to step 5. 上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下： 清单 6. JavaScript instanceof 运算符代码1234567891011function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式 var O = R.prototype;// 取 R 的显示原型 L = L.__proto__;// 取 L 的隐式原型 while (true) &#123; if (L === null) return false; if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true return true; L = L.__proto__; &#125; &#125; JavaScript 原型继承机制由于本文主要集中在剖析 JavaScript instanceof 运算符，所以对于 JavaScript 的原型继承机制不再做详细的讲解，下面参考来自 http://www.mollypages.org/misc/js.mp 的一张图片，此图片详细的描述了 JavaScript 各种对象的显示和隐式原型链结构。 由其本文涉及显示原型和隐式原型，所以下面对这两个概念作一下简单说明。在 JavaScript 原型继承结构里面，规范中用 [[Prototype]] 表示对象隐式的原型，在 JavaScript 中用 proto 表示，并且在 Firefox 和 Chrome 浏览器中是可以访问得到这个属性的，但是 IE 下不行。所有 JavaScript 对象都有 proto 属性，但只有 Object.prototype.proto 为 null，前提是没有在 Firefox 或者 Chrome 下修改过这个属性。这个属性指向它的原型对象。 至于显示的原型，在 JavaScript 里用 prototype 属性表示，这个是 JavaScript 原型继承的基础知识，在这里就不在叙述了。 JavaScript 原型链讲解 instanceof 复杂用法有了上面 instanceof 运算符的 JavaScript 代码和原型继承图，再来理解 instanceof 运算符将易如反掌。下面将详细讲解 Object instanceof Object，Function instanceof Function 和 Foo instanceof Foo 三个示例，其它示例读者可自行推演。 清单 7. Object instanceof Object123456789101112// 为了方便表述，首先区分左侧表达式和右侧表达式ObjectL = Object, ObjectR = Object; // 下面根据规范逐步推演O = ObjectR.prototype = Object.prototype L = ObjectL.__proto__ = Function.prototype // 第一次判断O != L // 循环查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype // 第二次判断O == L // 返回 true 清单 8. Function instanceof Function12345678// 为了方便表述，首先区分左侧表达式和右侧表达式FunctionL = Function, FunctionR = Function; // 下面根据规范逐步推演O = FunctionR.prototype = Function.prototype L = FunctionL.__proto__ = Function.prototype // 第一次判断O == L // 返回 true 清单 9. Foo instanceof Foo12345678910111213141516// 为了方便表述，首先区分左侧表达式和右侧表达式FooL = Foo, FooR = Foo; // 下面根据规范逐步推演O = FooR.prototype = Foo.prototype L = FooL.__proto__ = Function.prototype // 第一次判断O != L // 循环再次查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype // 第二次判断O != L // 再次循环查找 L 是否还有 __proto__ L = Object.prototype.__proto__ = null // 第三次判断L == null // 返回 false 结束语本文详细介绍了 JavaScript 语言中 instanceof 运算符，并且结合语言规范深入剖析了此操作符的算法。对读者使用 JavaScript 编写复杂的面向对象程序会有很大的帮助。本文所有代码在 Firefox 15 下通过测试。 问答 你好，我在验证var a = “1”, a instanceof String的时候为false,不符合上文所说的情况，而且a.proto === String.prototype//true String是一个构造函数对象，a的类型不是String，而是string，这个类型无法直接检测，a.proto会导致a被临时包装为一个object类型的对象，此时这个临时对象是由String构造函数创建的，所以a.proto === String.prototype成立。 重要的是要理解JavaScript中只有这几个类型:number/boolean/string/undefined/null/object，并没有什么乱七八糟的Object/Function/Array，它们都只不过是一堆object!]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制、八进制、十进制、十六进制之间的转换]]></title>
    <url>%2Fpost%2Fc94db3bb.html</url>
    <content type="text"><![CDATA[前提知识 我们需要了解一个数学关系，即2^3=8，2^4=16，而八进制和十六进制是用这关系衍生而来的，即用三位二进制表示一位八进制，用四位二进制表示一位十六进制数。接着，记住4个数字8、4、2、1（2^3=8、2^2=4、2^1=2、2^0=1）。 包含小数的进制换算： 12345(ABC.8C)H=10x16^2+11x16^1+12x16^0+8x16^-1+12x16^-2=2560+176+12+0.5+0.046875=(2748.546875)D 负次幂的计算 同底数幂相除，底数不变，指数相减，反过来 12^-5=2^(0-5)=2^0/2^5=1/2^5 二进制与八进制的转换 二进制与八进制之间的关系式每个八进制位对应三个二进制位，即一个八进制的数，是由3位二进制构成 二进制转换为八进制：取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。 八进制转换为二进制：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。 二进制与八进制编码对应表： 八进制 二进制 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 1234567891011121314151617// 通过表格可以一步完成下面的转换// 将二进制的(11010111.0100111)B转换为八进制的步骤如下：1. 小数点前111 = 7；2. 010 = 2；3. 11补全为011，011 = 3；4. 小数点后010 = 2；5. 011 = 3；6. 1补全为100，100 = 4；7. 读数，读数从高位到低位，即(11010111.0100111)B=(327.234)O。// 将八进制的(327)O转换为二进制的步骤如下：1. 3 = 011；2. 2 = 010；3. 7 = 111；4. 读数，读数从高位到低位，011010111，即(327)O=(11010111)B。 二进制与十六进制的转换 二进制与十六进制之间的关系式每个十六进制位对应四个二进制位，即一个十六进制的数，是由4位二进制构成 二进制转换为十六进制：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。 十六进制转换为二进制：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。 二进制与十六进制编码对应表： 十六进制 二进制 0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 10/A 1010 11/B 1011 12/C 1100 13/D 1101 14/E 1110 15/F 1111 1234567891011// 将十六进制的(D7)H转换为二进制的步骤如下：1. D = 1101；2. 7 = 0111；3. 读数，读数从高位到低位，即(D7)H=(11010111)B。// 将二进制的(11010111)B转换为十六进制的步骤如下：1. 0111 = 7；2. 1101 = D；3. 读数，读数从高位到低位，即(11010111)B=(D7)H。 八进制和十六进制的转换 以二进制或者十进制为媒介进行转换 十进制与二进制、八进制、十六进制的转换十进制转换为二进制十进制转换为二进制，需要分成整数和小数两个部分分别转换。当转换整数时，用的除2取余法；而转换小数时候，用的是乘2取整法 整数部分规则：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。 小数部分规则：乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数 12345// 将0.125换算为二进制结果为0.001 分析：第一步，将0.125乘以2，得0.25,则整数部分为0,小数部分为0.25; 第二步, 将小数部分0.25乘以2,得0.5,则整数部分为0,小数部分为0.5; 第三步, 将小数部分0.5乘以2,得1.0,则整数部分为1,小数部分为0.0; 第四步,读数,从第一位读起,读到最后一位,即为0.001。 二进制转换为十进制不分整数和小数部分 二进制数小数点前从低位到高位（即从右往左）计算，权值依次是2^0，2^1，2^2，2^3…；小数点后面的权值依次是2^(-1), 2^(-2),2^(-3)… 把最后的结果相加的值就是十进制的值了。例如： 12// 10101.01转换成十进制数，结果是21.251x2^4+0x2^3+1x2^2+0x2^1+1x2^0+0x2^(-1)+1x2^(-2)=14+6+1+0.25=21.25 十进制转八进制 间接法：先将十进制转换成二进制，然后将二进制又转换成八进制 直接法：分为整数部分和小数部分 十进制转换为八进制，需要分成整数和小数两个部分分别转换。当转换整数时，用的除8取余法；而转换小数时候，用的是乘8取整法 整数部分规则：除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。 小数部分规则：乘8取整法，即将小数部分乘以8，然后取整数部分，剩下的小数部分继续乘以8，然后取整数部分，剩下的小数部分又乘以8，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是3还是4取舍，如果是3，舍掉，如果是4，进一位。换句话说就是3舍4入。读数要从前面的整数读到后面的整数 八进制转十进制 八进制就是逢8进1，八进制数采用 0～7这八数来表达一个数。 不分整数和小数部分 八进制数小数点前从低位到高位（即从右往左）计算，权值依次是8^0，8^1，8^2，8^3…；小数点后面的权值依次是8^(-1), 8^(-2),8^(-3)… 把最后的结果相加的值就是十进制的值了。例如 12// 八进制1434.55转换为十进制1x8^3+4x8^2+3x8^1+4x8^0+5x8^(-1)+5x8^(-2)=512+256+24+4+0.625+0.078125=796.703125 十六进制转十进制 十六进制就是逢16进1，十六进制的16个数为0123456789ABCDEF 十六进制与八进制有很多相似之处，可以参照上面八进制与十进制的转换自己试试这两个进制之间的转换。 参考https://www.cnblogs.com/gaizai/p/4233780.html#_labelConvert10 http://www.cnblogs.com/lds85930/archive/2007/09/19/897912.html https://jingyan.baidu.com/article/495ba84109665338b30ede98.html]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-javascript笔记之ES6数组的扩展]]></title>
    <url>%2Fpost%2F34bda64f.html</url>
    <content type="text"><![CDATA[本文内容摘自ES6入门教程 Array.isArray Array.isArray() 用于确定传递的值是否是一个 Array。此方法优于instanceof 代码清单112345678Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray("foobar"); // falseArray.isArray(undefined); // false Array.from 该方法用于将两类对象转换为真正的数组：类似数组对象[array-like object]和可遍历[iterable]对象(包括String、新增的Set和Map)。 该函数接收三个参数： 第一个参数为类数组对象或者可遍历对象 第二个参数为一个函数，作用类似于map,用来对每个元素进行处理，并将处理后的值放入返回的数组。 第三个参数为thisArg，用来指定上下文 代码清单212345678910111213Array.from([1,2,3],(x)=&gt;x*x);// [1,4,9]// 取出一组dom节点的文本内容let spans = document.querySelectorAll("span.name");// map();// let names1 = Array.prototype.map.call(spans,(s)=&gt;s.textContent);let names2 = Array.from(spans).map((s)=&gt;s.textContent);// Array.fromlet names3 = Array.from(spans,(s)=&gt;s.textContent);// 初始化数组Array.from(&#123;length:3&#125;,()=&gt;"jack");// ["jack","jack","jack"] 关于string长度的应用，将string转换为数组，然后返回string的长度，因为它可以正确处理各种Unicode字符，可以避免将大于\uFFFF的Unicode字符算作两个字符的bug。 代码清单31Array.from(str).length; Array.of 该方法用于将一组值转换为数组， 在使用上基本上可以用来替代Array()。 代码清单4123456Array.of(2,3,4);// [2,3,4]Array.of(3);// [3]Array.of()// [] 该方法的主要目的是弥补数组构造函数的不足，Array构造函数会因为参数的不同导致Array()行为有差异。Array()在参数不少于2个的时候，返回的是由参数组成的新数组，参数个数只有一个的时候，实际是用来指定数组的长度。 代码清单5123456Array();// []Array(3);// [,,,]Array(2,3,4)// [2,3,4] 数组实例的 keys/values/entries三者均会返回一个可迭代对象，使用for...of循环 数组实例的 copyWinin() 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 代码清单61Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 代码清单7123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的find()和findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 代码清单812[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 数组实例的findIndex方法返回第一个符合条件的数组成员的位置，如果所有的数组成员都不符合条件，则返回-1 代码清单9123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;,this) // 2 这两个方法都可以发现NaN，弥补了数组indexOf方法的不足，indexOf无法识别数组的NaN成员，但是findIndex借助Object.is方法可以做到。 代码清单101234[NaN].indexOf(NaN);// -1[8,NaN].findIndex(y =&gt; Object.is(NaN,y));// 1 数组实例的fill() fill方法使用给定值，填充一个数组。 代码清单111234['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 代码清单1212['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 代码清单13123let arr = new Array(3).fill(&#123;name: "Mike"&#125;);console.log(arr);// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;] 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法的第二个参数表示搜索的起始下标，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 代码清单1412345[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。indexOf方法有两个缺点，一是它的本意是查找指定参数的数组下标。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。includes使用的是不一样的判断算法，就没有这个问题。 代码清单151234[NaN].indexOf(NaN)// -1[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 代码清单16123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 总结完！ 参考http://es6.ruanyifeng.com/#docs/array]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之随机数函数]]></title>
    <url>%2Fpost%2F23aab375.html</url>
    <content type="text"><![CDATA[API介绍Math.randomMath.random可以产生一个0-1间的随机数(包括0,不包括1)1Math.random(); // 获取一个大于等于0，小于1的随机数 Math.roundMath.round 返回一个数字四舍五入后最接近的整数123456789101112Math.round(20.49); // 20Math.round(20.5); // 21Math.round(-20.5); // -20Math.round(-20.51); // -21Math.round(0.5); // 1Math.round(0.49); // 0Math.round(-0.5); // 0Math.round(-0.51); // -1// 随机获取0和1Math.round(Math.random()); // 获取0到10的随机整数， 包括0和10Math.round(Math.random() * 10); Math.floorMath.floor 返回小于或等于一个给定数字的最大整数,即向下取整。1234567Math.floor( 45.95); // 45 Math.floor( 45.05); // 45 Math.floor( 4 ); // 4 Math.floor(-45.05); // -46 Math.floor(-45.95); // -46// 获取0到10的随机整数， 不包括10Math.floor(Math.random() * 10); Math.ceilMath.ceil 返回大于或等于一个给定数字的最小整数,即向上取整。 12345678Math.ceil( 45.95); // 46Math.ceil( 45.05); // 46 Math.ceil( 4 ); // 4 Math.ceil(-45.05); // -45 Math.ceil(-45.95); // -45// 获取0到10的随机整数， 包括0和10// 注意：只有Math.random为0的时候才为0，所以出现0的概率会比较低Math.ceil(Math.random() * 10); 如何使用当我们需要获取一组连续随机数的时候，我们希望这一组连续随机数是均线分布的，也就是在这一组随机数中，每一个具体数字出现的概率都是相当的。 例如，我们希望以相等的概率随机出现0或者1，我们实际上可以通过计算落在（0, 0.5），（0.5, 1）这两个区间内的累积概率分别代表0,和1。 因此，当我们需要获得指定区间的随机数时，我们可以在 Math.random()上乘以一定的数值，把整个区间范围拉长放大，例如，我们需要返回 [1,10] (注意是闭区间，包括1和10)，我们可以用Math.floor(Math.random()*10+1)获得. 之所以使用 floor 函数向下取整，而不能使用 round 函数四舍五入取整，round 取整后得到的是非均匀分布。 因为我们要每个数字出现的概率相等，就要保证每个区间长度相等，使用 round 取整后， 映射到1的区间为(1,1.5) 映射到2的区间为（1.5, 2.5）…… (9.5,10.5)，（10.5,11） 可见其区间长度是不同的，即1和11出现的概率为其他数字出现概率的一半。通过代码测试下： 使用Math.floor12345678910111213141516171819202122232425// var temp;var arr=&#123;&#125;;var t = 1000000;for(var i=0;i&lt;t;i++)&#123; temp=Math.floor(Math.random()*10+1); arr[temp]=(arr[temp]?arr[temp]:0)+1;&#125;console.log(arr)for (var j in arr) &#123; console.log(`得到$&#123;j&#125;的概率:` + arr[j]/t);&#125;// 可以看到出现各个值的概率是基本相等的。/*"得到1的概率:0.036753""得到2的概率:0.036697""得到3的概率:0.036808""得到4的概率:0.037075""得到5的概率:0.036365""得到6的概率:0.037077""得到7的概率:0.036649""得到8的概率:0.036889""得到9的概率:0.036621""得到10的概率:0.036676"*/ 使用 round:123456789101112131415161718192021222324252627var temp;var arr=&#123;&#125;;var t = 1000000;for(var i=0;i&lt;t;i++)&#123; temp=Math.round(Math.random()*10+1);// var index = temp&gt;0?(temp-1):temp;// console.log(arr[temp]); arr[temp]=(arr[temp]?arr[temp]:0)+1;&#125;console.log(arr)for (var j in arr) &#123; console.log(`得到$&#123;j&#125;的概率:` + arr[j]/t);&#125;// 得到1和11的概率为其他数字的一半。/**"得到1的概率:0.01608""得到2的概率:0.031666""得到3的概率:0.031815""得到4的概率:0.031614""得到5的概率:0.031795""得到6的概率:0.031918""得到7的概率:0.032079""得到8的概率:0.031509""得到9的概率:0.031664""得到10的概率:0.031598""得到11的概率:0.016016"*/ 所以Math.random服从 [0,1) 区间的均匀分布，因为均匀分布是连续性分布，我们也可以说是Math.random服从 （0,1）区间的均匀分布，这不影响我们使用累计概率密度。 因此，如果想获得 [min, max], 可以使用 Math.floor(Math.random() * (max - min + 1)) + min; 如果想获得 [min, max）, 可以使用 Math.floor(Math.random() * (max - min )) + min; 如果想获得 (min, max], 可以使用 Math.ceil(Math.random() * (max - min )) + min; 获取随机颜色下面是百度 2014年秋校园招聘 中，web前端开发岗位 的一道题，要求生成随机颜色，我们指定颜色的rgb表示方式中，三个值都是0到255之间的数字，那么我们如果能随机生成三个[0,255]的数字，那就能随机组成一个颜色值了，实现代码如下： 123456function randomRGB()&#123; var rc = function()&#123; return Math.floor(Math.random()*(255+1)); &#125; return `rgb($&#123;rc()&#125;,$&#123;rc()&#125;,$&#123;rc()&#125;)`&#125; 参考产生服从均匀分布随机数]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之JS解释执行过程]]></title>
    <url>%2Fpost%2F660a204a.html</url>
    <content type="text"><![CDATA[前言 编译型语言，编译步骤分为：词法分析、语法分析、语义检查、代码优化和字节生成，如java。 解释型语言，通过词法分析和语法分析得到抽象语法树（Abstract Syntax Tree）后，就可以开始解释执行了，如javascript。这里只是说明一下关于解析过程的原理，详细的解析过程（各种JS引擎还有不同）还需要更深一步的研究。 javascript的解释执行JavaScript解释型语言会经过以下几个步骤: 读入源代码===&gt;预解析===&gt;执行===&gt;结束，这里的预解析就像一个编译过程，包括一下几个步骤： 词法分析 语法分析 预编译 执行 词法分析词法分析器的作用，是将一行行的源码拆解成一个个词义单位（token）。所谓“词义单位”，指的是语法上不可能再分的、最小的单个字符或字符组合。 通过Esprima在线生成词法和语法分析树，可以在线查看对应的词法分析。 12345678910111213141516171819202122var a=2;function addA() &#123; return a;&#125;// 词法分析后的结果[ &#123;"type":"Keyword","value":"var"&#125;, &#123;"type":"Identifier","value":"a"&#125;, &#123;"type":"Punctuator","value":"="&#125;, &#123;"type":"Numeric","value":"2"&#125;, &#123;"type":"Punctuator","value":";"&#125;, &#123;"type":"Keyword","value":"function"&#125;, &#123;"type":"Identifier","value":"addA"&#125;, &#123;"type":"Punctuator","value":"("&#125;, &#123;"type":"Punctuator","value":")"&#125;, &#123;"type":"Punctuator","value":"&#123;"&#125;, &#123;"type":"Keyword","value":"return"&#125;, &#123;"type":"Identifier","value":"a"&#125;, &#123;"type":"Punctuator","value":";"&#125;, &#123;"type":"Punctuator","value":"&#125;"&#125;] 上面代码中，源代码经过词法分析后，返回一组词义单位，以及它们各自的词类。 语法分析 代码是给人读的，而js引擎要读的是抽象语法树。 语法分析将上一步生成的数组，根据语法规则，转为抽象语法树（Abstract Syntax Tree，简称AST）。如果源码符合语法规则，这一步就会顺利完成，生成一个抽象语法树；如果源码存在语法错误，这一步就会终止，抛出一个“语法错误”，并结束整个代码块的解析。 这个阶段主要做了两件事情： 确定作用域，根据静态作用域的特点，这个时候每个变量的作用域已经很明确了，不会在改变 记录每个作用域的所有变量和内嵌函数 1234var a=2;function addA() &#123; return a;&#125; 上面代码生成的抽象语法树的json格式如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; "type": "Program", "body": [ &#123; "type": "VariableDeclaration", "declarations": [ &#123; "type": "VariableDeclarator", "id": &#123; "type": "Identifier", "name": "a" &#125;, "init": &#123; "type": "Literal", "value": 2, "raw": "2" &#125; &#125; ], "kind": "var" &#125;, &#123; "type": "FunctionDeclaration", "id": &#123; "type": "Identifier", "name": "addA" &#125;, "params": [], "body": &#123; "type": "BlockStatement", "body": [ &#123; "type": "ReturnStatement", "argument": &#123; "type": "Identifier", "name": "a" &#125; &#125; ] &#125;, "generator": false, "expression": false, "async": false &#125; ], "sourceType": "script"&#125; 如果对抽象语法树感兴趣可以看下下面的链接： Esprima在线生成词法结构和语法分析树 AST explorer可以在线看到不同的parser解析js代码后得到的AST。 JavaScript AST visualizer 可以在线可视化的看到AST。 预编译预编译是指javascript引擎在执行一个函数时，会创建对应的执行上下文，它根据抽象语法树做的一些“准备工作”。这个过程包括一下几点： 创建变量对象 创建arguments对象，同名的实参，形参和变量之间是【引用】关系。 从语法分析树中复制作用域内的内嵌函数（functions）作为属性，key为函数name，属性值为函数的内存地址。 从语法分析树中复制作用域内所有变量（variables）作为属性，key为变量名称，此时变量值全部为undefined，若变量和函数存在同名，则跳过 创建作用域链，根据语法分析树中函数对应的作用域，结合当前环境的变量对象和上层环境的一系列变量对象组成 确定this指向 全局上下文的时候，变量对象就是全局对象window，this也志向window 执行开始执行后，执行上下文中的变量对象转换为活动对象，可以执行一系列的操作。 变量赋值，查找规则是先找自身作用域，找不到就在作用域链上查找 函数引用 执行其他代码 执行结束，内存回收 代码执行结束后，函数内变量的生存周期取决于函数实例是否存在引用，如没有就销毁活动对象 参考javascript的词法作用域]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之函数定义]]></title>
    <url>%2Fpost%2Fa4200564.html</url>
    <content type="text"><![CDATA[在 JavaScript中，函数是头等(first-class)对象，一等公民，因为它们可以像任何其他对象一样具有属性和方法。它们与其他对象的区别在于函数可以被调用。 函数的定义在javascript中，函数是由事件驱动的或者当它被调用时执行的可重复使用的代码快。当今任何一个javascript框架或者库，都是由成千上万个函数组成，比如jquery、react、vue等。通过使用函数可以更加合理的组织代码，不仅提高了代码的可读性，也为程序扩展提供了可能。通常根据定义函数的方式不同，将函数分为声明式函数和表达式函数。 声明式函数声明式函数相对于表达式函数而言又被称作具名函数，定义格式如下： 123function funcname([arg1[,arg2……]])&#123; // statements&#125; funcname是一个标识符，是定义的函数名，不是字符串也不是变量。紧跟后面的括号中是函数的参数，大括号中是函数体。当函数被调用时，传入参数并执行函数体中的代码。 123456function add(x,y)&#123; console.log(x+y);&#125;add(2, 3); //显示 5// 可以通过name属性获得函数的名字console.log(add.name);// add 表达式函数表达式函数可以定义一个匿名函数(表达式函数可以带函数名，但是函数名只能在函数内部使用，相对于全局来说是匿名的) 示例1(没有函数名) 12345678// add指向存储匿名函数的地址let add = function(x,y)&#123; console.log(x+y);&#125;;let sum = add;// 匿名函数的name用最初赋值的变量字符串表示console.log(add.name); //addconsole.log(sum.name); //add 示例2(提供函数名的时候，函数名只可以在函数内部使用来代指函数本身) 123456var factorial = function fac(n) &#123;return n&lt;2 ? 1 : n*fac(n-1)&#125;;console.log(factorial(3)); // 6console.log(factorial.name); //factorialconsole.log(fac.name); //fac is not defined 需要注意的是，使用Function构造函数也可以定义表达式，使用该方式定义函数允许我们动态的来定义和编译一个函数，而不是限定在function预编译的函数体中。但同时也会带来负面影响，因为每次调用都要对它进行编译并生成新的函数对象，尤其是在循环体中，效率相对较低。不推荐使用，了解即可 123456// 使用new Function创建一个函数var add = new Function ('x', 'y', 'console.log(x+y)');// 下面的代码和上面的代码是等价的function add(x,y)&#123; console.log(x+y);&#125; Function()构造函数定义的函数是全局作用域的 12345678910111213141516var y = "global";function a()&#123; var y = "local a"; console.log(y);&#125;var b = function()&#123; var y = "local b"; console.log(y);&#125;;function c()&#123; var y = "local c"; return new Function("console.log(y)");&#125;a();//local ab();//local bc()();//local c()()打印global，因为Function()返回的是全局变量y，而不是函数体内的局部变量。 声明式函数和表达式函数的区别最主要的区别是加载顺序有所不同，声明式函数是在 JavaScript 编译的时候就加载到作用域中,而表达式函数则是在代码执行的时候加载，如果在定义之前调用表达式函数，则会返回 undefined；这就是通常说的函数声明提升 123456789101112131415console.log(typeof f);//functionconsole.log(typeof c);//undefined,因为 c 还没有定义console.log(typeof d);//undefined,因为 d 还没有定义console.log(typeof a);//undefined,因为 d 还没有定义function f()&#123; return true&#125;var a = ()=&gt;"Hello ES6";var c = function()&#123; return true;&#125;;console.log(typeof c);//function, 因为上面已经定义console.log(typeof a);//function, 因为上面已经定义var d = new Function("return true");console.log(typeof d);//function，上面已经定义 参考链接MDNIBM Developer]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之搞不懂的你]]></title>
    <url>%2Fpost%2F86428339.html</url>
    <content type="text"><![CDATA[ES6的全局变量全局对象是最顶层的对象，在浏览器环境下是window对象，在NODE中指的是global对象。在ES5中全局对象的属性和全局变量是等价的。在ES6的模块环境中，全局变量必须显式声明称global对象的属性。 12345window.a = 1;a // 1a = 2;window.a // 2 这种规定很容易不知不觉创建出了全局变量，ES6为了改变这一点，一方面规定，var命令和function命令声明的全局变量依然是全局对象的属性，同时也规定，let/const/class命令声明的全局变量不属于全局对象的属性。 12345var a = 1;window.a // 1let b = 1;window.b // undefined ES6块级作用域中，声明式函数(function f(){})可以在全局使用，表达式函数不可以new关键字主要做了什么事：- `this.__proto__ = 构造函数.prototype` - `构造函数.prototype.constructor = 构造函数` - `return this` PS： 如果构造函数有返回值，且返回简单类型的值，会被忽略 null和undefinedundefinedundefined不是关键字，不是标识符，是一个全局变量，值为undefined12console.log(Object.getOwnPropertyDescriptor(window,undefined));// &#123;value: undefined, writable: false, enumerable: false, configurable: false&#125; 通过上面的代码可知全局变量的undefined是不可修改不可枚举不配置的，但是可以在局部声明一个新的变量叫undefined；123456function a()&#123; var undefined=10; console.log(window.undefined); // undefined console.log(undefined);// 10&#125;a(); 上面的代码如果出现在项目中会造成一定的问题，为防手误，要做好代码检查。 nullnull是Null类型的唯一值，typeof null返回object，因为特殊值null被认为是一个空对象的引用(指针)【null作为js中七种类型之一，是唯一一个typeof返回的不是自身类型的，贼奇葩】。 所以如果一个值准备存储对象，最好将该变量初始化为null，null==undefined为true（自动转换），null===undefined为false（三等要求类型相同）。 setTimoutsetTimeout从第三个参数起，用来给第一个参数传参1234setTimeout(function(a,b)&#123; console.log(a,b);&#125;,1000,10,20);// 1s之后打印10 20 javascript多行字符串12345678910var str = "当我们能够熟练运用\React进行前端开发时，\不免会对React内部机制产生浓厚的兴趣。\组件是什么？\是真的DOM吗？\生命周期函数的执行依据又是什么呢？"console.log(str);// 当我们能够熟练运用React进行前端开发时，不免会对React内部机制产生浓厚的兴趣。组件是什么？是真的DOM吗？生命周期函数的执行依据又是什么呢？ 使用label语法，跳出多层循环, JavaScript 没有 goto 语句，label标记只能和 break 或 continue 一起使用123456789label:for(var i=0;i&lt;5;i++)&#123; for(var j=0;j&lt;5;j++)&#123; if(i==4)&#123; // break label; continue label; &#125; console.log(i); &#125;&#125; typeof NaN为number，所有数值类型（包括无穷大）只有NaN和0转换为布尔值时为false switch语句在比较值时使用的是全等操作，不会发生类型转换 回调函数：很多人都以为回调函数是异步的，其实与是否同步异步没有关系，是同步还是异步取决于是否需要等待执行结果 正向代理：为客户端提供代理的是正向代理 反向代理：为服务端提供代理的是反向代理 所谓面向对象就是定义了写代码的套路，继承是为了复用代码，封装是为了隐藏细节，多态是为了让代码更灵活，如果面向对象是宗教，你是什么教的]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
        <tag>JS基础笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript笔记之ES6对象的解构赋值]]></title>
    <url>%2Fpost%2F574d9917.html</url>
    <content type="text"><![CDATA[ES6入门教程 ES6允许按照一定的模式，从数组对象和对象中提取值，对变量进行赋值，这被称为解构(Destructuring) 三个规则 如果等号右边不是对象，会尝试转换为对象 只有当等号右边对应的属性值严格等于undefined的时候，等号左边的默认值才能生效 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 数组的解构赋值要求等号右边的对象具备Iterator接口，即只要某种数据结构具备Iterator接口，都可以采用数组的形式解构。 以下数据结构原声具备Iterator接口： Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 Generator 函数 1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 圆括号问题解构赋值虽然很方便，但是对于编译器来说，一个式子到底是模式，还是表达式，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。因此，建议只要有可能，就不要在模式中放置圆括号。 使用圆括号只有一种情况可以使用圆括号：赋值语句的非模式部分，可以使用圆括号。123456// 模式是取数组的第一个成员，跟圆括号无关[(b)] = [3]; // 正确// 模式是p(&#123; p: (d) &#125; = &#123;&#125;); // 正确// 同上面第一句[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 在赋值语句中，等号左边数组的非下标部分和对象的非属性部分可以使用圆括号 不适用圆括号以下三种解构赋值不得使用圆括号。 变量声明语句 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数 函数参数也属于变量声明，因此不能带有圆括号。 1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; 赋值语句的模式 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 用途 交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历map结构 任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map 结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 1234567const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123;console.log(key + " is " + value);&#125; 提取数组的头尾的值 数组也是对象的一种，下面这种方法对于数组和类数组对象尤其有用 12345let arr = [1, 23, 4, 5, 5, 6];let &#123; 0: first, [arr.length - 1]: last &#125; = arr;console.log(first, last);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JS基础笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零碎的html和css]]></title>
    <url>%2Fpost%2F25184d41.html</url>
    <content type="text"><![CDATA[垂直居中通常的做法 height:40px;line-height:40px; 达到垂直居中的效果建议的做法 可以通过 padding 和 line-height 相加来达到，这样比直接设置高度有更多的灵活性，适应性更好。 border和outlineborder占用宽高空间，outline不占用 文字省略溢出word-break: break-all; 单词的中断，当一行显示不下的时候，随意中断单词/数字, 控制如何分行white-space:nowrap; 控制文字如何不换行文字省略溢出12345p&#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 多行文本的溢出效果谷歌上很多。 为什么在两个span之间会出现莫名其妙的空格？ 怎么消除？其实不只是两个 span 之间会出现，所有的 inline 和 inline-block 元素之间存在回车、换行、空格、tab等的任何看不到的字符，显示到页面上都会表现为有一个空格的间隔。 解决办法是使用 浮动，浮动的元素是不遵守上面规则的。 元素的高度和空格如果在页面有这样的代码&lt;div style=&quot;font-size:20px&quot;&gt;123123&lt;/div&gt;，那么这个时候 div 的高度是多少？答：不确定，这个时候是由字体决定，因为此时 div 的 line-height 是字体设计师设计字体的时候的建议行高（设计师觉得这个行高字体排列最好看），而 div 的高度为 字体大小 * 行高，如果字体不同，div 的高度也会不同，所以不确定 div 的高度，可以通过 css 覆盖字体行高。 html 中命名输入了两个空格，为什么页面上只会显示一个，空格的宽度也会不一样？答：空格的宽度也跟字体有关，因为字体设计师在设计的时候给出的建议空格宽度， 两端对齐text-align:justify 为什么两端对齐的没有效果？ 答：text-align:justify只有在多行文字的情况下，才会出现两端对齐，在单行文字的时候，没有相对的参照物。 怎么实现单行两端对齐？ 答： 可以通过在给元素添加一个 after 伪类，并设置伪类display:inline-block，然后设置text-align:justify ，然后指定元素的高度并设置overflow:hidden隐藏超出的 after，这样就实现了多行的效果，text-align:justify也就起作用了，其实文字是对齐了一个看不到的行。12&lt;div&gt;姓名&lt;/div&gt;&lt;div&gt;家庭地址&lt;/div&gt; 1234567891011121314div &#123; width: 120px; text-align: justify; line-height: 30px; height: 30px; overflow: hidden;&#125;div::after &#123; display: inline-block; content: ''; width: 100%; height: 1px;&#125; 设置a标签有href属性时，触摸屏按下的颜色1-webkit-tap-highlight-color:rgba(0,0,0,0); 去除默认情况下，ios中input和button的圆角1-webkit-appearance: none 禁止用户对文字缩放123body *&#123; -webkit-text-size-adjust:none&#125; 当对某元素设置id属性id=someId时, window对象会增加同名属性, 可以通过window[someId]或window.someId引用该元素 getAttribute/setAttribute/removeAttribute操作元素的行间属性，attribute有一个特性是可以获取原始字符串，在获取src、href这样属性的时候，使用getAttribute可以获取源码里写入的值，而dom.src/dom.href获取的是浏览器处理过的值，在不同浏览器下会不一样 node.children获取所有的元素节点，node.childNodes获取所有的节点，包括元素节点、文本节点、注释节点等 p、dt和h1~h6不可以包含块级元素 private在定位的时候不脱离文档流，并且占有原来的位置，position: absolute;的元素是相对于已定位的父元素 ， position: fixed;的元素是相对于ViewPort（可视窗口）， 表格中colspan是横向合并，rowspan是纵向合并，border-collapse:collapse合并表格边框，消除边框间隙,忽略 border-spacing 和 empty-cells 属性 ul是无序的，ol是有序的 dl定义列表，dt定义列表标题，dd定义列表项，dl下有多个dd列表项，只有一个dt标题123456&lt;dl&gt; &lt;dt&gt;我是标题&lt;/dt&gt; &lt;dd&gt;列表项&lt;/dd&gt; &lt;dd&gt;列表项&lt;/dd&gt; &lt;dd&gt;列表项&lt;/dd&gt;&lt;/dl&gt;]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom笔记之querySelectorAll和getElementByXXX]]></title>
    <url>%2Fpost%2F581c5f4a.html</url>
    <content type="text"><![CDATA[原文来自 https://www.zhihu.com/question/24702250/answer/28695133 标准的差异querySelectorAll属于w3c中的selector规范，而getElementBy系列属于w3c的dom规范， 接收参数的不同querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的className、tagName 和 name。 123var c1 = document.querySelectorAll('.b1 .c');var c2 = document.getElementsByClassName('c');var c3 = document.getElementsByClassName('b2')[0].getElementsByClassName('c'); 需要注意的是，querySelectorAll 所接收的参数是必须严格符合 CSS 选择符规范的。所以下面这种写法，将会抛出异常。代码如下 [4]：12345678try &#123; var e1 = document.getElementsByClassName('1a2b3c'); var e2 = document.querySelectorAll('.1a2b3c');&#125; catch (e) &#123; console.error(e.message);&#125;console.log(e1 &amp;&amp; e1[0].className);console.log(e2 &amp;&amp; e2[0].className); （CSS 选择器中的元素名，类和 ID 均不能以数字为开头。） 返回值两者的返回值都是dom节点的集合，区别在于getElementBy系列返回的集合会根据节点的改变动态更新，而querySelectorAll不会动态更新 12345678910111213// Demo 1var ul = document.querySelectorAll('ul')[0], lis = ul.querySelectorAll("li");for(var i = 0; i &lt; lis.length ; i++)&#123; ul.appendChild(document.createElement("li"));&#125;// Demo 2var ul = document.getElementsByTagName('ul')[0], lis = ul.getElementsByTagName("li"); for(var i = 0; i &lt; lis.length ; i++)&#123; ul.appendChild(document.createElement("li")); &#125; 因为 Demo 2 中的 lis 是一个动态的 Node List, 每一次使用 lis 都会重新对文档进行查询，导致无限循环的问题。而 Demo 1 中的 lis 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。 但为什么要这样设计呢？其实，在 W3C 规范中对 querySelectorAll 方法有明确规定 [6]： The NodeList object returned by the querySelectorAll() method must be static ([DOM], section 8). 那什么是 NodeList 呢？W3C 中是这样说明的 [7]： The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live. 所以，NodeList 本质上是一个动态的 Node 集合，只是规范中对 querySelectorAll 有明确要求，规定其必须返回一个静态的 NodeList 对象。我们再看看两者的返回类型：12document.querySelectorAll('a').toString(); // return "[object NodeList]"document.getElementsByTagName('a').toString(); // return "[object HTMLCollection]" 这里又多了一个 HTMLCollection 对象出来，那 HTMLCollection 又是什么？HTMLCollection 在 W3C 的定义如下 [8]： An HTMLCollection is a list of nodes. An individual node may be accessed by either ordinal index or the node’s name or id attributes.Note: Collections in the HTML DOM are assumed to be live meaning that they are automatically updated when the underlying document is changed. 实际上，HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。这样说有点难理解，看看下面的例子会比较好理解 [9]： 12345var ul = document.getElementsByTagName('ul')[0], lis1 = ul.childNodes, lis2 = ul.children;console.log(lis1.toString(), lis1.length); // "[object NodeList]" 11console.log(lis2.toString(), lis2.length); // "[object HTMLCollection]" 4 NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。所以在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象 。 NodeList是Node的集合一样，ElementCollection也是Element的集合。但需要特别注意的是：NodeList和ElementCollcetion都不是真正的数组 总结query选择符选出来的元素及元素数组是静态的，而getElement这种方法选出的元素是动态的。静态的就是说选出的所有元素的数组，不会随着文档操作而改变。在使用的时候getElement这种方法性能比较好，query选择符则比较方便。 完！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom笔记之设置和获取样式]]></title>
    <url>%2Fpost%2F817b1e48.html</url>
    <content type="text"><![CDATA[行间样式下面的代码只能操作行间样式 cssText 的本质就是设置 HTML 元素的 style 属性值, 与getAttribute(&quot;style&quot;)不同之处在于cssText会对格式做处理，而getAttribute原样返回 123456789&lt;div style="color:red;font-size:14px;" id="dom"&gt;welcome&lt;/div&gt;&lt;script&gt;var dom=document.querySelector("#dom");console.log(domd.style.cssText); // color: red; font-size: 14px;console.log(dom.getAttribute("style")); // color:red;font-size:14px;// 设置值的时候，会把原来的行间样式清空，重新设置dom.style.cssText = "width:100px;height:200px;"console.log(dom.style.cssText); // width: 100px; height: 200px;&lt;/script&gt; length表示设置了多少样式 1var length = dom.style.length; // 2 getPropertyValue/setProperty/removeProperty这是三个api用来对单独的样式属性进行操作 123456// 获取指定样式属性的值，不能够使用fontSizedom.style.getPropertyValue("font-size");// 可以接受三个参数，第一个是属性名称，第二个是属性值，第三个是importantdom.style.setProperty("color", "blue", "important");// 删除行间样式的属性dom.style.removeProperty("color"); getPropertyPriority判断行间样式是否设置了important，如果设置了，那么返回important，如果没有设置，那么返回空 1dom.style.getPropertyPriority("color") cssFloat和styleFloat因为float是关键子，所以没有办法通过dom.style.float这样直接使用，cssFloat就是替代方式。 12345dom.style.cssFloat="left";// 等价于dom.style["float"]="left";// 兼容IE9一下的浏览器dom.style.styleFloat="left"; 封装style函数用来获取和设置行间样式1234567function style(dom,attr,val) &#123; if(arguments.length === 2) &#123; return dom.style[attr]; &#125; else if(arguments.length === 3) &#123; return dom.style[attr] = val; &#125;&#125; 计算后的样式在chrome下可以看到一个computed的页签，里面就是浏览器计算过的样式，那么怎么通过js获取到计算后的属性值呢？ 就是通过window.getComputedStyle(dom)[styleAttr]，需要兼容ie9一下，使用dom.currentStyle[styleAttr],styleAttr遵循驼峰命名。1234567891011function css(dom,styleAttr)&#123; if(dom.currentStyle)&#123; return dom.currentStyle[styleAttr]; //IE下兼容 &#125;else&#123; return getComputedStyle(dom,false)[styleAttr]; //非IE下兼容 &#125;&#125;console.log(css(dom,"float")); 总结完！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记之link和@import]]></title>
    <url>%2Fpost%2Fcf849149.html</url>
    <content type="text"><![CDATA[使用方式这是两种不同的引入外部样式的写法：123456&lt;link rel='stylesheet' href='a.css'&gt;Or you can use the @import rule:&lt;style&gt;@import url('a.css');&lt;/style&gt; 注意在《CSS权威指南》中写道： @import一定要写在除@charset外的其他任何 CSS 规则之前，如果置于其它位置将会被浏览器忽略，而且，在@import之后如果存在其它样式，则@import之后的分号是必须书写，不可省略的。 区别 @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。 加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。 可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。 link没有兼容性问题，@import是 CSS2.1 才有的语法，故只支持IE5+， 可以忽略建议 强烈建议使用link标签，慎用@import方式，这样可以避免考虑@import的语法规则和注意事项，避免产生资源文件下载顺序混乱和http请求过多的烦恼。]]></content>
      <categories>
        <category>html/css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防止网站页面被其他网站iframe引用方法]]></title>
    <url>%2Fpost%2Fc1ee2ca.html</url>
    <content type="text"><![CDATA[在响应头里加一个X-Frame-Options其取值有三种，大部分浏览器都支持：123DENY： 浏览器拒绝当前页面被任何Frame页面嵌套SAMEORIGIN： frame页面的地址只能在同源域名下被嵌套ALLOW-FROM [url]： 页面只能被指定的url嵌入到iframe或 frame中 nginx配置1add_header X-Frame-Options SAMEORIGIN apache配置1Header always append X-Frame-Options SAMEORIGIN 页面meta配置1&lt;meta http-equiv="X-Frame-Options" content="deny"&gt; js脚本判断123456789101112//方式一 if (self.frameElement &amp;&amp; self.frameElement.tagName == "IFRAME") &#123; location.href = "about:blank";&#125;//方式二 if (window.frames.length != parent.frames.length) &#123; location.href = "about:blank";&#125;//方式三 if (self != top) &#123; location.href = "about:blank";&#125; 禁用iframe内的JS脚本1&lt;noscript&gt;&lt;iframe src=fillseo.html&gt;&lt;/iframe&gt;&lt;/noscript&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[签名 学习是一条令人时而喜极若狂、时而郁郁寡欢的道路。 个人信息 网名：星木（xingmu），略懂JS、HTML/CSS、NODEJS、JAJA，linux，欢迎沟通交流。 关于Blog本站是使用 Hexo 搭建，镜像托管在 Github 之上，博客主题使用的是非常漂亮、简洁的 Next 主题。 本站是为了个人交流学习而搭建，本站内容若非注明【转】均来自本人撰写，转载必会注明原文引用地址，若您认为侵犯你的个人知识产权，请联系我(daixingmu@qq.com)，我会第一时间和您进行沟通处理。若你喜欢本站内容，欢迎转载，但请注明出处，且勿用于商业用途，谢谢！！！ 联系方式 邮箱：daixingmu@qq.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
